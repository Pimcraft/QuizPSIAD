[
  {
    "type": "simple_select",
    "question": "Który algorytm jest klasycznym przykładem algorytmu nadzorowanego?",
    "options": {
      "A": "K-means",
      "B": "Drzewo decyzyjne",
      "C": "Apriori",
      "D": "t-SNE"
    },
    "correct": "B",
    "explanation": "Drzewo decyzyjne to klasyczny algorytm nadzorowany, ponieważ uczy się na danych z etykietami.",
    "auto_id": 1
  },
  {
    "type": "simple_select",
    "question": "W uczeniu nadzorowanym wymagane są:",
    "options": {
      "A": "Zbiory danych bez etykiet",
      "B": "Zbiory danych z etykietami",
      "C": "Struktury hierarchiczne",
      "D": "Sieci neuronowe"
    },
    "correct": "B",
    "explanation": "Uczenie nadzorowane wymaga danych z etykietami, by model mógł uczyć się poprawnych wyników.",
    "auto_id": 2
  },
  {
    "type": "simple_select",
    "question": "Który z poniższych algorytmów służy do regresji?",
    "options": {
      "A": "KNN",
      "B": "Regresja liniowa",
      "C": "PCA",
      "D": "DBSCAN"
    },
    "correct": "B",
    "explanation": "Regresja liniowa jest klasycznym algorytmem nadzorowanym do przewidywania wartości ciągłych.",
    "auto_id": 3
  },
  {
    "type": "simple_select",
    "question": "Czym różni się klasyfikacja od regresji?",
    "options": {
      "A": "Klasyfikacja przewiduje liczby, regresja etykiety",
      "B": "Klasyfikacja wymaga danych bez etykiet",
      "C": "Klasyfikacja przypisuje do klas, regresja przewiduje wartości liczbowe",
      "D": "Niczym"
    },
    "correct": "C",
    "explanation": "Klasyfikacja przypisuje dane do kategorii, a regresja przewiduje wartości liczbowe.",
    "auto_id": 4
  },
  {
    "type": "simple_select",
    "question": "Które zastosowanie najlepiej pasuje do klasyfikacji?",
    "options": {
      "A": "Prognozowanie temperatury",
      "B": "Identyfikacja spamu w e-mailach",
      "C": "Szeregowanie zadań",
      "D": "Klasteryzacja klientów"
    },
    "correct": "B",
    "explanation": "Identyfikacja spamu to przykład problemu klasyfikacyjnego – e-mail jest spamem lub nie.",
    "auto_id": 5
  },
  {
    "type": "simple_select",
    "question": "Jaką rolę pełni funkcja kosztu (loss function) w uczeniu nadzorowanym?",
    "options": {
      "A": "Losuje dane wejściowe",
      "B": "Określa strukturę modelu",
      "C": "Mierzy różnicę między przewidywaniami a rzeczywistością",
      "D": "Optymalizuje bazę danych"
    },
    "correct": "C",
    "explanation": "Funkcja kosztu mierzy, jak bardzo przewidywania modelu różnią się od rzeczywistych wartości.",
    "auto_id": 6
  },
  {
    "type": "simple_select",
    "question": "Który algorytm najlepiej nadaje się do klasyfikacji binarnej?",
    "options": {
      "A": "Regresja logistyczna",
      "B": "DBSCAN",
      "C": "K-means",
      "D": "PCA"
    },
    "correct": "A",
    "explanation": "Regresja logistyczna doskonale sprawdza się w problemach klasyfikacji binarnej.",
    "auto_id": 7
  },
  {
    "type": "simple_select",
    "question": "Co jest przykładem etykiety w zbiorze uczącym?",
    "options": {
      "A": "Adres IP",
      "B": "Kod pocztowy",
      "C": "Czy klient kupił produkt (tak/nie)",
      "D": "Kolor strony"
    },
    "correct": "C",
    "explanation": "Tak/Nie to klasyczna etykieta binarna – wykorzystywana do uczenia nadzorowanego.",
    "auto_id": 8
  },
  {
    "type": "simple_select",
    "question": "Jakim typem problemu jest „rozpoznawanie cyfr odręcznych”?",
    "options": {
      "A": "Regresja",
      "B": "Klasyfikacja wieloklasowa",
      "C": "Uczenie nienadzorowane",
      "D": "Reinforcement learning"
    },
    "correct": "B",
    "explanation": "Rozpoznawanie cyfr to klasyfikacja do 10 klas (0–9).",
    "auto_id": 9
  },
  {
    "type": "simple_select",
    "question": "Co oznacza overfitting w kontekście uczenia nadzorowanego?",
    "options": {
      "A": "Model nie uczy się wystarczająco",
      "B": "Model uczy się na błędnych danych",
      "C": "Model działa tylko dobrze na danych treningowych",
      "D": "Model działa lepiej niż oczekiwano"
    },
    "correct": "C",
    "explanation": "Overfitting to zbyt mocne dopasowanie do danych treningowych, przez co model nie generalizuje.",
    "auto_id": 10
  },
  {
    "type": "simple_select",
    "question": "W jakim celu dzieli się dane na zbiór treningowy i testowy?",
    "options": {
      "A": "By zróżnicować dane wejściowe",
      "B": "By przyspieszyć uczenie",
      "C": "By móc ocenić działanie modelu na nowych danych",
      "D": "By zmniejszyć liczbę danych"
    },
    "correct": "C",
    "explanation": "Zbiór testowy służy do oceny modelu – czy działa na danych, których nie widział podczas uczenia.",
    "auto_id": 11
  },
  {
    "type": "simple_select",
    "question": "Który z poniższych NIE jest algorytmem nadzorowanym?",
    "options": {
      "A": "SVM",
      "B": "Random Forest",
      "C": "K-means",
      "D": "Regresja logistyczna"
    },
    "correct": "C",
    "explanation": "K-means to algorytm nienadzorowany – nie używa etykiet.",
    "auto_id": 12
  },
  {
    "type": "simple_select",
    "question": "Który z poniższych mierników jest używany do oceny klasyfikatorów?",
    "options": {
      "A": "MSE",
      "B": "Dokładność (accuracy)",
      "C": "Silhouette score",
      "D": "Entropy"
    },
    "correct": "B",
    "explanation": "Dokładność to podstawowa miara skuteczności klasyfikatora.",
    "auto_id": 13
  },
  {
    "type": "simple_select",
    "question": "Do czego służy walidacja krzyżowa (cross-validation)?",
    "options": {
      "A": "Do treningu sieci neuronowej",
      "B": "Do optymalizacji hiperparametrów",
      "C": "Do badania stabilności modelu",
      "D": "Do porównania baz danych"
    },
    "correct": "C",
    "explanation": "Cross-validation ocenia, jak model radzi sobie na różnych podzbiorach danych.",
    "auto_id": 14
  },
  {
    "type": "simple_select",
    "question": "Który algorytm tworzy „las drzew”?",
    "options": {
      "A": "XGBoost",
      "B": "SVM",
      "C": "Random Forest",
      "D": "Gradient Descent"
    },
    "correct": "C",
    "explanation": "Random Forest to zespół wielu drzew decyzyjnych, tzw. „las”.",
    "auto_id": 15
  },
  {
    "type": "multi_select",
    "question": "Które algorytmy należą do uczenia nadzorowanego?",
    "options": {
      "A": "KNN",
      "B": "K-means",
      "C": "Regresja liniowa",
      "D": "Apriori"
    },
    "correct": [
      "A",
      "C"
    ],
    "explanation": "KNN i regresja liniowa to algorytmy nadzorowane. K-means i Apriori są nienadzorowane.",
    "auto_id": 16
  },
  {
    "type": "multi_select",
    "question": "W jakich zastosowaniach można użyć uczenia nadzorowanego?",
    "options": {
      "A": "Wykrywanie spamu",
      "B": "Rekomendacje produktów",
      "C": "Segmentacja klientów",
      "D": "Przewidywanie cen mieszkań"
    },
    "correct": [
      "A",
      "D"
    ],
    "explanation": "Spam i ceny mieszkań to klasyfikacja i regresja – klasyczne zastosowania uczenia nadzorowanego.",
    "auto_id": 17
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy procesu tworzenia modelu nadzorowanego",
    "steps": [
      "Zbieranie danych",
      "Przygotowanie danych",
      "Trenowanie modelu",
      "Testowanie modelu",
      "Ocena modelu"
    ],
    "correct": [
      "Zbieranie danych",
      "Przygotowanie danych",
      "Trenowanie modelu",
      "Testowanie modelu",
      "Ocena modelu"
    ],
    "explanation": "To klasyczny przepływ pracy w projekcie ML z nadzorowanym modelem.",
    "auto_id": 18
  },
  {
    "type": "order",
    "question": "Uporządkuj algorytmy wg ich złożoności obliczeniowej (rosnąco)",
    "steps": [
      "Regresja liniowa",
      "Drzewo decyzyjne",
      "KNN",
      "SVM",
      "Random Forest"
    ],
    "correct": [
      "Regresja liniowa",
      "Drzewo decyzyjne",
      "KNN",
      "SVM",
      "Random Forest"
    ],
    "explanation": "Porządek bazuje na typowych przypadkach i złożoności algorytmów.",
    "auto_id": 19
  },
  {
    "type": "order",
    "question": "Uporządkuj poniższe działania w procesie regresji liniowej",
    "steps": [
      "Wybór zmiennych",
      "Wyznaczenie funkcji straty",
      "Trenowanie modelu",
      "Ocena współczynnika determinacji (R^2)",
      "Wizualizacja wyników"
    ],
    "correct": [
      "Wybór zmiennych",
      "Wyznaczenie funkcji straty",
      "Trenowanie modelu",
      "Ocena współczynnika determinacji (R^2)",
      "Wizualizacja wyników"
    ],
    "explanation": "To naturalny ciąg kroków w zadaniu regresji liniowej.",
    "auto_id": 20
  },
  {
    "type": "simple_select",
    "question": "Czym jest głębokie uczenie (deep learning)?",
    "options": {
      "A": "Uczenie z udziałem człowieka",
      "B": "Uczenie oparte na wielu warstwach sieci neuronowych",
      "C": "Uczenie oparte na klastrach",
      "D": "Uczenie bez użycia danych"
    },
    "correct": "B",
    "explanation": "Głębokie uczenie polega na wykorzystaniu wielu warstw ukrytych w sieciach neuronowych.",
    "auto_id": 21
  },
  {
    "type": "simple_select",
    "question": "Która architektura sieci neuronowej najlepiej nadaje się do analizy obrazów?",
    "options": {
      "A": "RNN",
      "B": "CNN",
      "C": "LSTM",
      "D": "GAN"
    },
    "correct": "B",
    "explanation": "CNN (Convolutional Neural Network) to sieci wyspecjalizowane w przetwarzaniu obrazów.",
    "auto_id": 22
  },
  {
    "type": "simple_select",
    "question": "Jaką funkcję pełni warstwa aktywacyjna ReLU?",
    "options": {
      "A": "Normalizuje dane",
      "B": "Redukuje liczbę parametrów",
      "C": "Wprowadza nieliniowość",
      "D": "Optymalizuje wagę sieci"
    },
    "correct": "C",
    "explanation": "ReLU (Rectified Linear Unit) pozwala wprowadzić nieliniowość do modelu.",
    "auto_id": 23
  },
  {
    "type": "simple_select",
    "question": "Jakie dane najlepiej nadają się do przetwarzania przez RNN?",
    "options": {
      "A": "Dane statyczne",
      "B": "Obrazy",
      "C": "Dane sekwencyjne",
      "D": "Zbiory niezależnych obserwacji"
    },
    "correct": "C",
    "explanation": "RNN (Recurrent Neural Network) służy do analizy danych sekwencyjnych, jak tekst czy sygnał.",
    "auto_id": 24
  },
  {
    "type": "simple_select",
    "question": "Która warstwa w CNN odpowiada za redukcję wymiarów?",
    "options": {
      "A": "Warstwa w pełni połączona",
      "B": "Warstwa konwolucyjna",
      "C": "Warstwa aktywacyjna",
      "D": "Warstwa poolingowa"
    },
    "correct": "D",
    "explanation": "Warstwa poolingowa (np. MaxPooling) zmniejsza wymiar danych, ułatwiając przetwarzanie.",
    "auto_id": 25
  },
  {
    "type": "simple_select",
    "question": "Do czego służy propagacja wsteczna (backpropagation)?",
    "options": {
      "A": "Do zbierania danych",
      "B": "Do losowania wag",
      "C": "Do aktualizacji wag na podstawie błędu",
      "D": "Do przewidywania wyniku"
    },
    "correct": "C",
    "explanation": "Backpropagation pozwala na aktualizację wag, ucząc sieć neuronową.",
    "auto_id": 26
  },
  {
    "type": "simple_select",
    "question": "Jakie zastosowanie głębokiego uczenia jest typowe w medycynie?",
    "options": {
      "A": "Automatyczne testy jednostkowe",
      "B": "Rozpoznawanie chorób na podstawie obrazów medycznych",
      "C": "Analiza plików PDF",
      "D": "Kompresja danych"
    },
    "correct": "B",
    "explanation": "Głębokie uczenie (np. CNN) jest wykorzystywane do analizy obrazów RTG, MRI itd.",
    "auto_id": 27
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych to architektury głębokiego uczenia?",
    "options": {
      "A": "CNN",
      "B": "RNN",
      "C": "Random Forest",
      "D": "LSTM"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "CNN, RNN i LSTM to architektury sieci neuronowych wykorzystywane w deep learningu.",
    "auto_id": 28
  },
  {
    "type": "multi_select",
    "question": "W jakich dziedzinach informatyki stosuje się deep learning?",
    "options": {
      "A": "Rozpoznawanie mowy",
      "B": "Zarządzanie projektami",
      "C": "Rozpoznawanie obrazów",
      "D": "Analiza języka naturalnego (NLP)"
    },
    "correct": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Deep learning znajduje zastosowanie w mowie, obrazach i NLP. Zarządzanie projektami nie wymaga DL.",
    "auto_id": 29
  },
  {
    "type": "multi_select",
    "question": "Które techniki wspomagają proces uczenia w sieciach neuronowych?",
    "options": {
      "A": "Normalizacja danych",
      "B": "Dropout",
      "C": "Gradient descent",
      "D": "Czyszczenie kodu"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Normalizacja, dropout i gradient descent pomagają w poprawnym działaniu modelu.",
    "auto_id": 30
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są funkcjami aktywacji?",
    "options": {
      "A": "ReLU",
      "B": "Sigmoid",
      "C": "Tanh",
      "D": "Softmax"
    },
    "correct": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Wszystkie wymienione są funkcjami aktywacji w sieciach neuronowych.",
    "auto_id": 31
  },
  {
    "type": "multi_select",
    "question": "Które problemy może rozwiązywać GAN (Generative Adversarial Network)?",
    "options": {
      "A": "Generowanie obrazów",
      "B": "Odtwarzanie brakujących danych",
      "C": "Klasyfikacja tekstu"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "GAN potrafi generować realistyczne obrazy, uzupełniać braki i tworzyć deepfake.",
    "auto_id": 32
  },
  {
    "type": "multi_select",
    "question": "Które elementy składają się na warstwę konwolucyjną?",
    "options": {
      "A": "Filtry",
      "B": "Bias",
      "C": "Funkcja aktywacji",
      "D": "Krawędziowanie Laplace’a"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Warstwa konwolucyjna zawiera filtry, bias i aktywację – nie Laplace’a.",
    "auto_id": 33
  },
  {
    "type": "multi_select",
    "question": "Które podejścia zwiększają dokładność sieci neuronowych?",
    "options": {
      "A": "Zwiększenie liczby epok",
      "B": "Użycie większej liczby danych treningowych",
      "C": "Overfitting",
      "D": "Augmentacja danych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Więcej danych i epok oraz augmentacja zwykle poprawiają jakość modelu – overfitting wręcz przeciwnie.",
    "auto_id": 34
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki procesu trenowania sieci neuronowej",
    "steps": [
      "Przygotowanie danych",
      "Inicjalizacja wag",
      "Propagacja w przód",
      "Obliczenie błędu",
      "Backpropagation",
      "Aktualizacja wag"
    ],
    "correct": [
      "Przygotowanie danych",
      "Inicjalizacja wag",
      "Propagacja w przód",
      "Obliczenie błędu",
      "Backpropagation",
      "Aktualizacja wag"
    ],
    "explanation": "To typowy cykl uczenia w sieciach neuronowych.",
    "auto_id": 35
  },
  {
    "type": "order",
    "question": "Uporządkuj warstwy w klasycznej CNN",
    "steps": [
      "Warstwa wejściowa",
      "Warstwa konwolucyjna",
      "Pooling",
      "Warstwa w pełni połączona",
      "Wyjście"
    ],
    "correct": [
      "Warstwa wejściowa",
      "Warstwa konwolucyjna",
      "Pooling",
      "Warstwa w pełni połączona",
      "Wyjście"
    ],
    "explanation": "Taki układ warstw jest typowy dla CNN.",
    "auto_id": 36
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki przy użyciu RNN do analizy sekwencji",
    "steps": [
      "Podanie sekwencji wejściowej",
      "Przekazanie do warstwy RNN",
      "Przetwarzanie kolejnych kroków czasowych",
      "Zebranie stanu ukrytego",
      "Uzyskanie wyjścia końcowego"
    ],
    "correct": [
      "Podanie sekwencji wejściowej",
      "Przekazanie do warstwy RNN",
      "Przetwarzanie kolejnych kroków czasowych",
      "Zebranie stanu ukrytego",
      "Uzyskanie wyjścia końcowego"
    ],
    "explanation": "Tak działa przetwarzanie sekwencji w RNN.",
    "auto_id": 37
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy przygotowania danych do sieci neuronowej",
    "steps": [
      "Zbieranie danych",
      "Czyszczenie danych",
      "Normalizacja",
      "Podział na zbiory treningowe i testowe",
      "Kodowanie kategorii"
    ],
    "correct": [
      "Zbieranie danych",
      "Czyszczenie danych",
      "Kodowanie kategorii",
      "Normalizacja",
      "Podział na zbiory treningowe i testowe"
    ],
    "explanation": "Kodowanie i normalizacja powinny poprzedzać podział danych.",
    "auto_id": 38
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy działania GAN",
    "steps": [
      "Losowy szum",
      "Generowanie danych przez generator",
      "Ocena przez dyskryminator",
      "Obliczenie błędu",
      "Aktualizacja wag generatora i dyskryminatora"
    ],
    "correct": [
      "Losowy szum",
      "Generowanie danych przez generator",
      "Ocena przez dyskryminator",
      "Obliczenie błędu",
      "Aktualizacja wag generatora i dyskryminatora"
    ],
    "explanation": "To klasyczny schemat działania GAN.",
    "auto_id": 39
  },
  {
    "type": "order",
    "question": "Uporządkuj warstwy typowego modelu LSTM",
    "steps": [
      "Warstwa wejściowa",
      "Warstwa LSTM",
      "Warstwa w pełni połączona",
      "Warstwa aktywacyjna",
      "Wyjście"
    ],
    "correct": [
      "Warstwa wejściowa",
      "Warstwa LSTM",
      "Warstwa w pełni połączona",
      "Warstwa aktywacyjna",
      "Wyjście"
    ],
    "explanation": "LSTM działa na sekwencjach, po czym następują warstwy klasyfikujące.",
    "auto_id": 40
  },
  {
    "type": "simple_select",
    "question": "Czym są algorytmy genetyczne?",
    "options": {
      "A": "Metoda sortowania danych",
      "B": "Technika klasyfikacji obrazów",
      "C": "Heurystyczna metoda optymalizacji inspirowana ewolucją biologiczną",
      "D": "Rodzaj algorytmu regresji"
    },
    "correct": "C",
    "explanation": "Algorytmy genetyczne naśladują mechanizmy ewolucji, takie jak dobór naturalny i krzyżowanie.",
    "auto_id": 41
  },
  {
    "type": "simple_select",
    "question": "Jaki operator odpowiada za „rozmnażanie” w algorytmach genetycznych?",
    "options": {
      "A": "Selekcja",
      "B": "Krzyżowanie",
      "C": "Mutacja",
      "D": "Ocena dopasowania"
    },
    "correct": "B",
    "explanation": "Operator krzyżowania (crossover) łączy osobniki, tworząc nowe rozwiązania.",
    "auto_id": 42
  },
  {
    "type": "simple_select",
    "question": "Czym jest funkcja przystosowania (fitness function)?",
    "options": {
      "A": "Mechanizm selekcji danych",
      "B": "Metoda sortowania populacji",
      "C": "Miara oceny jakości rozwiązania",
      "D": "Technika wizualizacji"
    },
    "correct": "C",
    "explanation": "Funkcja przystosowania ocenia, jak dobre jest dane rozwiązanie.",
    "auto_id": 43
  },
  {
    "type": "simple_select",
    "question": "W jakim celu stosuje się mutację w algorytmach genetycznych?",
    "options": {
      "A": "Aby przyspieszyć krzyżowanie",
      "B": "Aby uniknąć lokalnych minimów",
      "C": "Aby zmniejszyć liczbę osobników",
      "D": "Aby zatrzymać ewolucję"
    },
    "correct": "B",
    "explanation": "Mutacja wprowadza losowość, co pozwala przeszukiwać nowe obszary przestrzeni rozwiązań.",
    "auto_id": 44
  },
  {
    "type": "simple_select",
    "question": "Który element NIE należy do podstawowego cyklu algorytmu genetycznego?",
    "options": {
      "A": "Mutacja",
      "B": "Krzyżowanie",
      "C": "Uczenie nadzorowane",
      "D": "Selekcja"
    },
    "correct": "C",
    "explanation": "Uczenie nadzorowane to osobna kategoria metod ML, nie element algorytmu genetycznego.",
    "auto_id": 45
  },
  {
    "type": "simple_select",
    "question": "Co oznacza pojęcie „populacja” w kontekście algorytmów genetycznych?",
    "options": {
      "A": "Zestaw danych wejściowych",
      "B": "Zbiór możliwych rozwiązań",
      "C": "Baza wiedzy",
      "D": "Drzewo decyzyjne"
    },
    "correct": "B",
    "explanation": "Populacja to zbiór aktualnych rozwiązań, które poddawane są ewolucji.",
    "auto_id": 46
  },
  {
    "type": "simple_select",
    "question": "W jakim zastosowaniu algorytmy genetyczne są szczególnie skuteczne?",
    "options": {
      "A": "Sortowanie alfabetyczne",
      "B": "Problemy optymalizacyjne z dużą przestrzenią rozwiązań",
      "C": "Bazy danych",
      "D": "Uczenie z nauczycielem"
    },
    "correct": "B",
    "explanation": "Algorytmy genetyczne dobrze radzą sobie w skomplikowanych problemach optymalizacji.",
    "auto_id": 47
  },
  {
    "type": "multi_select",
    "question": "Które etapy wchodzą w skład algorytmu genetycznego?",
    "options": {
      "A": "Selekcja",
      "B": "Krzyżowanie",
      "C": "Mutacja",
      "D": "Redukcja szumów"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Redukcja szumów to termin spoza klasycznych etapów AG.",
    "auto_id": 48
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są operatorami genetycznymi?",
    "options": {
      "A": "Selekcja",
      "B": "Krzyżowanie",
      "C": "Mutacja",
      "D": "Walidacja krzyżowa"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Walidacja krzyżowa to metoda oceny modeli ML, nie operator AG.",
    "auto_id": 49
  },
  {
    "type": "multi_select",
    "question": "Jakie zastosowania mają algorytmy genetyczne w informatyce?",
    "options": {
      "A": "Optymalizacja harmonogramów",
      "B": "Szyfrowanie danych",
      "C": "Tworzenie sieci neuronowych",
      "D": "Kompresja zdjęć"
    },
    "correct": [
      "A",
      "C"
    ],
    "explanation": "AG wykorzystywane są do optymalizacji i wstępnej konfiguracji architektur sieci.",
    "auto_id": 50
  },
  {
    "type": "multi_select",
    "question": "Jakie zalety mają algorytmy genetyczne?",
    "options": {
      "A": "Odporność na lokalne minima",
      "B": "Elastyczność przy różnych typach danych",
      "C": "Szybkość porównywalna z wyszukiwaniem liniowym",
      "D": "Możliwość równoległego przetwarzania"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "AG są elastyczne, odporne na lokalne minima i dobrze skalowalne dzięki przetwarzaniu równoległemu.",
    "auto_id": 51
  },
  {
    "type": "multi_select",
    "question": "Które techniki mogą wspierać algorytmy genetyczne?",
    "options": {
      "A": "Sieci neuronowe",
      "B": "Symulowane wyżarzanie",
      "C": "Drzewa decyzyjne",
      "D": "Metody Monte Carlo"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "AG mogą być łączone z innymi technikami optymalizacyjnymi lub ML.",
    "auto_id": 52
  },
  {
    "type": "multi_select",
    "question": "Czym mogą być reprezentowane osobniki w AG?",
    "options": {
      "A": "Ciągi binarne",
      "B": "Listy wartości numerycznych",
      "C": "Grafy",
      "D": "Pliki .doc"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Osobniki mogą mieć różną reprezentację, zależnie od problemu – pliki .doc nie są typowe.",
    "auto_id": 53
  },
  {
    "type": "multi_select",
    "question": "Które problemy można rozwiązać algorytmami genetycznymi?",
    "options": {
      "A": "Problem komiwojażera",
      "B": "Optymalizacja tras",
      "C": "Kompilacja kodu źródłowego",
      "D": "Dobór parametrów modeli ML"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "AG świetnie sprawdzają się przy problemach kombinatorycznych i optymalizacji hiperparametrów.",
    "auto_id": 54
  },
  {
    "type": "order",
    "question": "Uporządkuj główne etapy algorytmu genetycznego",
    "steps": [
      "Inicjalizacja populacji",
      "Ocena przystosowania",
      "Selekcja",
      "Krzyżowanie",
      "Mutacja",
      "Nowa populacja"
    ],
    "correct": [
      "Inicjalizacja populacji",
      "Ocena przystosowania",
      "Selekcja",
      "Krzyżowanie",
      "Mutacja",
      "Nowa populacja"
    ],
    "explanation": "To klasyczny cykl działania AG.",
    "auto_id": 55
  },
  {
    "type": "order",
    "question": "Uporządkuj operacje na pojedynczym osobniku podczas ewolucji",
    "steps": [
      "Ocena przystosowania",
      "Wybranie do krzyżowania",
      "Krzyżowanie",
      "Mutacja",
      "Reinsercja do populacji"
    ],
    "correct": [
      "Ocena przystosowania",
      "Wybranie do krzyżowania",
      "Krzyżowanie",
      "Mutacja",
      "Reinsercja do populacji"
    ],
    "explanation": "Każdy osobnik przechodzi te kroki w cyklu AG.",
    "auto_id": 56
  },
  {
    "type": "order",
    "question": "Uporządkuj zastosowania AG od najprostszych do bardziej złożonych",
    "steps": [
      "Optymalizacja funkcji matematycznej",
      "Dobór parametrów modelu",
      "Planowanie produkcji",
      "Symulacja zachowań organizmu"
    ],
    "correct": [
      "Optymalizacja funkcji matematycznej",
      "Dobór parametrów modelu",
      "Planowanie produkcji",
      "Symulacja zachowań organizmu"
    ],
    "explanation": "AG są stosowane w coraz bardziej złożonych obszarach.",
    "auto_id": 57
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy implementacji AG",
    "steps": [
      "Zdefiniowanie reprezentacji",
      "Zaprojektowanie funkcji przystosowania",
      "Ustalenie operatorów genetycznych",
      "Zaprogramowanie algorytmu",
      "Testowanie i analiza"
    ],
    "correct": [
      "Zdefiniowanie reprezentacji",
      "Zaprojektowanie funkcji przystosowania",
      "Ustalenie operatorów genetycznych",
      "Zaprogramowanie algorytmu",
      "Testowanie i analiza"
    ],
    "explanation": "Etapy projektowania i implementacji AG w praktyce.",
    "auto_id": 58
  },
  {
    "type": "order",
    "question": "Uporządkuj działania podczas selekcji turniejowej",
    "steps": [
      "Wybór losowych osobników",
      "Ocena ich przystosowania",
      "Porównanie wyników",
      "Wybór najlepszego"
    ],
    "correct": [
      "Wybór losowych osobników",
      "Ocena ich przystosowania",
      "Porównanie wyników",
      "Wybór najlepszego"
    ],
    "explanation": "Selekcja turniejowa opiera się na losowo wybranych pojedynkach.",
    "auto_id": 59
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki w adaptacyjnym AG",
    "steps": [
      "Dostosowanie parametrów mutacji",
      "Dostosowanie parametrów krzyżowania",
      "Ewolucja populacji",
      "Ocena jakości adaptacji"
    ],
    "correct": [
      "Dostosowanie parametrów mutacji",
      "Dostosowanie parametrów krzyżowania",
      "Ewolucja populacji",
      "Ocena jakości adaptacji"
    ],
    "explanation": "AG adaptacyjne modyfikują parametry w trakcie działania.",
    "auto_id": 60
  },
  {
    "type": "simple_select",
    "question": "Czym jest system rozproszony?",
    "options": {
      "A": "System działający na jednym serwerze",
      "B": "System składający się z wielu niezależnych komputerów współpracujących jako całość",
      "C": "System działający w przeglądarce",
      "D": "System do zarządzania plikami"
    },
    "correct": "B",
    "explanation": "System rozproszony składa się z wielu węzłów, które współpracują ze sobą w celu realizacji wspólnego zadania.",
    "auto_id": 61
  },
  {
    "type": "simple_select",
    "question": "Który z poniższych jest przykładem systemu rozproszonego?",
    "options": {
      "A": "MS Word",
      "B": "Google Docs",
      "C": "Adobe Photoshop",
      "D": "Notepad++"
    },
    "correct": "B",
    "explanation": "Google Docs to aplikacja działająca w chmurze, z możliwością współpracy wielu użytkowników – typowy przykład systemu rozproszonego.",
    "auto_id": 62
  },
  {
    "type": "simple_select",
    "question": "Który problem jest charakterystyczny dla systemów rozproszonych?",
    "options": {
      "A": "Mało pamięci RAM",
      "B": "Wysoka temperatura procesora",
      "C": "Brak wspólnego zegara systemowego",
      "D": "Zbyt duża ilość myszek podłączonych do systemu"
    },
    "correct": "C",
    "explanation": "W systemach rozproszonych każdy węzeł ma swój zegar – synchronizacja czasu to jedno z wyzwań.",
    "auto_id": 63
  },
  {
    "type": "simple_select",
    "question": "Czym jest skalowanie poziome (horizontal scaling)?",
    "options": {
      "A": "Zwiększanie liczby użytkowników",
      "B": "Zwiększanie mocy jednego serwera",
      "C": "Dodawanie kolejnych węzłów do systemu",
      "D": "Zwiększanie pojemności dysku twardego"
    },
    "correct": "C",
    "explanation": "Skalowanie poziome polega na dodawaniu kolejnych instancji (np. serwerów) do systemu.",
    "auto_id": 64
  },
  {
    "type": "simple_select",
    "question": "Jakie narzędzie służy do orkiestracji kontenerów w środowiskach rozproszonych?",
    "options": {
      "A": "Dockerfile",
      "B": "Visual Studio",
      "C": "Kubernetes",
      "D": "Notepad"
    },
    "correct": "C",
    "explanation": "Kubernetes zarządza wdrażaniem, skalowaniem i utrzymaniem kontenerów w klastrze.",
    "auto_id": 65
  },
  {
    "type": "simple_select",
    "question": "Która cecha NIE jest typowa dla systemu rozproszonego?",
    "options": {
      "A": "Niezależność węzłów",
      "B": "Globalny adres pamięci",
      "C": "Brak pojedynczego punktu awarii",
      "D": "Asynchroniczność komunikacji"
    },
    "correct": "B",
    "explanation": "Systemy rozproszone nie mają wspólnej pamięci, więc nie posiadają globalnego adresu pamięci.",
    "auto_id": 66
  },
  {
    "type": "simple_select",
    "question": "Czym jest replikacja danych w systemach rozproszonych?",
    "options": {
      "A": "Kompresją danych do wielu formatów",
      "B": "Wysyłką danych e-mailem",
      "C": "Utrzymywaniem wielu kopii danych w różnych lokalizacjach",
      "D": "Usuwaniem starych danych"
    },
    "correct": "C",
    "explanation": "Replikacja zwiększa dostępność i odporność systemu poprzez utrzymywanie wielu kopii danych.",
    "auto_id": 67
  },
  {
    "type": "multi_select",
    "question": "Które komponenty mogą wchodzić w skład aplikacji rozproszonej?",
    "options": {
      "A": "Frontend webowy",
      "B": "API REST",
      "C": "Baza danych",
      "D": "System chłodzenia serwera"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Aplikacje rozproszone składają się z wielu współpracujących komponentów, takich jak frontend, API, czy baza danych.",
    "auto_id": 68
  },
  {
    "type": "multi_select",
    "question": "Które technologie wspierają budowę systemów rozproszonych?",
    "options": {
      "A": "Docker",
      "B": "Kubernetes",
      "C": "HTTP",
      "D": "WinRAR"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Docker i Kubernetes to kluczowe narzędzia, a HTTP jest podstawowym protokołem komunikacyjnym.",
    "auto_id": 69
  },
  {
    "type": "multi_select",
    "question": "Które problemy są typowe dla aplikacji rozproszonych?",
    "options": {
      "A": "Opóźnienia w komunikacji",
      "B": "Brak skalowalności",
      "C": "Awaria jednego węzła",
      "D": "Synchronizacja danych"
    },
    "correct": [
      "A",
      "C",
      "D"
    ],
    "explanation": "Aplikacje rozproszone muszą radzić sobie z opóźnieniami, awariami i synchronizacją.",
    "auto_id": 70
  },
  {
    "type": "multi_select",
    "question": "Jakie są zalety aplikacji rozproszonych?",
    "options": {
      "A": "Wysoka dostępność",
      "B": "Lepsza skalowalność",
      "C": "Brak potrzeby testowania",
      "D": "Odporność na awarie"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Systemy rozproszone zapewniają dostępność, skalowalność i odporność – ale nadal trzeba je testować.",
    "auto_id": 71
  },
  {
    "type": "multi_select",
    "question": "Które wzorce architektoniczne stosuje się w aplikacjach rozproszonych?",
    "options": {
      "A": "Monolit",
      "B": "Mikrousługi",
      "C": "Event-driven architecture",
      "D": "Client-server"
    },
    "correct": [
      "B",
      "C",
      "D"
    ],
    "explanation": "Mikrousługi i architektura zdarzeniowa to popularne wzorce, client-server jest klasyką.",
    "auto_id": 72
  },
  {
    "type": "multi_select",
    "question": "Które protokoły służą do komunikacji w systemach rozproszonych?",
    "options": {
      "A": "HTTP",
      "B": "gRPC",
      "C": "FTP",
      "D": "SOAP"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "HTTP, gRPC i SOAP są stosowane do komunikacji między komponentami.",
    "auto_id": 73
  },
  {
    "type": "multi_select",
    "question": "Które podejścia pomagają zapewnić spójność danych?",
    "options": {
      "A": "Replikacja synchroniczna",
      "B": "Zarządzanie transakcjami",
      "C": "Asynchroniczne komunikaty",
      "D": "Systemy kolejkowe"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Replikacja, transakcje i kolejki wiadomości pomagają zapewnić spójność i trwałość danych.",
    "auto_id": 74
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki wdrażania aplikacji rozproszonej w chmurze",
    "steps": [
      "Projekt architektury",
      "Tworzenie kontenerów",
      "Konfiguracja klastra",
      "Wdrażanie komponentów",
      "Monitorowanie"
    ],
    "correct": [
      "Projekt architektury",
      "Tworzenie kontenerów",
      "Konfiguracja klastra",
      "Wdrażanie komponentów",
      "Monitorowanie"
    ],
    "explanation": "To typowy proces tworzenia i uruchamiania aplikacji w środowisku rozproszonym.",
    "auto_id": 75
  },
  {
    "type": "order",
    "question": "Uporządkuj działania systemu client-server",
    "steps": [
      "Żądanie od klienta",
      "Przetwarzanie żądania na serwerze",
      "Odpowiedź serwera",
      "Wyświetlenie wyniku klientowi"
    ],
    "correct": [
      "Żądanie od klienta",
      "Przetwarzanie żądania na serwerze",
      "Odpowiedź serwera",
      "Wyświetlenie wyniku klientowi"
    ],
    "explanation": "Model client-server działa w oparciu o cykl: żądanie–odpowiedź.",
    "auto_id": 76
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy komunikacji REST API",
    "steps": [
      "Zgłoszenie żądania HTTP",
      "Obsługa żądania przez kontroler",
      "Wywołanie logiki biznesowej",
      "Zwrócenie odpowiedzi JSON"
    ],
    "correct": [
      "Zgłoszenie żądania HTTP",
      "Obsługa żądania przez kontroler",
      "Wywołanie logiki biznesowej",
      "Zwrócenie odpowiedzi JSON"
    ],
    "explanation": "To standardowy przepływ komunikacji w API REST.",
    "auto_id": 77
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w systemie kolejkowym (np. RabbitMQ)",
    "steps": [
      "Wysłanie wiadomości do kolejki",
      "Oczekiwanie na odbiór",
      "Pobranie przez konsumenta",
      "Przetwarzanie wiadomości"
    ],
    "correct": [
      "Wysłanie wiadomości do kolejki",
      "Oczekiwanie na odbiór",
      "Pobranie przez konsumenta",
      "Przetwarzanie wiadomości"
    ],
    "explanation": "To klasyczny schemat działania komunikacji asynchronicznej.",
    "auto_id": 78
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy skalowania aplikacji poziomo",
    "steps": [
      "Wykrycie wzrostu ruchu",
      "Utworzenie nowych instancji",
      "Równoważenie obciążenia",
      "Monitorowanie wydajności"
    ],
    "correct": [
      "Wykrycie wzrostu ruchu",
      "Utworzenie nowych instancji",
      "Równoważenie obciążenia",
      "Monitorowanie wydajności"
    ],
    "explanation": "Skalowanie poziome reaguje na wzrost obciążenia przez dodanie instancji.",
    "auto_id": 79
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy budowy systemu mikrousług",
    "steps": [
      "Podział aplikacji na usługi",
      "Zdefiniowanie API",
      "Wdrażanie usług",
      "Rejestrowanie i monitorowanie"
    ],
    "correct": [
      "Podział aplikacji na usługi",
      "Zdefiniowanie API",
      "Wdrażanie usług",
      "Rejestrowanie i monitorowanie"
    ],
    "explanation": "Budowa systemu mikrousług wymaga rozdzielenia funkcjonalności i integracji przez API.",
    "auto_id": 80
  },
  {
    "type": "simple_select",
    "question": "Czym jest programowanie współbieżne?",
    "options": {
      "A": "Pisanie wielu projektów jednocześnie",
      "B": "Uruchamianie wielu komputerów naraz",
      "C": "Wykonywanie wielu zadań w tym samym czasie (logicznie)",
      "D": "Kompilowanie kodu na różnych platformach"
    },
    "correct": "C",
    "explanation": "Programowanie współbieżne pozwala na jednoczesne wykonywanie wielu zadań – współdzieląc czas procesora.",
    "auto_id": 81
  },
  {
    "type": "simple_select",
    "question": "Który z poniższych języków ma wbudowane wsparcie dla współbieżności?",
    "options": {
      "A": "HTML",
      "B": "Python",
      "C": "CSS",
      "D": "SQL"
    },
    "correct": "B",
    "explanation": "Python ma wsparcie dla wątków, asyncio i multiprocessing – wspiera współbieżność.",
    "auto_id": 82
  },
  {
    "type": "simple_select",
    "question": "Czym różni się współbieżność od równoległości?",
    "options": {
      "A": "Współbieżność działa tylko na jednym rdzeniu, a równoległość na wielu",
      "B": "Nie ma żadnej różnicy",
      "C": "Współbieżność to przetwarzanie offline",
      "D": "Równoległość dotyczy baz danych"
    },
    "correct": "A",
    "explanation": "Współbieżność to logiczne współdzielenie zasobów, a równoległość – fizyczne działanie na wielu rdzeniach.",
    "auto_id": 83
  },
  {
    "type": "simple_select",
    "question": "Do czego służy semafor w programowaniu współbieżnym?",
    "options": {
      "A": "Do stylowania interfejsu",
      "B": "Do synchronizacji dostępu do zasobów",
      "C": "Do rysowania wykresów",
      "D": "Do wysyłania e-maili"
    },
    "correct": "B",
    "explanation": "Semafory pozwalają kontrolować dostęp do zasobów współdzielonych, np. pamięci.",
    "auto_id": 84
  },
  {
    "type": "simple_select",
    "question": "Który z poniższych problemów może wystąpić przy braku synchronizacji?",
    "options": {
      "A": "Race condition",
      "B": "Dead pixel",
      "C": "Data migration",
      "D": "Low bandwidth"
    },
    "correct": "A",
    "explanation": "Race condition to błąd wynikający z jednoczesnego dostępu wielu wątków do wspólnych zasobów.",
    "auto_id": 85
  },
  {
    "type": "simple_select",
    "question": "Jakie rozwiązanie pomaga zapobiec zakleszczeniu (deadlock)?",
    "options": {
      "A": "Czyszczenie cache",
      "B": "Zamki (locks)",
      "C": "Unikanie cykli zależności",
      "D": "Więcej pamięci RAM"
    },
    "correct": "C",
    "explanation": "Unikanie cykli w zależnościach zasobów może zapobiec zakleszczeniom.",
    "auto_id": 86
  },
  {
    "type": "simple_select",
    "question": "Która biblioteka służy do współbieżności w Pythonie?",
    "options": {
      "A": "math",
      "B": "asyncio",
      "C": "re",
      "D": "csv"
    },
    "correct": "B",
    "explanation": "asyncio umożliwia programowanie asynchroniczne, czyli współbieżne, w Pythonie.",
    "auto_id": 87
  },
  {
    "type": "multi_select",
    "question": "Które elementy są typowe dla współbieżnych aplikacji?",
    "options": {
      "A": "Wątki (threads)",
      "B": "Zamki (locks)",
      "C": "Klasy dziedziczące po Singletonie",
      "D": "Kolejki (queues)"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Wątki, zamki i kolejki to podstawowe mechanizmy współbieżności.",
    "auto_id": 88
  },
  {
    "type": "multi_select",
    "question": "W jakich zastosowaniach przydaje się współbieżność?",
    "options": {
      "A": "Serwery WWW",
      "B": "Gry komputerowe",
      "C": "Analiza danych w czasie rzeczywistym",
      "D": "Tworzenie dokumentów PDF"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Współbieżność pozwala obsługiwać wielu użytkowników i zdarzenia jednocześnie.",
    "auto_id": 89
  },
  {
    "type": "multi_select",
    "question": "Jakie mechanizmy synchronizacji są stosowane w współbieżnym kodzie?",
    "options": {
      "A": "Mutexy",
      "B": "Semafory",
      "C": "Warunki wyścigu",
      "D": "Bariery"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Mutexy, semafory i bariery pomagają kontrolować współdzielone zasoby – wyścigi są błędami.",
    "auto_id": 90
  },
  {
    "type": "multi_select",
    "question": "Które języki programowania mają dobre wsparcie dla współbieżności?",
    "options": {
      "A": "Go",
      "B": "Rust",
      "C": "Python",
      "D": "Markdown"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Go i Rust mają wbudowane mechanizmy, Python ma wsparcie dzięki bibliotekom – Markdown to format tekstu.",
    "auto_id": 91
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są problemami we współbieżności?",
    "options": {
      "A": "Deadlock",
      "B": "Race condition",
      "C": "Thread starvation",
      "D": "Lazy loading"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Deadlock, race condition i starvation to klasyczne problemy przy współdzieleniu zasobów.",
    "auto_id": 92
  },
  {
    "type": "multi_select",
    "question": "Które rozwiązania pozwalają zwiększyć bezpieczeństwo w kodzie współbieżnym?",
    "options": {
      "A": "Stosowanie mutexów",
      "B": "Użycie kolejek komunikacyjnych",
      "C": "Ignorowanie wyjątków",
      "D": "Projektowanie bez współdzielenia stanu"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Mutexy, kolejki i unikanie współdzielenia danych zwiększają bezpieczeństwo aplikacji.",
    "auto_id": 93
  },
  {
    "type": "multi_select",
    "question": "Które środowiska lub frameworki wspierają programowanie współbieżne?",
    "options": {
      "A": "Node.js",
      "B": "Akka",
      "C": "React",
      "D": "Java Thread API"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Node.js (asynchroniczny event loop), Akka (aktory) i Java Thread API oferują modele współbieżności.",
    "auto_id": 94
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki w tworzeniu wątku w Javie",
    "steps": [
      "Tworzenie klasy implementującej Runnable",
      "Implementacja metody run()",
      "Tworzenie obiektu Thread",
      "Uruchomienie wątku metodą start()"
    ],
    "correct": [
      "Tworzenie klasy implementującej Runnable",
      "Implementacja metody run()",
      "Tworzenie obiektu Thread",
      "Uruchomienie wątku metodą start()"
    ],
    "explanation": "To klasyczna sekwencja tworzenia i uruchamiania wątku w Javie.",
    "auto_id": 95
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy obsługi żądań w serwerze współbieżnym",
    "steps": [
      "Oczekiwanie na połączenie",
      "Tworzenie nowego wątku",
      "Obsługa żądania",
      "Zamknięcie połączenia"
    ],
    "correct": [
      "Oczekiwanie na połączenie",
      "Tworzenie nowego wątku",
      "Obsługa żądania",
      "Zamknięcie połączenia"
    ],
    "explanation": "Serwery współbieżne tworzą nowy wątek dla każdego połączenia.",
    "auto_id": 96
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy synchronizacji dostępu do pliku",
    "steps": [
      "Zablokowanie pliku",
      "Odczyt/zapis danych",
      "Odblokowanie pliku",
      "Zamknięcie uchwytu"
    ],
    "correct": [
      "Zablokowanie pliku",
      "Odczyt/zapis danych",
      "Odblokowanie pliku",
      "Zamknięcie uchwytu"
    ],
    "explanation": "Blokada chroni dane przed jednoczesnym dostępem w wielu wątkach.",
    "auto_id": 97
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy działania semafora",
    "steps": [
      "Ustawienie wartości semafora",
      "Sprawdzenie dostępności zasobu",
      "Zablokowanie semafora",
      "Zwolnienie semafora"
    ],
    "correct": [
      "Ustawienie wartości semafora",
      "Sprawdzenie dostępności zasobu",
      "Zablokowanie semafora",
      "Zwolnienie semafora"
    ],
    "explanation": "To typowy przebieg działania semafora – przy synchronizacji wielu procesów.",
    "auto_id": 98
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w modelu async/await",
    "steps": [
      "Wywołanie funkcji asynchronicznej",
      "Zawieszenie wykonania",
      "Oczekiwanie na zakończenie zadania",
      "Wznowienie wykonywania"
    ],
    "correct": [
      "Wywołanie funkcji asynchronicznej",
      "Zawieszenie wykonania",
      "Oczekiwanie na zakończenie zadania",
      "Wznowienie wykonywania"
    ],
    "explanation": "async/await upraszcza współbieżność poprzez \"udawanie\" synchronicznego przepływu.",
    "auto_id": 99
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki działania programu z wieloma procesami",
    "steps": [
      "Tworzenie procesów potomnych",
      "Ustawienie kanałów komunikacyjnych",
      "Wymiana danych między procesami",
      "Zamknięcie procesów"
    ],
    "correct": [
      "Tworzenie procesów potomnych",
      "Ustawienie kanałów komunikacyjnych",
      "Wymiana danych między procesami",
      "Zamknięcie procesów"
    ],
    "explanation": "To standardowy sposób komunikacji międzyprocesowej (IPC).",
    "auto_id": 100
  },
  {
    "type": "simple_select",
    "question": "Czym jest sztuczna sieć neuronowa (ANN)?",
    "options": {
      "A": "Sieć komputerowa",
      "B": "Model symulujący działanie ludzkiego mózgu",
      "C": "System operacyjny",
      "D": "Silnik bazodanowy"
    },
    "correct": "B",
    "explanation": "Sztuczna sieć neuronowa (Artificial Neural Network) to model matematyczny inspirowany mózgiem.",
    "auto_id": 101
  },
  {
    "type": "simple_select",
    "question": "Która sieć najlepiej nadaje się do analizy danych sekwencyjnych?",
    "options": {
      "A": "ANN",
      "B": "CNN",
      "C": "RNN",
      "D": "GAN"
    },
    "correct": "C",
    "explanation": "RNN (Recurrent Neural Network) jest zaprojektowana do przetwarzania sekwencji, np. tekstu lub mowy.",
    "auto_id": 102
  },
  {
    "type": "simple_select",
    "question": "Która architektura wykorzystuje operacje konwolucyjne?",
    "options": {
      "A": "RNN",
      "B": "CNN",
      "C": "ANN",
      "D": "SVM"
    },
    "correct": "B",
    "explanation": "CNN (Convolutional Neural Network) używa splotów (convolution) do wykrywania cech w danych wejściowych.",
    "auto_id": 103
  },
  {
    "type": "simple_select",
    "question": "Jakie dane najczęściej przetwarzają CNN?",
    "options": {
      "A": "Sekwencje tekstowe",
      "B": "Liczby zespolone",
      "C": "Obrazy i dane przestrzenne",
      "D": "Drzewa decyzyjne"
    },
    "correct": "C",
    "explanation": "CNN zostały stworzone do pracy z obrazami i sygnałami przestrzennymi.",
    "auto_id": 104
  },
  {
    "type": "simple_select",
    "question": "Który typ sieci ma „pamięć” poprzednich kroków?",
    "options": {
      "A": "ANN",
      "B": "CNN",
      "C": "RNN",
      "D": "PCA"
    },
    "correct": "C",
    "explanation": "RNN posiada mechanizm pamięci – przetwarza dane w kontekście poprzednich kroków.",
    "auto_id": 105
  },
  {
    "type": "simple_select",
    "question": "Czym różni się ANN od CNN?",
    "options": {
      "A": "ANN działa tylko w Pythonie",
      "B": "CNN posiada warstwy konwolucyjne, ANN nie",
      "C": "ANN nie wymaga danych",
      "D": "CNN działa offline, a ANN online"
    },
    "correct": "B",
    "explanation": "CNN ma warstwy konwolucyjne do ekstrakcji cech z danych, czego nie ma klasyczna ANN.",
    "auto_id": 106
  },
  {
    "type": "simple_select",
    "question": "Który typ sieci może zapamiętać zależności długoterminowe?",
    "options": {
      "A": "CNN",
      "B": "ANN",
      "C": "LSTM (typ RNN)",
      "D": "GAN"
    },
    "correct": "C",
    "explanation": "LSTM to specjalna wersja RNN zaprojektowana do zapamiętywania długich zależności w sekwencjach.",
    "auto_id": 107
  },
  {
    "type": "multi_select",
    "question": "Które cechy są typowe dla CNN?",
    "options": {
      "A": "Warstwy konwolucyjne",
      "B": "Pooling",
      "C": "Rekurencja",
      "D": "Wysoka skuteczność w analizie obrazów"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "CNN nie używa rekurencji, ale posiada warstwy konwolucyjne i poolingowe, i świetnie działa na obrazach.",
    "auto_id": 108
  },
  {
    "type": "multi_select",
    "question": "Które architektury zaliczamy do głębokiego uczenia?",
    "options": {
      "A": "CNN",
      "B": "RNN",
      "C": "ANN z jedną warstwą",
      "D": "LSTM"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Głębokie uczenie zakłada wiele warstw – klasyczna płytka ANN z jedną warstwą się nie kwalifikuje.",
    "auto_id": 109
  },
  {
    "type": "multi_select",
    "question": "Które zastosowania pasują do RNN?",
    "options": {
      "A": "Przewidywanie kursów giełdowych",
      "B": "Tłumaczenie tekstu",
      "C": "Rozpoznawanie obrazów",
      "D": "Analiza sentymentu"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "RNN najlepiej sprawdza się tam, gdzie mamy dane sekwencyjne, np. tekst, czas, język.",
    "auto_id": 110
  },
  {
    "type": "multi_select",
    "question": "Które zastosowania pasują do CNN?",
    "options": {
      "A": "Wykrywanie obiektów na zdjęciach",
      "B": "Rozpoznawanie twarzy",
      "C": "Generowanie sekwencji tekstowych",
      "D": "Analiza zdjęć medycznych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "CNN to król obrazów – twarze, zdjęcia medyczne, detekcja obiektów. Tekst – to domena RNN.",
    "auto_id": 111
  },
  {
    "type": "multi_select",
    "question": "Które warstwy można znaleźć w głębokiej sieci neuronowej?",
    "options": {
      "A": "Warstwa wejściowa",
      "B": "Warstwa ukryta",
      "C": "Warstwa wyjściowa",
      "D": "Warstwa korekcyjna"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Typowe sieci składają się z wejścia, ukrycia i wyjścia – warstwa korekcyjna to wymysł.",
    "auto_id": 112
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są przykładami RNN?",
    "options": {
      "A": "LSTM",
      "B": "GRU",
      "C": "Feedforward",
      "D": "Bidirectional RNN"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "LSTM, GRU i Bi-RNN to różne warianty sieci rekurencyjnych.",
    "auto_id": 113
  },
  {
    "type": "multi_select",
    "question": "Czym różni się RNN od CNN?",
    "options": {
      "A": "RNN przetwarza dane sekwencyjne, CNN przestrzenne",
      "B": "RNN zawiera pamięć stanów, CNN nie",
      "C": "RNN działa szybciej na GPU niż CNN",
      "D": "CNN ma pooling, RNN nie"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "RNN pracuje na sekwencjach i ma pamięć, CNN działa na obrazach i ma pooling.",
    "auto_id": 114
  },
  {
    "type": "order",
    "question": "Uporządkuj warstwy klasycznej ANN",
    "steps": [
      "Warstwa wejściowa",
      "Warstwa ukryta",
      "Warstwa wyjściowa"
    ],
    "correct": [
      "Warstwa wejściowa",
      "Warstwa ukryta",
      "Warstwa wyjściowa"
    ],
    "explanation": "ANN zazwyczaj składa się z wejścia, jednej lub więcej warstw ukrytych i wyjścia.",
    "auto_id": 115
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki przetwarzania obrazu przez CNN",
    "steps": [
      "Podanie obrazu",
      "Konwolucja",
      "Pooling",
      "Warstwa w pełni połączona",
      "Wyjście"
    ],
    "correct": [
      "Podanie obrazu",
      "Konwolucja",
      "Pooling",
      "Warstwa w pełni połączona",
      "Wyjście"
    ],
    "explanation": "CNN najpierw przetwarza obraz przez warstwy splotowe i poolingowe, potem klasyfikuje.",
    "auto_id": 116
  },
  {
    "type": "order",
    "question": "Uporządkuj działania RNN przy przetwarzaniu sekwencji",
    "steps": [
      "Podanie elementu sekwencji",
      "Przetworzenie przez komórkę RNN",
      "Aktualizacja stanu ukrytego",
      "Generowanie wyjścia"
    ],
    "correct": [
      "Podanie elementu sekwencji",
      "Przetworzenie przez komórkę RNN",
      "Aktualizacja stanu ukrytego",
      "Generowanie wyjścia"
    ],
    "explanation": "Każdy element sekwencji aktualizuje stan i daje wyjście.",
    "auto_id": 117
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy tworzenia modelu CNN",
    "steps": [
      "Zdefiniowanie warstw konwolucyjnych",
      "Dodanie warstw poolingowych",
      "Dodanie warstw w pełni połączonych",
      "Trenowanie modelu",
      "Testowanie modelu"
    ],
    "correct": [
      "Zdefiniowanie warstw konwolucyjnych",
      "Dodanie warstw poolingowych",
      "Dodanie warstw w pełni połączonych",
      "Trenowanie modelu",
      "Testowanie modelu"
    ],
    "explanation": "Model budujemy od warstw, przez trening aż do testowania.",
    "auto_id": 118
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki przygotowania danych do ANN",
    "steps": [
      "Zebranie danych",
      "Czyszczenie danych",
      "Normalizacja",
      "Podział na zbiory",
      "Trenowanie"
    ],
    "correct": [
      "Zebranie danych",
      "Czyszczenie danych",
      "Normalizacja",
      "Podział na zbiory",
      "Trenowanie"
    ],
    "explanation": "Przed trenowaniem przygotowujemy dane: czyszczenie, normalizacja, podział.",
    "auto_id": 119
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki działania LSTM",
    "steps": [
      "Odczyt danych wejściowych",
      "Decyzja o zapisie stanu",
      "Aktualizacja komórki pamięci",
      "Wygenerowanie wyjścia"
    ],
    "correct": [
      "Odczyt danych wejściowych",
      "Decyzja o zapisie stanu",
      "Aktualizacja komórki pamięci",
      "Wygenerowanie wyjścia"
    ],
    "explanation": "LSTM decyduje, co zapamiętać, co zapomnieć i co wypuścić jako wynik.",
    "auto_id": 120
  },
  {
    "type": "simple_select",
    "question": "Czym jest projektowanie systemu informatycznego?",
    "options": {
      "A": "Pisaniem dokumentacji końcowej",
      "B": "Procesem definiowania architektury, komponentów i interakcji systemu",
      "C": "Kompilacją programu",
      "D": "Zarządzaniem zespołem"
    },
    "correct": "B",
    "explanation": "Projektowanie systemu to definiowanie jego struktury, interakcji oraz komponentów.",
    "auto_id": 121
  },
  {
    "type": "simple_select",
    "question": "Która z poniższych metod opiera się na iteracyjnym podejściu i częstej współpracy z klientem?",
    "options": {
      "A": "Waterfall",
      "B": "Agile",
      "C": "Big Bang",
      "D": "Spiral"
    },
    "correct": "B",
    "explanation": "Agile bazuje na iteracjach, szybkich dostawach i częstej komunikacji z klientem.",
    "auto_id": 122
  },
  {
    "type": "simple_select",
    "question": "Czym charakteryzuje się podejście kaskadowe (Waterfall)?",
    "options": {
      "A": "Praca w sprintach",
      "B": "Brak dokumentacji",
      "C": "Sztywny podział na kolejne etapy",
      "D": "Brak testowania"
    },
    "correct": "C",
    "explanation": "Waterfall zakłada wykonanie kolejnych kroków (np. analiza, projekt, implementacja) bez cofania.",
    "auto_id": 123
  },
  {
    "type": "simple_select",
    "question": "Który diagram służy do modelowania przepływu danych?",
    "options": {
      "A": "Diagram klas",
      "B": "Diagram przypadków użycia",
      "C": "Diagram przepływu danych (DFD)",
      "D": "Diagram sekwencji"
    },
    "correct": "C",
    "explanation": "Diagram DFD służy do przedstawiania, jak dane przepływają przez system.",
    "auto_id": 124
  },
  {
    "type": "simple_select",
    "question": "Jaki jest cel tworzenia diagramu przypadków użycia?",
    "options": {
      "A": "Wizualizacja przepływu danych",
      "B": "Analiza wymagań funkcjonalnych przez przedstawienie interakcji użytkownika z systemem",
      "C": "Opisywanie relacji baz danych",
      "D": "Tworzenie diagramów klas"
    },
    "correct": "B",
    "explanation": "Diagram przypadków użycia prezentuje funkcjonalności systemu z punktu widzenia użytkownika.",
    "auto_id": 125
  },
  {
    "type": "simple_select",
    "question": "Który z poniższych NIE jest techniką projektowania systemów informatycznych?",
    "options": {
      "A": "Diagram klas",
      "B": "Diagramy DFD",
      "C": "Kompilacja kodu",
      "D": "Modelowanie procesów biznesowych"
    },
    "correct": "C",
    "explanation": "Kompilacja kodu to etap budowania systemu, nie technika projektowania.",
    "auto_id": 126
  },
  {
    "type": "simple_select",
    "question": "Która metoda wspiera prototypowanie i analizę ryzyka?",
    "options": {
      "A": "Waterfall",
      "B": "Agile",
      "C": "Spiral",
      "D": "Extreme Programming"
    },
    "correct": "C",
    "explanation": "Model spiralny uwzględnia analizę ryzyka i prototypowanie w każdym cyklu.",
    "auto_id": 127
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są metodami projektowania systemów informatycznych?",
    "options": {
      "A": "Agile",
      "B": "Waterfall",
      "C": "Extreme Programming",
      "D": "Kanban"
    },
    "correct": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Wszystkie to metody zarządzania i projektowania w inżynierii oprogramowania.",
    "auto_id": 128
  },
  {
    "type": "multi_select",
    "question": "Które techniki wykorzystywane są w projektowaniu systemów?",
    "options": {
      "A": "Diagramy UML",
      "B": "Prototypowanie",
      "C": "Modelowanie danych",
      "D": "Zamiana zmiennych na stałe"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Zamiana zmiennych to operacja programistyczna, a nie technika projektowa.",
    "auto_id": 129
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych diagramów są częścią UML?",
    "options": {
      "A": "Diagram klas",
      "B": "Diagram sekwencji",
      "C": "Diagram blokowy",
      "D": "Diagram przypadków użycia"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Diagram blokowy nie jest standardem UML – pozostałe tak.",
    "auto_id": 130
  },
  {
    "type": "multi_select",
    "question": "Które elementy analizuje się podczas projektowania systemu?",
    "options": {
      "A": "Funkcjonalności systemu",
      "B": "Struktura danych",
      "C": "Interfejsy użytkownika",
      "D": "Hasła użytkowników"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Hasła są częścią danych operacyjnych, a nie projektowych.",
    "auto_id": 131
  },
  {
    "type": "multi_select",
    "question": "Które metody wspierają elastyczność i szybkie zmiany w projekcie?",
    "options": {
      "A": "Agile",
      "B": "Scrum",
      "C": "Waterfall",
      "D": "Extreme Programming"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Waterfall jest sztywny i sekwencyjny – pozostałe są zwinne.",
    "auto_id": 132
  },
  {
    "type": "multi_select",
    "question": "Które narzędzia można wykorzystać w projektowaniu systemów?",
    "options": {
      "A": "Enterprise Architect",
      "B": "Draw.io",
      "C": "MySQL Workbench",
      "D": "Steam"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Steam to platforma gier – nie służy do projektowania systemów.",
    "auto_id": 133
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych pojęć są związane z modelowaniem struktury systemu?",
    "options": {
      "A": "Diagram klas",
      "B": "Relacje między obiektami",
      "C": "Diagram sekwencji",
      "D": "Zmienna tymczasowa"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Zmienna tymczasowa to termin z kodowania, nie z projektowania.",
    "auto_id": 134
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy klasycznego procesu projektowania systemu",
    "steps": [
      "Zbieranie wymagań",
      "Analiza systemowa",
      "Projektowanie",
      "Implementacja",
      "Testowanie"
    ],
    "correct": [
      "Zbieranie wymagań",
      "Analiza systemowa",
      "Projektowanie",
      "Implementacja",
      "Testowanie"
    ],
    "explanation": "To typowy przebieg projektowania w klasycznych modelach jak Waterfall.",
    "auto_id": 135
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki przy projektowaniu bazy danych",
    "steps": [
      "Określenie encji",
      "Określenie relacji",
      "Tworzenie modelu logicznego",
      "Normalizacja",
      "Tworzenie modelu fizycznego"
    ],
    "correct": [
      "Określenie encji",
      "Określenie relacji",
      "Tworzenie modelu logicznego",
      "Normalizacja",
      "Tworzenie modelu fizycznego"
    ],
    "explanation": "Projekt bazy danych zaczyna się od encji i relacji, kończy na fizycznej strukturze.",
    "auto_id": 136
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki projektowania interfejsu użytkownika (UI)",
    "steps": [
      "Zebranie wymagań użytkowników",
      "Tworzenie prototypów",
      "Testy użyteczności",
      "Poprawki projektu",
      "Wdrożenie"
    ],
    "correct": [
      "Zebranie wymagań użytkowników",
      "Tworzenie prototypów",
      "Testy użyteczności",
      "Poprawki projektu",
      "Wdrożenie"
    ],
    "explanation": "Projekt UI opiera się na potrzebach użytkowników i iteracyjnym podejściu.",
    "auto_id": 137
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w podejściu Agile",
    "steps": [
      "Zebranie user stories",
      "Planowanie sprintu",
      "Implementacja funkcjonalności",
      "Codzienne stand-upy",
      "Prezentacja i retrospekcja"
    ],
    "correct": [
      "Zebranie user stories",
      "Planowanie sprintu",
      "Implementacja funkcjonalności",
      "Codzienne stand-upy",
      "Prezentacja i retrospekcja"
    ],
    "explanation": "Agile działa iteracyjnie, z naciskiem na komunikację i dostarczanie wartości.",
    "auto_id": 138
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy tworzeniu diagramu UML",
    "steps": [
      "Zdefiniowanie kontekstu systemu",
      "Zidentyfikowanie aktorów i przypadków użycia",
      "Stworzenie relacji między przypadkami",
      "Dodanie rozszerzeń i wyjątków"
    ],
    "correct": [
      "Zdefiniowanie kontekstu systemu",
      "Zidentyfikowanie aktorów i przypadków użycia",
      "Stworzenie relacji między przypadkami",
      "Dodanie rozszerzeń i wyjątków"
    ],
    "explanation": "Tworzenie diagramu przypadków użycia ma logiczny przebieg od ogółu do szczegółu.",
    "auto_id": 139
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w modelu spiralnym",
    "steps": [
      "Identyfikacja celów",
      "Analiza ryzyka",
      "Tworzenie prototypu",
      "Ewaluacja i decyzja o kolejnym cyklu"
    ],
    "correct": [
      "Identyfikacja celów",
      "Analiza ryzyka",
      "Tworzenie prototypu",
      "Ewaluacja i decyzja o kolejnym cyklu"
    ],
    "explanation": "Model spiralny skupia się na powtarzalnych cyklach projektowych z analizą ryzyka.",
    "auto_id": 140
  },
  {
    "type": "simple_select",
    "question": "Do czego służy diagram przypadków użycia?",
    "options": {
      "A": "Do analizy przepływu danych między systemami",
      "B": "Do prezentacji komunikacji między obiektami",
      "C": "Do opisu funkcjonalności systemu z perspektywy użytkownika",
      "D": "Do planowania sprintów w Agile"
    },
    "correct": "C",
    "explanation": "Diagram przypadków użycia (use case) pokazuje, co system robi z punktu widzenia użytkownika.",
    "auto_id": 141
  },
  {
    "type": "simple_select",
    "question": "Który diagram UML najlepiej obrazuje komunikację między obiektami w czasie?",
    "options": {
      "A": "Diagram klas",
      "B": "Diagram aktywności",
      "C": "Diagram komponentów",
      "D": "Diagram sekwencji"
    },
    "correct": "D",
    "explanation": "Diagram sekwencji przedstawia wymianę komunikatów między obiektami w czasie.",
    "auto_id": 142
  },
  {
    "type": "simple_select",
    "question": "Co przedstawia diagram klas?",
    "options": {
      "A": "Relacje między encjami i ich atrybutami",
      "B": "Procesy biznesowe",
      "C": "Strumień danych w sieci",
      "D": "Etapy projektu"
    },
    "correct": "A",
    "explanation": "Diagram klas przedstawia strukturę systemu w postaci klas, ich atrybutów i relacji.",
    "auto_id": 143
  },
  {
    "type": "simple_select",
    "question": "Który diagram UML najczęściej służy do modelowania procesów i logiki przepływu?",
    "options": {
      "A": "Diagram komponentów",
      "B": "Diagram klas",
      "C": "Diagram aktywności",
      "D": "Diagram wdrożenia"
    },
    "correct": "C",
    "explanation": "Diagram aktywności (activity diagram) modeluje logikę przepływu sterowania lub danych.",
    "auto_id": 144
  },
  {
    "type": "simple_select",
    "question": "W jakiej sytuacji najczęściej stosujemy diagram przypadków użycia?",
    "options": {
      "A": "Podczas analizy struktury klas",
      "B": "Na etapie analizy wymagań",
      "C": "Podczas implementacji kodu",
      "D": "Podczas testowania jednostkowego"
    },
    "correct": "B",
    "explanation": "Diagram przypadków użycia jest narzędziem analizy – pomaga zebrać wymagania od interesariuszy.",
    "auto_id": 145
  },
  {
    "type": "simple_select",
    "question": "Który z poniższych diagramów NIE przedstawia interakcji między obiektami?",
    "options": {
      "A": "Diagram sekwencji",
      "B": "Diagram przypadków użycia",
      "C": "Diagram aktywności",
      "D": "Diagram klas"
    },
    "correct": "D",
    "explanation": "Diagram klas skupia się na strukturze danych i relacjach, nie interakcjach.",
    "auto_id": 146
  },
  {
    "type": "simple_select",
    "question": "Który diagram jest najbardziej przydatny do przedstawienia zachowania użytkownika w systemie?",
    "options": {
      "A": "Diagram klas",
      "B": "Diagram sekwencji",
      "C": "Diagram przypadków użycia",
      "D": "Diagram komponentów"
    },
    "correct": "C",
    "explanation": "Diagram przypadków użycia pokazuje, jakie działania użytkownik może wykonywać w systemie.",
    "auto_id": 147
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych diagramów są diagramami behawioralnymi UML?",
    "options": {
      "A": "Diagram sekwencji",
      "B": "Diagram przypadków użycia",
      "C": "Diagram aktywności",
      "D": "Diagram klas"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Diagram klas to diagram strukturalny, pozostałe należą do behawioralnych.",
    "auto_id": 148
  },
  {
    "type": "multi_select",
    "question": "Które elementy można znaleźć w diagramie klas?",
    "options": {
      "A": "Atrybuty",
      "B": "Metody",
      "C": "Dziedziczenie",
      "D": "Zdarzenia użytkownika"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Diagram klas zawiera atrybuty, metody i relacje między klasami – nie zdarzenia.",
    "auto_id": 149
  },
  {
    "type": "multi_select",
    "question": "W jakich sytuacjach stosujemy diagramy aktywności?",
    "options": {
      "A": "Modelowanie algorytmów i przepływu procesów",
      "B": "Projektowanie struktury klas",
      "C": "Tworzenie przypadków użycia",
      "D": "Wizualizacja przepływu sterowania"
    },
    "correct": [
      "A",
      "D"
    ],
    "explanation": "Diagramy aktywności służą do wizualizacji przepływu sterowania, a nie struktury klas.",
    "auto_id": 150
  },
  {
    "type": "multi_select",
    "question": "Które diagramy pokazują relacje między obiektami?",
    "options": {
      "A": "Diagram sekwencji",
      "B": "Diagram klas",
      "C": "Diagram aktywności",
      "D": "Diagram przypadków użycia"
    },
    "correct": [
      "A",
      "B"
    ],
    "explanation": "Diagram klas pokazuje relacje między strukturami, sekwencji – między obiektami w czasie.",
    "auto_id": 151
  },
  {
    "type": "multi_select",
    "question": "Dlaczego przypadki użycia, sekwencji, klas i aktywności są najczęściej stosowane?",
    "options": {
      "A": "Pokrywają pełny cykl życia systemu",
      "B": "Są zrozumiałe dla interesariuszy",
      "C": "Są wymagane przez każdą firmę IT",
      "D": "Nadają się do dokumentowania funkcjonalności, struktury i zachowania"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Te cztery diagramy obejmują analizę, projekt, logikę i strukturę – dlatego są najczęstsze.",
    "auto_id": 152
  },
  {
    "type": "multi_select",
    "question": "Które narzędzia umożliwiają tworzenie diagramów UML?",
    "options": {
      "A": "StarUML",
      "B": "Draw.io",
      "C": "UMLet",
      "D": "VLC Media Player"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "VLC to odtwarzacz – nie narzędzie do modelowania.",
    "auto_id": 153
  },
  {
    "type": "multi_select",
    "question": "Jak rozpoznać, który diagram UML zastosować?",
    "options": {
      "A": "Sekwencji – gdy ważna jest kolejność komunikatów",
      "B": "Przypadków użycia – do analizy wymagań",
      "C": "Klas – do projektowania struktury danych",
      "D": "Aktywności – do budowy frontendu"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Diagramy dobiera się w zależności od celu – frontend nie projektuje się diagramem aktywności.",
    "auto_id": 154
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki tworzenia diagramu przypadków użycia",
    "steps": [
      "Zidentyfikowanie aktorów",
      "Zidentyfikowanie przypadków użycia",
      "Zdefiniowanie relacji",
      "Dodanie rozszerzeń (extends)"
    ],
    "correct": [
      "Zidentyfikowanie aktorów",
      "Zidentyfikowanie przypadków użycia",
      "Zdefiniowanie relacji",
      "Dodanie rozszerzeń (extends)"
    ],
    "explanation": "Use case diagram zaczyna się od aktorów, następnie przypadki, relacje i rozszerzenia.",
    "auto_id": 155
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki budowy diagramu klas",
    "steps": [
      "Zidentyfikowanie klas",
      "Określenie atrybutów i metod",
      "Zdefiniowanie relacji między klasami",
      "Dodanie modyfikatorów dostępu"
    ],
    "correct": [
      "Zidentyfikowanie klas",
      "Określenie atrybutów i metod",
      "Zdefiniowanie relacji między klasami",
      "Dodanie modyfikatorów dostępu"
    ],
    "explanation": "Projekt klasy zaczyna się od samej klasy, potem jej właściwości, relacje i modyfikatory.",
    "auto_id": 156
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki tworzenia diagramu sekwencji",
    "steps": [
      "Zidentyfikowanie obiektów",
      "Określenie interakcji",
      "Dodanie komunikatów",
      "Ułożenie komunikatów chronologicznie"
    ],
    "correct": [
      "Zidentyfikowanie obiektów",
      "Określenie interakcji",
      "Dodanie komunikatów",
      "Ułożenie komunikatów chronologicznie"
    ],
    "explanation": "Sekwencja to interakcje między obiektami uporządkowane w czasie.",
    "auto_id": 157
  },
  {
    "type": "order",
    "question": "Uporządkuj elementy diagramu aktywności",
    "steps": [
      "Stan początkowy",
      "Akcje",
      "Decyzje",
      "Stan końcowy"
    ],
    "correct": [
      "Stan początkowy",
      "Akcje",
      "Decyzje",
      "Stan końcowy"
    ],
    "explanation": "Diagram aktywności odwzorowuje przepływ: start, akcje, decyzje, zakończenie.",
    "auto_id": 158
  },
  {
    "type": "order",
    "question": "Uporządkuj zastosowanie diagramów w fazach SDLC",
    "steps": [
      "Przypadków użycia",
      "Klas",
      "Sekwencji",
      "Aktywności"
    ],
    "correct": [
      "Przypadków użycia",
      "Klas",
      "Sekwencji",
      "Aktywności"
    ],
    "explanation": "Kolejność odpowiada typowemu przechodzeniu od wymagań do logiki systemu.",
    "auto_id": 159
  },
  {
    "type": "order",
    "question": "Uporządkuj czynności w wyborze odpowiedniego diagramu UML",
    "steps": [
      "Określenie celu modelowania",
      "Identyfikacja odbiorców diagramu",
      "Wybór diagramu UML",
      "Tworzenie i prezentacja diagramu"
    ],
    "correct": [
      "Określenie celu modelowania",
      "Identyfikacja odbiorców diagramu",
      "Wybór diagramu UML",
      "Tworzenie i prezentacja diagramu"
    ],
    "explanation": "Zastosowanie diagramu zależy od celu i odbiorców – dobór formy następuje później.",
    "auto_id": 160
  },
  {
    "type": "simple_select",
    "question": "Co oznacza skrót ETL?",
    "options": {
      "A": "Evaluate, Test, Launch",
      "B": "Extract, Transform, Load",
      "C": "Enter, Transfer, Log",
      "D": "Edit, Train, Learn"
    },
    "correct": "B",
    "explanation": "ETL to klasyczny proces w hurtowniach danych: Extract (ekstrakcja), Transform (transformacja), Load (załadunek).",
    "auto_id": 161
  },
  {
    "type": "simple_select",
    "question": "Który krok w procesie ETL odpowiada za czyszczenie danych?",
    "options": {
      "A": "Extract",
      "B": "Transform",
      "C": "Load",
      "D": "Query"
    },
    "correct": "B",
    "explanation": "Transformacja obejmuje czyszczenie, standaryzację i przygotowanie danych do załadunku.",
    "auto_id": 162
  },
  {
    "type": "simple_select",
    "question": "Czym jest eksploracja danych (data exploration)?",
    "options": {
      "A": "Proces tworzenia GUI",
      "B": "Wstępna analiza danych, np. wykresy, statystyki, rozkłady",
      "C": "Usuwanie baz danych",
      "D": "Testowanie oprogramowania"
    },
    "correct": "B",
    "explanation": "Eksploracja danych to pierwszy etap analizy danych, mający na celu ich poznanie.",
    "auto_id": 163
  },
  {
    "type": "simple_select",
    "question": "Z jakich źródeł mogą pochodzić dane w procesie ETL?",
    "options": {
      "A": "Z bazy danych",
      "B": "Z API",
      "C": "Z plików CSV",
      "D": "Ze wszystkich powyższych"
    },
    "correct": "D",
    "explanation": "Dane mogą być pobierane z różnych źródeł – baz, API, plików itd.",
    "auto_id": 164
  },
  {
    "type": "simple_select",
    "question": "Które narzędzie jest często wykorzystywane do eksploracji danych?",
    "options": {
      "A": "Photoshop",
      "B": "Excel",
      "C": "PowerPoint",
      "D": "AutoCAD"
    },
    "correct": "B",
    "explanation": "Excel, mimo prostoty, jest nadal popularnym narzędziem do wstępnej eksploracji danych.",
    "auto_id": 165
  },
  {
    "type": "simple_select",
    "question": "Jaka jest rola procesu „Extract” w ETL?",
    "options": {
      "A": "Wysyłanie danych do klienta",
      "B": "Pobieranie danych ze źródeł",
      "C": "Formatowanie tabel",
      "D": "Łączenie modeli ML"
    },
    "correct": "B",
    "explanation": "Extract oznacza ekstrakcję – pobranie danych ze źródeł, np. baz danych, plików, API.",
    "auto_id": 166
  },
  {
    "type": "simple_select",
    "question": "Który etap procesu ETL zazwyczaj wymaga walidacji i kontroli jakości danych?",
    "options": {
      "A": "Extract",
      "B": "Transform",
      "C": "Load",
      "D": "Train"
    },
    "correct": "B",
    "explanation": "Transformacja to etap, gdzie dane są sprawdzane, czyszczone i przekształcane.",
    "auto_id": 167
  },
  {
    "type": "multi_select",
    "question": "Które działania zaliczają się do eksploracji danych?",
    "options": {
      "A": "Tworzenie wykresów",
      "B": "Analiza braków danych",
      "C": "Podsumowania statystyczne",
      "D": "Renderowanie animacji"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Eksploracja danych obejmuje analizę struktury danych, wykresy, rozkłady i brakujące wartości.",
    "auto_id": 168
  },
  {
    "type": "multi_select",
    "question": "Jakie typowe przekształcenia danych występują w fazie „Transform”?",
    "options": {
      "A": "Usuwanie duplikatów",
      "B": "Zmiana formatów dat",
      "C": "Łączenie pól",
      "D": "Usuwanie aplikacji"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Transformacja to przygotowanie danych do załadunku – czyszczenie, zmiany formatów, łączenie kolumn itp.",
    "auto_id": 169
  },
  {
    "type": "multi_select",
    "question": "Które narzędzia są wykorzystywane w procesach ETL?",
    "options": {
      "A": "Talend",
      "B": "Apache NiFi",
      "C": "Power BI",
      "D": "Pentaho"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Power BI służy do wizualizacji, a Talend, NiFi i Pentaho do procesów ETL.",
    "auto_id": 170
  },
  {
    "type": "multi_select",
    "question": "Jakie źródła danych mogą być używane do gromadzenia danych?",
    "options": {
      "A": "Relacyjne bazy danych",
      "B": "Systemy plików",
      "C": "Dane z czujników (IoT)",
      "D": "Podręczniki akademickie"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Dane mogą pochodzić z baz, plików, urządzeń – książki raczej nie.",
    "auto_id": 171
  },
  {
    "type": "multi_select",
    "question": "Jakie problemy mogą wystąpić podczas eksploracji danych?",
    "options": {
      "A": "Brakujące wartości",
      "B": "Błędne typy danych",
      "C": "Wysoka jakość danych",
      "D": "Nietypowe rozkłady"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Braki, błędne typy i rozkłady to typowe problemy – wysoka jakość danych to zaleta.",
    "auto_id": 172
  },
  {
    "type": "multi_select",
    "question": "Do czego służy eksploracja danych przed modelowaniem?",
    "options": {
      "A": "Do identyfikacji anomalii",
      "B": "Do oceny rozkładów zmiennych",
      "C": "Do zrozumienia danych",
      "D": "Do optymalizacji algorytmów sortowania"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Eksploracja przygotowuje dane do modelowania – sortowanie to nie jej cel.",
    "auto_id": 173
  },
  {
    "type": "multi_select",
    "question": "Co można osiągnąć dzięki dobrze zaprojektowanemu procesowi ETL?",
    "options": {
      "A": "Zautomatyzowane przetwarzanie danych",
      "B": "Spójność i jakość danych",
      "C": "Wysoka jakość wizualizacji w PowerPoint",
      "D": "Łatwiejsze analizy w hurtowniach danych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "ETL ułatwia automatyzację, poprawia jakość danych i przygotowuje dane do analizy.",
    "auto_id": 174
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy klasycznego procesu ETL",
    "steps": [
      "Extract",
      "Transform",
      "Load"
    ],
    "correct": [
      "Extract",
      "Transform",
      "Load"
    ],
    "explanation": "To podstawowa kolejność: najpierw pobranie, potem przekształcenie, na końcu załadunek.",
    "auto_id": 175
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w eksploracji danych",
    "steps": [
      "Wczytanie danych",
      "Analiza statystyczna",
      "Wizualizacja danych",
      "Identyfikacja problemów"
    ],
    "correct": [
      "Wczytanie danych",
      "Analiza statystyczna",
      "Wizualizacja danych",
      "Identyfikacja problemów"
    ],
    "explanation": "Kolejność odpowiada typowemu przebiegowi eksploracji.",
    "auto_id": 176
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy transformacji danych",
    "steps": [
      "Usuwanie duplikatów",
      "Uzupełnianie braków",
      "Zmiana formatów",
      "Tworzenie nowych zmiennych"
    ],
    "correct": [
      "Usuwanie duplikatów",
      "Uzupełnianie braków",
      "Zmiana formatów",
      "Tworzenie nowych zmiennych"
    ],
    "explanation": "Transformacja obejmuje czyszczenie i tworzenie danych pośrednich.",
    "auto_id": 177
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy budowie pipeline’u danych",
    "steps": [
      "Pobranie danych ze źródeł",
      "Przetwarzanie danych",
      "Przechowywanie danych",
      "Użycie w analizie"
    ],
    "correct": [
      "Pobranie danych ze źródeł",
      "Przetwarzanie danych",
      "Przechowywanie danych",
      "Użycie w analizie"
    ],
    "explanation": "Pipeline danych odpowiada za cały cykl życia danych – od źródła do analizy.",
    "auto_id": 178
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w czyszczeniu danych",
    "steps": [
      "Wykrycie braków",
      "Decyzja o sposobie uzupełnienia",
      "Zastąpienie braków",
      "Walidacja poprawności"
    ],
    "correct": [
      "Wykrycie braków",
      "Decyzja o sposobie uzupełnienia",
      "Zastąpienie braków",
      "Walidacja poprawności"
    ],
    "explanation": "To typowy przebieg czyszczenia danych krok po kroku.",
    "auto_id": 179
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy eksploracji zmiennych numerycznych",
    "steps": [
      "Obliczenie średniej i mediany",
      "Sprawdzenie rozkładu",
      "Identyfikacja wartości odstających",
      "Wizualizacja (np. histogram)"
    ],
    "correct": [
      "Obliczenie średniej i mediany",
      "Sprawdzenie rozkładu",
      "Identyfikacja wartości odstających",
      "Wizualizacja (np. histogram)"
    ],
    "explanation": "Eksplorację zaczynamy od statystyk, następnie analizujemy rozkład i odchylenia.",
    "auto_id": 180
  },
  {
    "type": "simple_select",
    "question": "Czym jest Big Data?",
    "options": {
      "A": "Zwykłą bazą danych SQL",
      "B": "Małym zbiorem danych analizowanym lokalnie",
      "C": "Zbiorem danych o dużej objętości, zmienności i różnorodności",
      "D": "Formatem plików graficznych"
    },
    "correct": "C",
    "explanation": "Big Data to dane o dużej skali, zmienności i różnorodności – przekraczające możliwości klasycznych systemów.",
    "auto_id": 181
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych NIE jest cechą Big Data?",
    "options": {
      "A": "Volume (ilość danych)",
      "B": "Velocity (szybkość przetwarzania)",
      "C": "Visibility (widoczność danych)",
      "D": "Variety (różnorodność)"
    },
    "correct": "C",
    "explanation": "Cechy Big Data to tzw. 3V: Volume, Velocity, Variety – widoczność nie jest jedną z nich.",
    "auto_id": 182
  },
  {
    "type": "simple_select",
    "question": "Czym jest Business Intelligence?",
    "options": {
      "A": "Technika kompresji danych",
      "B": "Zbiór narzędzi i metod analizy danych wspierających decyzje biznesowe",
      "C": "Metoda szyfrowania danych",
      "D": "System operacyjny dla firm"
    },
    "correct": "B",
    "explanation": "BI to proces przekształcania danych w wiedzę biznesową za pomocą narzędzi analitycznych i wizualizacji.",
    "auto_id": 183
  },
  {
    "type": "simple_select",
    "question": "Które narzędzie służy do przechowywania i przetwarzania Big Data w rozproszeniu?",
    "options": {
      "A": "Hadoop",
      "B": "Excel",
      "C": "PowerPoint",
      "D": "Photoshop"
    },
    "correct": "A",
    "explanation": "Hadoop to framework do rozproszonego przechowywania i przetwarzania dużych zbiorów danych.",
    "auto_id": 184
  },
  {
    "type": "simple_select",
    "question": "Do czego służy narzędzie Power BI?",
    "options": {
      "A": "Do tworzenia aplikacji mobilnych",
      "B": "Do tworzenia wykresów i raportów z danych",
      "C": "Do edycji grafiki rastrowej",
      "D": "Do zarządzania siecią"
    },
    "correct": "B",
    "explanation": "Power BI to narzędzie klasy Business Intelligence – tworzy interaktywne raporty i pulpity analityczne.",
    "auto_id": 185
  },
  {
    "type": "simple_select",
    "question": "Która z poniższych technologii umożliwia przetwarzanie strumieniowe danych Big Data?",
    "options": {
      "A": "Apache Kafka",
      "B": "SQLite",
      "C": "Photoshop",
      "D": "MySQL Workbench"
    },
    "correct": "A",
    "explanation": "Apache Kafka umożliwia szybkie i skalowalne przetwarzanie danych strumieniowych.",
    "auto_id": 186
  },
  {
    "type": "simple_select",
    "question": "Czym charakteryzuje się narzędzie Apache Spark?",
    "options": {
      "A": "Jest tylko edytorem tekstu",
      "B": "Służy do przetwarzania dużych zbiorów danych w pamięci RAM",
      "C": "Tworzy gry komputerowe",
      "D": "Analizuje dane wyłącznie w Excelu"
    },
    "correct": "B",
    "explanation": "Spark to szybki silnik przetwarzania danych Big Data z wykorzystaniem pamięci RAM (in-memory processing).",
    "auto_id": 187
  },
  {
    "type": "multi_select",
    "question": "Które narzędzia są związane z przetwarzaniem Big Data?",
    "options": {
      "A": "Apache Hadoop",
      "B": "Apache Spark",
      "C": "Google BigQuery",
      "D": "GIMP"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Hadoop, Spark i BigQuery to popularne technologie Big Data – GIMP to edytor graficzny.",
    "auto_id": 188
  },
  {
    "type": "multi_select",
    "question": "Które technologie wspierają analitykę Business Intelligence?",
    "options": {
      "A": "Power BI",
      "B": "Tableau",
      "C": "Looker",
      "D": "AutoCAD"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Power BI, Tableau i Looker umożliwiają tworzenie raportów, dashboardów i analiz danych.",
    "auto_id": 189
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych to potencjalne źródła danych Big Data?",
    "options": {
      "A": "Media społecznościowe",
      "B": "Urządzenia IoT",
      "C": "Logi serwerów",
      "D": "Ręcznie pisane notatki papierowe"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Dane z social media, IoT i logów są typowymi źródłami Big Data – notatki papierowe już nie.",
    "auto_id": 190
  },
  {
    "type": "multi_select",
    "question": "Które cechy charakteryzują Big Data?",
    "options": {
      "A": "Duża objętość",
      "B": "Wysoka szybkość napływu",
      "C": "Różnorodność danych",
      "D": "Wyłącznie dane liczbowe"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Big Data może obejmować dane tekstowe, graficzne, liczby – nie tylko dane liczbowe.",
    "auto_id": 191
  },
  {
    "type": "multi_select",
    "question": "Jakie zastosowania biznesowe ma Business Intelligence?",
    "options": {
      "A": "Tworzenie raportów i dashboardów",
      "B": "Wspieranie decyzji zarządczych",
      "C": "Analiza sprzedaży i prognozowanie",
      "D": "Komunikacja Bluetooth"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "BI pomaga analizować dane i wspierać decyzje – nie służy do komunikacji sprzętowej.",
    "auto_id": 192
  },
  {
    "type": "multi_select",
    "question": "Które funkcje można zrealizować w narzędziach BI?",
    "options": {
      "A": "Tworzenie raportów",
      "B": "Monitorowanie KPI",
      "C": "Wizualizacja danych",
      "D": "Projektowanie grafiki 3D"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "BI to narzędzia do raportowania, analizy i wizualizacji – nie do grafiki 3D.",
    "auto_id": 193
  },
  {
    "type": "multi_select",
    "question": "Które elementy są typowe dla platformy Big Data?",
    "options": {
      "A": "Przetwarzanie rozproszone",
      "B": "Skalowalność pozioma",
      "C": "Obsługa wielu formatów danych",
      "D": "Renderowanie plików wideo"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Big Data wymaga skalowalności, rozproszenia i elastyczności względem typów danych.",
    "auto_id": 194
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy analizy danych Big Data w biznesie",
    "steps": [
      "Gromadzenie danych",
      "Przechowywanie danych",
      "Przetwarzanie i analiza",
      "Wizualizacja i raportowanie"
    ],
    "correct": [
      "Gromadzenie danych",
      "Przechowywanie danych",
      "Przetwarzanie i analiza",
      "Wizualizacja i raportowanie"
    ],
    "explanation": "To standardowy przepływ danych w procesach analityki Big Data.",
    "auto_id": 195
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy wdrożeniu narzędzia BI w firmie",
    "steps": [
      "Zdefiniowanie celów analitycznych",
      "Podłączenie źródeł danych",
      "Tworzenie dashboardów",
      "Szkolenie użytkowników"
    ],
    "correct": [
      "Zdefiniowanie celów analitycznych",
      "Podłączenie źródeł danych",
      "Tworzenie dashboardów",
      "Szkolenie użytkowników"
    ],
    "explanation": "Etapy wdrożenia BI obejmują zarówno aspekty techniczne, jak i organizacyjne.",
    "auto_id": 196
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki działania Hadoop MapReduce",
    "steps": [
      "Podział danych na bloki",
      "Mapowanie danych",
      "Sortowanie i grupowanie",
      "Redukowanie i agregacja"
    ],
    "correct": [
      "Podział danych na bloki",
      "Mapowanie danych",
      "Sortowanie i grupowanie",
      "Redukowanie i agregacja"
    ],
    "explanation": "MapReduce działa w dwóch głównych etapach: Map i Reduce – poprzedzone dzieleniem i grupowaniem danych.",
    "auto_id": 197
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy tworzenia dashboardu w narzędziu BI",
    "steps": [
      "Wybór danych",
      "Tworzenie wizualizacji",
      "Konfiguracja filtrów",
      "Udostępnienie użytkownikom"
    ],
    "correct": [
      "Wybór danych",
      "Tworzenie wizualizacji",
      "Konfiguracja filtrów",
      "Udostępnienie użytkownikom"
    ],
    "explanation": "Tworzenie dashboardu to kolejny krok od danych po interaktywność i udostępnienie.",
    "auto_id": 198
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w cyklu życia danych Big Data",
    "steps": [
      "Zbieranie danych",
      "Przesyłanie danych",
      "Przetwarzanie danych",
      "Archiwizacja lub analiza"
    ],
    "correct": [
      "Zbieranie danych",
      "Przesyłanie danych",
      "Przetwarzanie danych",
      "Archiwizacja lub analiza"
    ],
    "explanation": "Cykl życia danych Big Data zaczyna się od ich zbierania, a kończy analizą lub archiwizacją.",
    "auto_id": 199
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy integracji danych z BigQuery",
    "steps": [
      "Podłączenie źródła danych",
      "Załadowanie danych",
      "Przetwarzanie zapytań SQL",
      "Prezentacja wyników"
    ],
    "correct": [
      "Podłączenie źródła danych",
      "Załadowanie danych",
      "Przetwarzanie zapytań SQL",
      "Prezentacja wyników"
    ],
    "explanation": "BigQuery umożliwia przetwarzanie danych w chmurze z wykorzystaniem SQL i integracji z BI.",
    "auto_id": 200
  },
  {
    "type": "simple_select",
    "question": "Czym jest operacja CRUD?",
    "options": {
      "A": "Rodzaj algorytmu sortowania",
      "B": "Zestaw podstawowych operacji na danych: Create, Read, Update, Delete",
      "C": "Format pliku graficznego",
      "D": "Metoda autoryzacji użytkowników"
    },
    "correct": "B",
    "explanation": "CRUD to akronim opisujący podstawowe operacje wykonywane na danych w systemach informatycznych.",
    "auto_id": 201
  },
  {
    "type": "simple_select",
    "question": "Która z poniższych operacji odpowiada „U” w CRUD?",
    "options": {
      "A": "Upload",
      "B": "Upgrade",
      "C": "Update",
      "D": "Undo"
    },
    "correct": "C",
    "explanation": "„U” oznacza „Update”, czyli aktualizację danych.",
    "auto_id": 202
  },
  {
    "type": "simple_select",
    "question": "Który przykład ilustruje operację „Create” w systemie CRUD?",
    "options": {
      "A": "Wyświetlenie listy produktów",
      "B": "Edycja istniejącego klienta",
      "C": "Usunięcie faktury",
      "D": "Dodanie nowego zamówienia"
    },
    "correct": "D",
    "explanation": "„Create” oznacza tworzenie nowych rekordów, np. dodanie zamówienia.",
    "auto_id": 203
  },
  {
    "type": "multi_select",
    "question": "Które operacje wchodzą w skład CRUD?",
    "options": {
      "A": "Create",
      "B": "Read",
      "C": "Refresh",
      "D": "Delete"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "CRUD to: Create, Read, Update, Delete – „Refresh” nie jest częścią tego zestawu.",
    "auto_id": 204
  },
  {
    "type": "multi_select",
    "question": "Jakie działania użytkownika w aplikacji mogą reprezentować CRUD?",
    "options": {
      "A": "Dodanie nowego klienta",
      "B": "Wyświetlenie szczegółów produktu",
      "C": "Aktualizacja danych kontaktowych",
      "D": "Zamiana języka interfejsu"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "CRUD odnosi się do operacji na danych, a nie konfiguracji UI.",
    "auto_id": 205
  },
  {
    "type": "multi_select",
    "question": "W których technologiach często stosuje się wzorzec CRUD?",
    "options": {
      "A": "REST API",
      "B": "Bazy danych SQL",
      "C": "CSS",
      "D": "Frameworki MVC"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "CRUD jest powszechnie stosowany w bazach danych, API i aplikacjach webowych – nie w CSS.",
    "auto_id": 206
  },
  {
    "type": "order",
    "question": "Uporządkuj operacje CRUD na przykładzie systemu zarządzania studentami",
    "steps": [
      "Dodanie nowego studenta",
      "Wyświetlenie danych studenta",
      "Edycja danych studenta",
      "Usunięcie studenta z bazy"
    ],
    "correct": [
      "Dodanie nowego studenta",
      "Wyświetlenie danych studenta",
      "Edycja danych studenta",
      "Usunięcie studenta z bazy"
    ],
    "explanation": "CRUD w praktyce: najpierw tworzymy, potem odczytujemy, aktualizujemy i ewentualnie usuwamy dane.",
    "auto_id": 207
  },
  {
    "type": "order",
    "question": "Uporządkuj odpowiadające metody HTTP do operacji CRUD",
    "steps": [
      "POST",
      "GET",
      "PUT/PATCH",
      "DELETE"
    ],
    "correct": [
      "POST",
      "GET",
      "PUT/PATCH",
      "DELETE"
    ],
    "explanation": "REST API mapuje CRUD na metody HTTP w tej właśnie kolejności.",
    "auto_id": 208
  },
  {
    "type": "order",
    "question": "Uporządkuj działania programisty przy implementacji CRUD dla nowego zasobu",
    "steps": [
      "Zdefiniowanie modelu danych",
      "Dodanie endpointów API",
      "Dodanie walidacji danych",
      "Testowanie operacji"
    ],
    "correct": [
      "Zdefiniowanie modelu danych",
      "Dodanie endpointów API",
      "Dodanie walidacji danych",
      "Testowanie operacji"
    ],
    "explanation": "Tworzenie CRUD-a zwykle zaczyna się od modelu, przez API aż do testów.",
    "auto_id": 209
  },
  {
    "type": "order",
    "question": "Uporządkuj operacje CRUD dla tabeli „Produkty” w kolejności logicznego cyklu życia produktu",
    "steps": [
      "Create – dodanie produktu",
      "Read – przeglądanie katalogu",
      "Update – aktualizacja danych",
      "Delete – usunięcie z oferty"
    ],
    "correct": [
      "Create – dodanie produktu",
      "Read – przeglądanie katalogu",
      "Update – aktualizacja danych",
      "Delete – usunięcie z oferty"
    ],
    "explanation": "CRUD odzwierciedla pełen cykl życia danych w aplikacji.",
    "auto_id": 210
  },
  {
    "type": "simple_select",
    "question": "Czym są testy jednostkowe (unit tests)?",
    "options": {
      "A": "Testy wyglądu strony",
      "B": "Testy szybkości połączenia",
      "C": "Testy pojedynczych funkcji lub metod",
      "D": "Testy baz danych"
    },
    "correct": "C",
    "explanation": "Testy jednostkowe sprawdzają pojedyncze funkcje lub klasy w izolacji.",
    "auto_id": 211
  },
  {
    "type": "simple_select",
    "question": "Które testy sprawdzają działanie aplikacji z punktu widzenia użytkownika?",
    "options": {
      "A": "Testy regresji",
      "B": "Testy jednostkowe",
      "C": "Testy end-to-end (E2E)",
      "D": "Testy statyczne"
    },
    "correct": "C",
    "explanation": "E2E testują całą aplikację, symulując zachowanie użytkownika.",
    "auto_id": 212
  },
  {
    "type": "simple_select",
    "question": "Czym są testy regresyjne?",
    "options": {
      "A": "Testy działania po wprowadzeniu zmian w kodzie",
      "B": "Testy wyglądu graficznego aplikacji",
      "C": "Testy szybkości internetu",
      "D": "Testy instalatora aplikacji"
    },
    "correct": "A",
    "explanation": "Testy regresji sprawdzają, czy nowe zmiany nie zepsuły istniejącej funkcjonalności.",
    "auto_id": 213
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są podstawowymi typami testów aplikacji webowych?",
    "options": {
      "A": "Testy jednostkowe",
      "B": "Testy integracyjne",
      "C": "Testy funkcjonalne",
      "D": "Testy dźwięku"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Dźwięk nie jest kluczowym elementem aplikacji webowych – pozostałe testy są standardowe.",
    "auto_id": 214
  },
  {
    "type": "multi_select",
    "question": "Które narzędzia są wykorzystywane do testowania aplikacji webowych?",
    "options": {
      "A": "Jest",
      "B": "Cypress",
      "C": "Selenium",
      "D": "Winamp"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Winamp to odtwarzacz muzyki – pozostałe to narzędzia do testowania aplikacji.",
    "auto_id": 215
  },
  {
    "type": "multi_select",
    "question": "Które elementy aplikacji warto testować automatycznie?",
    "options": {
      "A": "Walidację formularzy",
      "B": "Logowanie użytkownika",
      "C": "Styl czcionek w CSS",
      "D": "Obsługę błędnych danych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Walidacja, logika aplikacji i obsługa błędów powinny być testowane – styl to bardziej testy wizualne/UI.",
    "auto_id": 216
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy podstawowego cyklu testowania aplikacji",
    "steps": [
      "Przygotowanie scenariuszy testowych",
      "Uruchomienie testów",
      "Zbieranie wyników",
      "Raportowanie błędów"
    ],
    "correct": [
      "Przygotowanie scenariuszy testowych",
      "Uruchomienie testów",
      "Zbieranie wyników",
      "Raportowanie błędów"
    ],
    "explanation": "To klasyczny cykl testowania: plan → wykonanie → analiza → raport.",
    "auto_id": 217
  },
  {
    "type": "order",
    "question": "Uporządkuj działania testera E2E",
    "steps": [
      "Zalogowanie do systemu",
      "Dodanie produktu do koszyka",
      "Złożenie zamówienia",
      "Wylogowanie"
    ],
    "correct": [
      "Zalogowanie do systemu",
      "Dodanie produktu do koszyka",
      "Złożenie zamówienia",
      "Wylogowanie"
    ],
    "explanation": "To typowy flow testu end-to-end dla sklepu internetowego.",
    "auto_id": 218
  },
  {
    "type": "order",
    "question": "Uporządkuj poziomy testowania aplikacji webowej",
    "steps": [
      "Testy jednostkowe",
      "Testy integracyjne",
      "Testy systemowe",
      "Testy akceptacyjne"
    ],
    "correct": [
      "Testy jednostkowe",
      "Testy integracyjne",
      "Testy systemowe",
      "Testy akceptacyjne"
    ],
    "explanation": "Testowanie przebiega od najmniejszej jednostki kodu po całość systemu.",
    "auto_id": 219
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w testowaniu formularza logowania",
    "steps": [
      "Otwórz stronę logowania",
      "Wprowadź dane",
      "Kliknij „Zaloguj”",
      "Sprawdź komunikat lub przekierowanie"
    ],
    "correct": [
      "Otwórz stronę logowania",
      "Wprowadź dane",
      "Kliknij „Zaloguj”",
      "Sprawdź komunikat lub przekierowanie"
    ],
    "explanation": "To prosty scenariusz testowania działania formularza logowania.",
    "auto_id": 220
  },
  {
    "type": "simple_select",
    "question": "Czym są bazy danych NoSQL?",
    "options": {
      "A": "Bazy wyłącznie tekstowe",
      "B": "Relacyjne bazy danych SQL",
      "C": "Bazy nierelacyjne, często wykorzystywane do przechowywania dużych i zróżnicowanych danych",
      "D": "Systemy operacyjne"
    },
    "correct": "C",
    "explanation": "NoSQL to nierelacyjne bazy danych – często elastyczne i skalowalne, wykorzystywane w nowoczesnych aplikacjach.",
    "auto_id": 221
  },
  {
    "type": "simple_select",
    "question": "Która baza danych jest przykładem bazy NoSQL?",
    "options": {
      "A": "MySQL",
      "B": "PostgreSQL",
      "C": "MongoDB",
      "D": "Oracle"
    },
    "correct": "C",
    "explanation": "MongoDB to popularna dokumentowa baza NoSQL.",
    "auto_id": 222
  },
  {
    "type": "simple_select",
    "question": "Która z poniższych cech NIE dotyczy baz NoSQL?",
    "options": {
      "A": "Sztywna struktura tabel",
      "B": "Wysoka skalowalność pozioma",
      "C": "Przechowywanie dokumentów JSON",
      "D": "Brak konieczności stosowania schematu"
    },
    "correct": "A",
    "explanation": "Bazy NoSQL są elastyczne – nie wymagają sztywnego schematu jak relacyjne bazy danych.",
    "auto_id": 223
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych typów baz danych należą do rodziny NoSQL?",
    "options": {
      "A": "Bazy dokumentowe",
      "B": "Bazy grafowe",
      "C": "Bazy kolumnowe",
      "D": "Bazy transakcyjne SQL"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Bazy dokumentowe, grafowe i kolumnowe to popularne typy NoSQL – transakcyjne SQL są relacyjne.",
    "auto_id": 224
  },
  {
    "type": "multi_select",
    "question": "Które zalety są typowe dla baz NoSQL?",
    "options": {
      "A": "Wysoka skalowalność",
      "B": "Obsługa różnorodnych struktur danych",
      "C": "Sztywny schemat danych",
      "D": "Dobre dopasowanie do aplikacji webowych i mobilnych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Elastyczność schematu i skalowalność czynią NoSQL dobrym wyborem do nowoczesnych aplikacji.",
    "auto_id": 225
  },
  {
    "type": "multi_select",
    "question": "W jakich scenariuszach warto użyć baz NoSQL?",
    "options": {
      "A": "Duże zbiory niestrukturalnych danych",
      "B": "Analiza grafów społecznościowych",
      "C": "Szybki rozwój aplikacji MVP",
      "D": "Zaawansowane zapytania SQL z JOIN"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "NoSQL sprawdza się tam, gdzie struktura danych jest zmienna i potrzebna jest elastyczność – JOIN to domena SQL.",
    "auto_id": 226
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy korzystania z bazy dokumentowej NoSQL (np. MongoDB)",
    "steps": [
      "Utworzenie kolekcji",
      "Dodanie dokumentu",
      "Odczyt dokumentu",
      "Aktualizacja lub usunięcie"
    ],
    "correct": [
      "Utworzenie kolekcji",
      "Dodanie dokumentu",
      "Odczyt dokumentu",
      "Aktualizacja lub usunięcie"
    ],
    "explanation": "To typowy cykl CRUD w bazach NoSQL.",
    "auto_id": 227
  },
  {
    "type": "order",
    "question": "Uporządkuj typy baz NoSQL według skomplikowania struktury przechowywanych danych",
    "steps": [
      "Key-Value",
      "Dokumentowa",
      "Kolumnowa",
      "Grafowa"
    ],
    "correct": [
      "Key-Value",
      "Dokumentowa",
      "Kolumnowa",
      "Grafowa"
    ],
    "explanation": "To klasyfikacja baz NoSQL od najprostszej (Key-Value) do najbardziej złożonej (Grafowa).",
    "auto_id": 228
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy projektowaniu aplikacji z bazą NoSQL",
    "steps": [
      "Dobór typu bazy NoSQL",
      "Określenie struktury danych",
      "Tworzenie operacji CRUD",
      "Optymalizacja zapytań"
    ],
    "correct": [
      "Dobór typu bazy NoSQL",
      "Określenie struktury danych",
      "Tworzenie operacji CRUD",
      "Optymalizacja zapytań"
    ],
    "explanation": "Projekt z NoSQL zaczyna się od wyboru bazy, a kończy na optymalizacji zapytań.",
    "auto_id": 229
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy analizie danych z bazy NoSQL",
    "steps": [
      "Połączenie z bazą",
      "Pobranie danych",
      "Filtrowanie wyników",
      "Prezentacja danych"
    ],
    "correct": [
      "Połączenie z bazą",
      "Pobranie danych",
      "Filtrowanie wyników",
      "Prezentacja danych"
    ],
    "explanation": "Standardowy przepływ analizy danych niezależnie od typu bazy.",
    "auto_id": 230
  },
  {
    "type": "simple_select",
    "question": "Czym są relacyjne bazy danych?",
    "options": {
      "A": "Systemy plików tekstowych",
      "B": "Bazy przechowujące dane w postaci tabel powiązanych relacjami",
      "C": "Edytory grafiki rastrowej",
      "D": "Systemy do tworzenia animacji 3D"
    },
    "correct": "B",
    "explanation": "Relacyjne bazy danych opierają się na tabelach powiązanych relacjami między kolumnami.",
    "auto_id": 231
  },
  {
    "type": "simple_select",
    "question": "Który język służy do operacji na relacyjnych bazach danych?",
    "options": {
      "A": "HTML",
      "B": "SQL",
      "C": "CSS",
      "D": "NoSQL"
    },
    "correct": "B",
    "explanation": "SQL (Structured Query Language) to język zapytań używany do obsługi relacyjnych baz danych.",
    "auto_id": 232
  },
  {
    "type": "simple_select",
    "question": "Która z poniższych baz danych jest relacyjna?",
    "options": {
      "A": "MongoDB",
      "B": "Neo4j",
      "C": "MySQL",
      "D": "Redis"
    },
    "correct": "C",
    "explanation": "MySQL to popularna relacyjna baza danych obsługująca język SQL.",
    "auto_id": 233
  },
  {
    "type": "multi_select",
    "question": "Które cechy są typowe dla relacyjnych baz danych?",
    "options": {
      "A": "Struktura tabelaryczna",
      "B": "Użycie kluczy głównych i obcych",
      "C": "Zmienna struktura danych bez schematu",
      "D": "Relacje między tabelami"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Bazy relacyjne bazują na tabelach, relacjach i kluczach – nie działają bez schematu.",
    "auto_id": 234
  },
  {
    "type": "multi_select",
    "question": "Które operacje można wykonać w języku SQL?",
    "options": {
      "A": "SELECT",
      "B": "INSERT",
      "C": "UPDATE",
      "D": "ANIMATE"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "SQL umożliwia operacje na danych – „ANIMATE” to nie polecenie SQL.",
    "auto_id": 235
  },
  {
    "type": "multi_select",
    "question": "Które zastosowania pasują do relacyjnych baz danych?",
    "options": {
      "A": "Systemy księgowe",
      "B": "Systemy e-commerce",
      "C": "Aplikacje oparte na strukturze tabel",
      "D": "Modelowanie 3D w grach"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Bazy relacyjne dobrze sprawdzają się w aplikacjach o przewidywalnej, tabelarycznej strukturze danych.",
    "auto_id": 236
  },
  {
    "type": "order",
    "question": "Uporządkuj podstawowe kroki projektowania relacyjnej bazy danych",
    "steps": [
      "Identyfikacja encji",
      "Określenie atrybutów",
      "Zdefiniowanie kluczy głównych i obcych",
      "Tworzenie relacji między tabelami"
    ],
    "correct": [
      "Identyfikacja encji",
      "Określenie atrybutów",
      "Zdefiniowanie kluczy głównych i obcych",
      "Tworzenie relacji między tabelami"
    ],
    "explanation": "Projektowanie bazy zaczyna się od określenia danych i ich relacji.",
    "auto_id": 237
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy tworzeniu tabeli SQL",
    "steps": [
      "Zdefiniowanie nazwy tabeli",
      "Określenie kolumn i typów danych",
      "Ustawienie klucza głównego",
      "Zapisanie zapytania CREATE TABLE"
    ],
    "correct": [
      "Zdefiniowanie nazwy tabeli",
      "Określenie kolumn i typów danych",
      "Ustawienie klucza głównego",
      "Zapisanie zapytania CREATE TABLE"
    ],
    "explanation": "Tworzenie tabeli to proces od koncepcji do składni SQL.",
    "auto_id": 238
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy tworzenia relacji między tabelami",
    "steps": [
      "Zidentyfikowanie powiązanych encji",
      "Dodanie klucza obcego",
      "Określenie reguł integralności",
      "Testowanie relacji zapytaniem JOIN"
    ],
    "correct": [
      "Zidentyfikowanie powiązanych encji",
      "Dodanie klucza obcego",
      "Określenie reguł integralności",
      "Testowanie relacji zapytaniem JOIN"
    ],
    "explanation": "Tworzenie relacji polega na łączeniu tabel za pomocą kluczy i testowaniu ich działania.",
    "auto_id": 239
  },
  {
    "type": "order",
    "question": "Uporządkuj podstawowe operacje CRUD w SQL",
    "steps": [
      "INSERT",
      "SELECT",
      "UPDATE",
      "DELETE"
    ],
    "correct": [
      "INSERT",
      "SELECT",
      "UPDATE",
      "DELETE"
    ],
    "explanation": "To standardowa kolejność działań na danych: tworzenie, odczyt, edycja i usuwanie.",
    "auto_id": 240
  },
  {
    "type": "simple_select",
    "question": "Czym jest SQL Injection?",
    "options": {
      "A": "Legalna metoda zapisu danych",
      "B": "Rodzaj formatowania danych w bazie",
      "C": "Atak polegający na wstrzyknięciu złośliwego kodu SQL",
      "D": "Błąd podczas tworzenia tabel"
    },
    "correct": "C",
    "explanation": "SQL Injection to jedno z najgroźniejszych zagrożeń – pozwala napastnikowi wykonywać własne zapytania SQL.",
    "auto_id": 241
  },
  {
    "type": "simple_select",
    "question": "Które działanie może prowadzić do wycieku danych z bazy?",
    "options": {
      "A": "Brak autoryzacji dostępu",
      "B": "Użycie kluczy głównych",
      "C": "Używanie typów danych",
      "D": "Indeksowanie tabel"
    },
    "correct": "A",
    "explanation": "Brak autoryzacji umożliwia niepowołanym osobom dostęp do danych.",
    "auto_id": 242
  },
  {
    "type": "simple_select",
    "question": "Dlaczego hasła w bazach danych powinny być haszowane?",
    "options": {
      "A": "Aby zajmowały mniej miejsca",
      "B": "Aby były łatwe do zapamiętania",
      "C": "Aby zabezpieczyć je przed kradzieżą w razie wycieku",
      "D": "Aby umożliwić sortowanie alfabetyczne"
    },
    "correct": "C",
    "explanation": "Haszowanie zabezpiecza hasła – nawet jeśli baza zostanie wykradziona, oryginalne hasła nie są widoczne.",
    "auto_id": 243
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są zagrożeniami dla baz danych?",
    "options": {
      "A": "SQL Injection",
      "B": "Nieautoryzowany dostęp",
      "C": "Użycie SELECT *",
      "D": "Brak kopii zapasowej"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "SELECT * nie jest zagrożeniem bezpieczeństwa – ale pozostałe mogą prowadzić do poważnych naruszeń.",
    "auto_id": 244
  },
  {
    "type": "multi_select",
    "question": "Które działania pomagają zabezpieczyć bazę danych?",
    "options": {
      "A": "Użycie ról i uprawnień",
      "B": "Szyfrowanie danych",
      "C": "Haszowanie haseł",
      "D": "Przechowywanie haseł w czystym tekście"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Role, szyfrowanie i haszowanie to dobre praktyki bezpieczeństwa – przechowywanie haseł „na czysto” to ogromne ryzyko.",
    "auto_id": 245
  },
  {
    "type": "multi_select",
    "question": "Jakie są skutki ataku SQL Injection?",
    "options": {
      "A": "Utrata danych",
      "B": "Nieautoryzowany dostęp do kont",
      "C": "Zmiana lub usunięcie danych",
      "D": "Zwiększenie prędkości działania bazy"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Ataki SQL Injection mogą prowadzić do przejęcia kontroli nad bazą – nie przyspieszają działania systemu.",
    "auto_id": 246
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki ataku SQL Injection",
    "steps": [
      "Znalezienie podatnego formularza",
      "Wstrzyknięcie złośliwego zapytania SQL",
      "Wykonanie zapytania przez serwer",
      "Uzyskanie danych lub dostępu"
    ],
    "correct": [
      "Znalezienie podatnego formularza",
      "Wstrzyknięcie złośliwego zapytania SQL",
      "Wykonanie zapytania przez serwer",
      "Uzyskanie danych lub dostępu"
    ],
    "explanation": "To typowy scenariusz ataku SQL Injection – zaczyna się od wejścia użytkownika.",
    "auto_id": 247
  },
  {
    "type": "order",
    "question": "Uporządkuj działania zwiększające bezpieczeństwo bazy danych",
    "steps": [
      "Haszowanie haseł użytkowników",
      "Ustalanie ról i uprawnień",
      "Regularne tworzenie kopii zapasowych",
      "Monitorowanie logów dostępu"
    ],
    "correct": [
      "Haszowanie haseł użytkowników",
      "Ustalanie ról i uprawnień",
      "Regularne tworzenie kopii zapasowych",
      "Monitorowanie logów dostępu"
    ],
    "explanation": "Te działania wspólnie chronią dane przed utratą, kradzieżą i nadużyciem.",
    "auto_id": 248
  },
  {
    "type": "order",
    "question": "Uporządkuj działania administratora po wykryciu wycieku danych",
    "steps": [
      "Odcięcie źródła ataku",
      "Zabezpieczenie systemu",
      "Powiadomienie odpowiednich służb i użytkowników",
      "Analiza przyczyn i aktualizacja systemu"
    ],
    "correct": [
      "Odcięcie źródła ataku",
      "Zabezpieczenie systemu",
      "Powiadomienie odpowiednich służb i użytkowników",
      "Analiza przyczyn i aktualizacja systemu"
    ],
    "explanation": "Reakcja powinna być szybka: zatrzymać atak, poinformować, zabezpieczyć i wyciągnąć wnioski.",
    "auto_id": 249
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy tworzenia polityki bezpieczeństwa bazy danych",
    "steps": [
      "Analiza ryzyka",
      "Ustalenie zasad dostępu",
      "Implementacja zabezpieczeń",
      "Szkolenie użytkowników"
    ],
    "correct": [
      "Analiza ryzyka",
      "Ustalenie zasad dostępu",
      "Implementacja zabezpieczeń",
      "Szkolenie użytkowników"
    ],
    "explanation": "Bezpieczeństwo baz danych to także edukacja użytkowników, a nie tylko techniczne zabezpieczenia.",
    "auto_id": 250
  },
  {
    "type": "simple_select",
    "question": "Czym jest rootkit?",
    "options": {
      "A": "Legalny komponent systemu Windows",
      "B": "Zestaw narzędzi ukrywający obecność złośliwego oprogramowania",
      "C": "Antywirus od Microsoftu",
      "D": "Dodatek do przeglądarki internetowej"
    },
    "correct": "B",
    "explanation": "Rootkit ukrywa złośliwe procesy i pliki, umożliwiając długotrwałe przejęcie kontroli nad systemem.",
    "auto_id": 251
  },
  {
    "type": "simple_select",
    "question": "Czym jest exploit systemu operacyjnego?",
    "options": {
      "A": "Zabezpieczenie systemu przed atakiem",
      "B": "Błąd systemu, który może zostać wykorzystany przez atakującego",
      "C": "Aktualizacja oprogramowania",
      "D": "Narzędzie do testowania wydajności"
    },
    "correct": "B",
    "explanation": "Exploit wykorzystuje lukę w systemie operacyjnym, by wykonać nieautoryzowane operacje.",
    "auto_id": 252
  },
  {
    "type": "simple_select",
    "question": "Które konto w systemie operacyjnym jest najczęściej celem ataku?",
    "options": {
      "A": "Gość (Guest)",
      "B": "Użytkownik standardowy",
      "C": "Administrator (root)",
      "D": "Operator drukarki"
    },
    "correct": "C",
    "explanation": "Konto administratora ma najwyższe uprawnienia, więc przejęcie go daje pełną kontrolę nad systemem.",
    "auto_id": 253
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są typowymi zagrożeniami dla systemów operacyjnych?",
    "options": {
      "A": "Malware",
      "B": "Brak aktualizacji bezpieczeństwa",
      "C": "Nieprawidłowe hasła",
      "D": "Zbyt mała ilość RAM-u"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Złośliwe oprogramowanie, przestarzałe systemy i słabe hasła to główne wektory ataku – brak RAM to problem wydajnościowy.",
    "auto_id": 254
  },
  {
    "type": "multi_select",
    "question": "Jakie skutki mogą mieć luki w systemie operacyjnym?",
    "options": {
      "A": "Przejęcie kontroli nad systemem",
      "B": "Kradzież danych",
      "C": "Utrata integralności systemu",
      "D": "Poprawa szybkości systemu"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Luki mogą zostać wykorzystane przez atakującego do przejęcia systemu i manipulacji danymi.",
    "auto_id": 255
  },
  {
    "type": "multi_select",
    "question": "Jakie działania pomagają zabezpieczyć system operacyjny?",
    "options": {
      "A": "Regularne aktualizacje",
      "B": "Używanie kont z ograniczonymi uprawnieniami",
      "C": "Wyłączanie zapory sieciowej",
      "D": "Skanowanie antywirusowe"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Aktualizacje, kontrola uprawnień i antywirus to podstawowe środki bezpieczeństwa – wyłączanie zapory to błąd.",
    "auto_id": 256
  },
  {
    "type": "order",
    "question": "Uporządkuj działania zabezpieczające nowy system operacyjny po instalacji",
    "steps": [
      "Zainstalowanie aktualizacji",
      "Skonfigurowanie zapory sieciowej",
      "Utworzenie użytkowników z ograniczonymi uprawnieniami",
      "Instalacja oprogramowania antywirusowego"
    ],
    "correct": [
      "Zainstalowanie aktualizacji",
      "Skonfigurowanie zapory sieciowej",
      "Utworzenie użytkowników z ograniczonymi uprawnieniami",
      "Instalacja oprogramowania antywirusowego"
    ],
    "explanation": "To zalecana kolejność kroków w celu ochrony systemu od samego początku.",
    "auto_id": 257
  },
  {
    "type": "order",
    "question": "Uporządkuj działania podczas ataku ransomware na system operacyjny",
    "steps": [
      "Odłączenie systemu od sieci",
      "Zatrzymanie działania złośliwego procesu",
      "Analiza przyczyny ataku",
      "Odtworzenie systemu z kopii zapasowej"
    ],
    "correct": [
      "Odłączenie systemu od sieci",
      "Zatrzymanie działania złośliwego procesu",
      "Analiza przyczyny ataku",
      "Odtworzenie systemu z kopii zapasowej"
    ],
    "explanation": "Priorytetem jest powstrzymanie rozprzestrzeniania się ataku, a potem naprawa i analiza.",
    "auto_id": 258
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy przeprowadzenia ataku z wykorzystaniem exploita systemowego",
    "steps": [
      "Identyfikacja podatności systemu",
      "Opracowanie lub użycie gotowego exploita",
      "Uruchomienie exploita na celu",
      "Uzyskanie uprawnień lub danych"
    ],
    "correct": [
      "Identyfikacja podatności systemu",
      "Opracowanie lub użycie gotowego exploita",
      "Uruchomienie exploita na celu",
      "Uzyskanie uprawnień lub danych"
    ],
    "explanation": "To typowy przebieg ataku: luka → exploit → uruchomienie → efekty.",
    "auto_id": 259
  },
  {
    "type": "order",
    "question": "Uporządkuj działania administratora systemu w celu minimalizacji ryzyka ataków",
    "steps": [
      "Włączenie aktualizacji automatycznych",
      "Tworzenie kopii zapasowych",
      "Monitorowanie logów systemowych",
      "Ustalanie silnych polityk haseł"
    ],
    "correct": [
      "Włączenie aktualizacji automatycznych",
      "Ustalanie silnych polityk haseł",
      "Tworzenie kopii zapasowych",
      "Monitorowanie logów systemowych"
    ],
    "explanation": "To podstawowy zestaw działań prewencyjnych dla bezpieczeństwa systemów operacyjnych.",
    "auto_id": 260
  },
  {
    "type": "simple_select",
    "question": "Czym jest atak typu Man-in-the-Middle (MitM)?",
    "options": {
      "A": "Zablokowanie dostępu do internetu",
      "B": "Podsłuchiwanie i modyfikacja komunikacji między dwiema stronami",
      "C": "Zainfekowanie komputera wirusem",
      "D": "Zresetowanie hasła przez administratora"
    },
    "correct": "B",
    "explanation": "Atak MitM polega na przechwyceniu i możliwej manipulacji danymi przesyłanymi między dwoma stronami.",
    "auto_id": 261
  },
  {
    "type": "simple_select",
    "question": "Czym jest atak DDoS?",
    "options": {
      "A": "Złośliwe oprogramowanie szyfrujące pliki",
      "B": "Rodzaj firewalla",
      "C": "Zmasowany atak polegający na przeciążeniu serwera ruchem sieciowym",
      "D": "Automatyczne aktualizacje zabezpieczeń"
    },
    "correct": "C",
    "explanation": "DDoS (Distributed Denial of Service) to przeciążenie systemu ogromną liczbą żądań z wielu źródeł.",
    "auto_id": 262
  },
  {
    "type": "simple_select",
    "question": "Który protokół zapewnia bezpieczną transmisję danych w sieci?",
    "options": {
      "A": "FTP",
      "B": "HTTP",
      "C": "Telnet",
      "D": "HTTPS"
    },
    "correct": "D",
    "explanation": "HTTPS to szyfrowana wersja protokołu HTTP – zapewnia poufność i integralność transmisji.",
    "auto_id": 263
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są zagrożeniami w sieciach komputerowych?",
    "options": {
      "A": "Podsłuchiwanie transmisji (sniffing)",
      "B": "Nieautoryzowany dostęp do routera",
      "C": "Utrata zasilania serwera",
      "D": "Ataki DDoS"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Sniffing, DDoS i dostęp do sprzętu sieciowego to zagrożenia – utrata zasilania to problem infrastrukturalny.",
    "auto_id": 264
  },
  {
    "type": "multi_select",
    "question": "Jakie środki pomagają zabezpieczyć sieci komputerowe?",
    "options": {
      "A": "Szyfrowanie transmisji",
      "B": "Silne hasła do routerów",
      "C": "Firewall",
      "D": "Wyłączanie aktualizacji systemu"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Szyfrowanie, silne hasła i firewall to podstawowe zabezpieczenia – wyłączanie aktualizacji zwiększa ryzyko.",
    "auto_id": 265
  },
  {
    "type": "multi_select",
    "question": "Jakie informacje mogą być wykradzione w ataku MitM?",
    "options": {
      "A": "Hasła i loginy",
      "B": "Dane kart płatniczych",
      "C": "Szyfrowanie SSL",
      "D": "Treści wiadomości przesyłanych w sieci"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Atakujący może przechwycić dowolne dane przesyłane niezaszyfrowanym kanałem.",
    "auto_id": 266
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki ataku Man-in-the-Middle",
    "steps": [
      "Podsłuchanie komunikacji",
      "Przejęcie połączenia",
      "Modyfikacja danych",
      "Przesłanie zmodyfikowanych danych dalej"
    ],
    "correct": [
      "Przejęcie połączenia",
      "Podsłuchanie komunikacji",
      "Modyfikacja danych",
      "Przesłanie zmodyfikowanych danych dalej"
    ],
    "explanation": "Atak MitM zaczyna się od przejęcia połączenia i umożliwia podsłuch oraz manipulację danymi.",
    "auto_id": 267
  },
  {
    "type": "order",
    "question": "Uporządkuj działania zabezpieczające sieć Wi-Fi",
    "steps": [
      "Ustawienie silnego hasła",
      "Wyłączenie WPS",
      "Włączenie szyfrowania WPA2/WPA3",
      "Zmiana domyślnej nazwy sieci (SSID)"
    ],
    "correct": [
      "Zmiana domyślnej nazwy sieci (SSID)",
      "Ustawienie silnego hasła",
      "Włączenie szyfrowania WPA2/WPA3",
      "Wyłączenie WPS"
    ],
    "explanation": "To rekomendowana kolejność konfiguracji bezpiecznej sieci bezprzewodowej.",
    "auto_id": 268
  },
  {
    "type": "simple_select",
    "question": "Na czym polega atak typu sniffing w sieciach komputerowych?",
    "options": {
      "A": "Na przeszukiwaniu zawartości dysku twardego",
      "B": "Na podsłuchiwaniu ruchu sieciowego",
      "C": "Na skanowaniu portów serwera",
      "D": "Na szyfrowaniu danych użytkownika"
    },
    "correct": "B",
    "explanation": "Sniffing to pasywne podsłuchiwanie danych przesyłanych w sieci – często przy użyciu narzędzi typu sniffer.",
    "auto_id": 269
  },
  {
    "type": "simple_select",
    "question": "Co oznacza skrót DDoS?",
    "options": {
      "A": "Distributed Denial of Service",
      "B": "Database Detection of Services",
      "C": "Data Defense over Session",
      "D": "Dynamic Domain Optimization Service"
    },
    "correct": "A",
    "explanation": "DDoS to rozproszony atak polegający na przeciążeniu systemu dużą ilością fałszywych żądań.",
    "auto_id": 270
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych połączeń sieciowych jest bezpieczniejsze?",
    "options": {
      "A": "HTTP",
      "B": "Telnet",
      "C": "FTP",
      "D": "HTTPS"
    },
    "correct": "D",
    "explanation": "HTTPS używa szyfrowania SSL/TLS, co zwiększa bezpieczeństwo przesyłanych danych.",
    "auto_id": 271
  },
  {
    "type": "multi_select",
    "question": "Które działania mogą prowadzić do zagrożeń w sieci komputerowej?",
    "options": {
      "A": "Brak firewalla",
      "B": "Używanie domyślnych haseł",
      "C": "Regularne aktualizacje systemu",
      "D": "Nieszyfrowana transmisja danych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Brak zabezpieczeń i używanie domyślnych danych logowania to typowe luki w bezpieczeństwie.",
    "auto_id": 272
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są typowymi zagrożeniami w sieciach komputerowych?",
    "options": {
      "A": "Man-in-the-Middle (MitM)",
      "B": "ARP Spoofing",
      "C": "SQL Injection",
      "D": "Sniffing"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "SQL Injection dotyczy baz danych, natomiast MitM, ARP spoofing i sniffing to zagrożenia sieciowe.",
    "auto_id": 273
  },
  {
    "type": "multi_select",
    "question": "Które narzędzia służą do ochrony sieci komputerowej?",
    "options": {
      "A": "Firewall",
      "B": "VPN",
      "C": "IDS/IPS",
      "D": "Notepad++"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Firewall, VPN oraz systemy wykrywania intruzów (IDS/IPS) są podstawowymi narzędziami ochrony sieci.",
    "auto_id": 274
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy ataku typu DDoS",
    "steps": [
      "Zainfekowanie komputerów-botów",
      "Skierowanie ruchu do celu",
      "Przeciążenie zasobów ofiary",
      "Zablokowanie działania usługi"
    ],
    "correct": [
      "Zainfekowanie komputerów-botów",
      "Skierowanie ruchu do celu",
      "Przeciążenie zasobów ofiary",
      "Zablokowanie działania usługi"
    ],
    "explanation": "DDoS rozpoczyna się od stworzenia botnetu, którego zadaniem jest atak na określony cel.",
    "auto_id": 275
  },
  {
    "type": "order",
    "question": "Uporządkuj działania zabezpieczające sieć lokalną w firmie",
    "steps": [
      "Zastosowanie firewalla",
      "Segmentacja sieci",
      "Monitorowanie ruchu sieciowego",
      "Regularne testy penetracyjne"
    ],
    "correct": [
      "Zastosowanie firewalla",
      "Segmentacja sieci",
      "Monitorowanie ruchu sieciowego",
      "Regularne testy penetracyjne"
    ],
    "explanation": "To typowe i skuteczne kroki zapewniające bezpieczeństwo sieci korporacyjnej.",
    "auto_id": 276
  },
  {
    "type": "order",
    "question": "Uporządkuj działania w przypadku wykrycia podsłuchu sieciowego (sniffingu)",
    "steps": [
      "Zidentyfikowanie urządzenia podsłuchującego",
      "Odcięcie go od sieci",
      "Zmiana haseł i kluczy szyfrujących",
      "Zgłoszenie incydentu do administratora bezpieczeństwa"
    ],
    "correct": [
      "Zidentyfikowanie urządzenia podsłuchującego",
      "Odcięcie go od sieci",
      "Zmiana haseł i kluczy szyfrujących",
      "Zgłoszenie incydentu do administratora bezpieczeństwa"
    ],
    "explanation": "Szybka reakcja i usunięcie zagrożenia to podstawa – potem przywracamy bezpieczeństwo i raportujemy.",
    "auto_id": 277
  },
  {
    "type": "order",
    "question": "Uporządkuj działania chroniące sieć przed atakiem MitM",
    "steps": [
      "Włączenie HTTPS",
      "Stosowanie VPN",
      "Użycie certyfikatów TLS",
      "Weryfikacja tożsamości serwera"
    ],
    "correct": [
      "Włączenie HTTPS",
      "Użycie certyfikatów TLS",
      "Stosowanie VPN",
      "Weryfikacja tożsamości serwera"
    ],
    "explanation": "Dobre praktyki zabezpieczające komunikację wrażliwą przed przechwyceniem i manipulacją.",
    "auto_id": 278
  },
  {
    "type": "simple_select",
    "question": "Ile warstw posiada model TCP/IP?",
    "options": {
      "A": "2",
      "B": "4",
      "C": "5",
      "D": "7"
    },
    "correct": "B",
    "explanation": "Model TCP/IP składa się z 4 warstw: aplikacji, transportu, internetu i dostępu do sieci.",
    "auto_id": 279
  },
  {
    "type": "simple_select",
    "question": "Która warstwa modelu TCP/IP odpowiada za przesyłanie danych między hostami końcowymi?",
    "options": {
      "A": "Warstwa aplikacji",
      "B": "Warstwa transportowa",
      "C": "Warstwa internetowa",
      "D": "Warstwa dostępu do sieci"
    },
    "correct": "B",
    "explanation": "Warstwa transportowa (np. TCP/UDP) odpowiada za komunikację między aplikacjami na różnych hostach.",
    "auto_id": 280
  },
  {
    "type": "simple_select",
    "question": "Który protokół pracuje w warstwie internetowej modelu TCP/IP?",
    "options": {
      "A": "FTP",
      "B": "IP",
      "C": "TCP",
      "D": "DHCP"
    },
    "correct": "B",
    "explanation": "Protokół IP (Internet Protocol) działa w warstwie internetowej i odpowiada za adresację oraz routowanie.",
    "auto_id": 281
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych protokołów działają w warstwie aplikacji modelu TCP/IP?",
    "options": {
      "A": "HTTP",
      "B": "DNS",
      "C": "TCP",
      "D": "FTP"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "HTTP, FTP i DNS należą do warstwy aplikacji – TCP działa w warstwie transportowej.",
    "auto_id": 282
  },
  {
    "type": "multi_select",
    "question": "Które funkcje realizuje warstwa transportowa w modelu TCP/IP?",
    "options": {
      "A": "Zarządzanie sesją i portami",
      "B": "Kontrola błędów transmisji",
      "C": "Wysyłanie pakietów między sieciami",
      "D": "Segmentacja i reassembly danych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Transport zapewnia niezawodność, zarządza portami, segmentuje dane – routowanie to warstwa internetowa.",
    "auto_id": 283
  },
  {
    "type": "multi_select",
    "question": "Które warstwy modelu TCP/IP mają odpowiedniki w modelu OSI?",
    "options": {
      "A": "Warstwa aplikacji (OSI: aplikacji, prezentacji, sesji)",
      "B": "Warstwa transportowa (OSI: transportowa)",
      "C": "Warstwa internetowa (OSI: sieciowa)",
      "D": "Warstwa dostępu do sieci (OSI: łącza danych + fizyczna)"
    },
    "correct": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Każda z warstw TCP/IP ma swój odpowiednik w modelu OSI – choć niektóre łączą kilka poziomów.",
    "auto_id": 284
  },
  {
    "type": "order",
    "question": "Uporządkuj warstwy modelu TCP/IP od najwyższej do najniższej",
    "steps": [
      "Warstwa aplikacji",
      "Warstwa transportowa",
      "Warstwa internetowa",
      "Warstwa dostępu do sieci"
    ],
    "correct": [
      "Warstwa aplikacji",
      "Warstwa transportowa",
      "Warstwa internetowa",
      "Warstwa dostępu do sieci"
    ],
    "explanation": "To standardowa struktura modelu TCP/IP od poziomu użytkownika do fizycznej transmisji.",
    "auto_id": 285
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki przesyłu danych w modelu TCP/IP (z punktu widzenia nadawcy)",
    "steps": [
      "Dane aplikacji są generowane",
      "Dane są segmentowane i oznaczane portem",
      "Dane są opakowane w pakiety IP",
      "Pakiety są przesyłane przez medium sieciowe"
    ],
    "correct": [
      "Dane aplikacji są generowane",
      "Dane są segmentowane i oznaczane portem",
      "Dane są opakowane w pakiety IP",
      "Pakiety są przesyłane przez medium sieciowe"
    ],
    "explanation": "Każda warstwa przetwarza dane i przekazuje je niżej – aż do fizycznej transmisji.",
    "auto_id": 286
  },
  {
    "type": "order",
    "question": "Uporządkuj protokoły według warstw TCP/IP, od warstwy aplikacji w dół",
    "steps": [
      "HTTP",
      "TCP",
      "IP",
      "Ethernet"
    ],
    "correct": [
      "HTTP",
      "TCP",
      "IP",
      "Ethernet"
    ],
    "explanation": "HTTP → aplikacja, TCP → transport, IP → internet, Ethernet → dostęp do sieci.",
    "auto_id": 287
  },
  {
    "type": "order",
    "question": "Uporządkuj działania odbiorcy danych w modelu TCP/IP (od odbioru do aplikacji)",
    "steps": [
      "Odebranie ramek przez kartę sieciową",
      "Rozpakowanie pakietu IP",
      "Złożenie segmentów w dane",
      "Przekazanie danych do aplikacji"
    ],
    "correct": [
      "Odebranie ramek przez kartę sieciową",
      "Rozpakowanie pakietu IP",
      "Złożenie segmentów w dane",
      "Przekazanie danych do aplikacji"
    ],
    "explanation": "Proces odbioru danych przechodzi odwrotną drogę przez warstwy TCP/IP.",
    "auto_id": 288
  },
  {
    "type": "simple_select",
    "question": "Czym jest diagram ERD?",
    "options": {
      "A": "Diagram zależności klas",
      "B": "Diagram pokazujący procesy biznesowe",
      "C": "Diagram relacji encji w bazach danych",
      "D": "Diagram do modelowania sieci komputerowych"
    },
    "correct": "C",
    "explanation": "ERD (Entity-Relationship Diagram) służy do modelowania danych i relacji między encjami w bazie.",
    "auto_id": 289
  },
  {
    "type": "simple_select",
    "question": "Który element ERD reprezentuje byt (np. klient, zamówienie)?",
    "options": {
      "A": "Relacja",
      "B": "Encja",
      "C": "Atrybut",
      "D": "Indeks"
    },
    "correct": "B",
    "explanation": "Encje w ERD to byty rzeczywiste lub logiczne, które przechowują dane (np. Klient, Produkt).",
    "auto_id": 290
  },
  {
    "type": "simple_select",
    "question": "W jakiej fazie projektowania systemu informatycznego stosujemy ERD?",
    "options": {
      "A": "W trakcie pisania kodu",
      "B": "Podczas testowania aplikacji",
      "C": "Na etapie analizy i projektowania bazy danych",
      "D": "Podczas wdrażania aktualizacji"
    },
    "correct": "C",
    "explanation": "Diagram ERD jest używany w fazie projektowania bazy danych i analizy wymagań danych.",
    "auto_id": 291
  },
  {
    "type": "multi_select",
    "question": "Które elementy występują na diagramie ERD?",
    "options": {
      "A": "Encje",
      "B": "Relacje",
      "C": "Atrybuty",
      "D": "Wątki"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "ERD składa się z encji, relacji między nimi i atrybutów – wątki to pojęcie z programowania.",
    "auto_id": 292
  },
  {
    "type": "multi_select",
    "question": "Kiedy warto zastosować ERD?",
    "options": {
      "A": "Przy projektowaniu struktury bazy danych",
      "B": "Podczas analizy zależności między danymi",
      "C": "Przy projektowaniu interfejsu użytkownika",
      "D": "Podczas modelowania danych w hurtowni"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "ERD koncentruje się na danych i relacjach – UI to inna warstwa systemu.",
    "auto_id": 293
  },
  {
    "type": "multi_select",
    "question": "Jakie typy relacji mogą występować w ERD?",
    "options": {
      "A": "jeden do jednego (1:1)",
      "B": "jeden do wielu (1:N)",
      "C": "wiele do wielu (N:M)",
      "D": "kaskadowa do połączonej (K:P)"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Relacje 1:1, 1:N i N:M to podstawowe typy – K:P nie istnieje w ERD.",
    "auto_id": 294
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy tworzenia ERD od podstaw",
    "steps": [
      "Zidentyfikowanie encji",
      "Zdefiniowanie atrybutów encji",
      "Określenie relacji między encjami",
      "Dodanie typów kardynalności"
    ],
    "correct": [
      "Zidentyfikowanie encji",
      "Zdefiniowanie atrybutów encji",
      "Określenie relacji między encjami",
      "Dodanie typów kardynalności"
    ],
    "explanation": "Tworzenie ERD to proces od ogólnego modelu danych po szczegóły relacji.",
    "auto_id": 295
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy analizie istniejącej bazy danych za pomocą ERD",
    "steps": [
      "Eksport struktury bazy",
      "Analiza encji i ich kluczy",
      "Identyfikacja relacji między tabelami",
      "Stworzenie diagramu ERD"
    ],
    "correct": [
      "Eksport struktury bazy",
      "Analiza encji i ich kluczy",
      "Identyfikacja relacji między tabelami",
      "Stworzenie diagramu ERD"
    ],
    "explanation": "Z ERD możemy analizować strukturę danych z istniejącej bazy – krok po kroku.",
    "auto_id": 296
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy interpretacji relacji wiele do wielu w ERD",
    "steps": [
      "Zidentyfikowanie dwóch encji w relacji",
      "Utworzenie tabeli pośredniczącej",
      "Dodanie kluczy obcych do tabeli pośredniczącej",
      "Opisanie relacji w ERD"
    ],
    "correct": [
      "Zidentyfikowanie dwóch encji w relacji",
      "Utworzenie tabeli pośredniczącej",
      "Dodanie kluczy obcych do tabeli pośredniczącej",
      "Opisanie relacji w ERD"
    ],
    "explanation": "Relacje N:M w ERD muszą być reprezentowane przez tabelę pośredniczącą.",
    "auto_id": 297
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy przejścia z diagramu ERD do implementacji w SQL",
    "steps": [
      "Zamiana encji na tabele",
      "Dodanie kluczy głównych i obcych",
      "Zdefiniowanie typów danych",
      "Wygenerowanie skryptu CREATE TABLE"
    ],
    "correct": [
      "Zamiana encji na tabele",
      "Dodanie kluczy głównych i obcych",
      "Zdefiniowanie typów danych",
      "Wygenerowanie skryptu CREATE TABLE"
    ],
    "explanation": "Diagram ERD jest punktem wyjścia do implementacji struktury bazy danych w SQL.",
    "auto_id": 298
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej opisuje wymagania funkcjonalne?",
    "options": {
      "A": "Wymagania dotyczące działania i funkcji systemu",
      "B": "Wymagania dotyczące wydajności serwera",
      "C": "Oczekiwania dotyczące wyglądu UI",
      "D": "Cele marketingowe projektu"
    },
    "correct": "A",
    "explanation": "Wymagania funkcjonalne określają, co system ma robić – np. logowanie, wyszukiwanie, rejestracja.",
    "auto_id": 299
  },
  {
    "type": "simple_select",
    "question": "Które wymaganie jest przykładem niefunkcjonalnego?",
    "options": {
      "A": "System ma umożliwiać logowanie użytkownika",
      "B": "System ma obsługiwać płatności online",
      "C": "Czas odpowiedzi systemu nie może przekraczać 2 sekund",
      "D": "System ma pozwalać na rejestrację konta"
    },
    "correct": "C",
    "explanation": "Wydajność to typowe wymaganie niefunkcjonalne – nie określa funkcji, tylko ich jakość.",
    "auto_id": 300
  },
  {
    "type": "simple_select",
    "question": "Który dokument najczęściej zawiera opis wymagań funkcjonalnych i niefunkcjonalnych?",
    "options": {
      "A": "CV programisty",
      "B": "Plan testów jednostkowych",
      "C": "Specyfikacja wymagań systemowych (SRS)",
      "D": "Logi serwera"
    },
    "correct": "C",
    "explanation": "Specyfikacja wymagań (SRS) zawiera zarówno wymagania funkcjonalne, jak i niefunkcjonalne.",
    "auto_id": 301
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są wymaganiami funkcjonalnymi?",
    "options": {
      "A": "Użytkownik może zresetować hasło",
      "B": "Użytkownik może przeszukiwać katalog produktów",
      "C": "System musi działać 24/7",
      "D": "Administrator może blokować użytkowników"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "C to wymaganie niefunkcjonalne (dostępność) – pozostałe opisują konkretne funkcje systemu.",
    "auto_id": 302
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są przykładami wymagań niefunkcjonalnych?",
    "options": {
      "A": "System musi obsługiwać 10 000 użytkowników jednocześnie",
      "B": "Czas ładowania strony nie może przekraczać 1 sekundy",
      "C": "Logowanie użytkownika musi być możliwe",
      "D": "System powinien być zgodny z RODO"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Wydajność, zgodność z przepisami, dostępność – to wymagania niefunkcjonalne.",
    "auto_id": 303
  },
  {
    "type": "multi_select",
    "question": "Dlaczego rozdzielanie wymagań na funkcjonalne i niefunkcjonalne jest ważne?",
    "options": {
      "A": "Ułatwia planowanie i testowanie systemu",
      "B": "Pozwala lepiej dobrać technologie",
      "C": "Pomaga uniknąć konfliktów z użytkownikami",
      "D": "Zapobiega występowaniu błędów składniowych w kodzie"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Rozdzielenie wymagań wspiera planowanie, architekturę systemu i komunikację z interesariuszami.",
    "auto_id": 304
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy analizy wymagań aplikacji internetowej",
    "steps": [
      "Zbieranie wymagań od interesariuszy",
      "Identyfikacja wymagań funkcjonalnych",
      "Identyfikacja wymagań niefunkcjonalnych",
      "Dokumentacja wymagań"
    ],
    "correct": [
      "Zbieranie wymagań od interesariuszy",
      "Identyfikacja wymagań funkcjonalnych",
      "Identyfikacja wymagań niefunkcjonalnych",
      "Dokumentacja wymagań"
    ],
    "explanation": "Analiza wymagań rozpoczyna się od rozmów z użytkownikami i kończy się formalną dokumentacją.",
    "auto_id": 305
  },
  {
    "type": "order",
    "question": "Uporządkuj przykłady wymagań od funkcjonalnych do niefunkcjonalnych",
    "steps": [
      "System umożliwia rejestrację konta",
      "Użytkownik może zmienić hasło",
      "System działa 24 godziny na dobę",
      "Strona ładuje się maksymalnie 2 sekundy"
    ],
    "correct": [
      "System umożliwia rejestrację konta",
      "Użytkownik może zmienić hasło",
      "System działa 24 godziny na dobę",
      "Strona ładuje się maksymalnie 2 sekundy"
    ],
    "explanation": "Pierwsze dwa to funkcje systemu, kolejne dwa – wymagania jakościowe (dostępność, wydajność).",
    "auto_id": 306
  },
  {
    "type": "order",
    "question": "Uporządkuj działania weryfikacyjne dla wymagań aplikacji",
    "steps": [
      "Przegląd wymagań z klientem",
      "Analiza wykonalności",
      "Walidacja przez zespół QA",
      "Aktualizacja dokumentacji"
    ],
    "correct": [
      "Przegląd wymagań z klientem",
      "Analiza wykonalności",
      "Walidacja przez zespół QA",
      "Aktualizacja dokumentacji"
    ],
    "explanation": "Weryfikacja wymagań to cykl iteracyjny – od zrozumienia potrzeb po techniczną ocenę.",
    "auto_id": 307
  },
  {
    "type": "order",
    "question": "Uporządkuj działania projektanta UX przy uwzględnianiu wymagań niefunkcjonalnych",
    "steps": [
      "Analiza szybkości działania aplikacji",
      "Dostosowanie interfejsu do RWD",
      "Testy dostępności WCAG",
      "Utrzymywanie spójności UI"
    ],
    "correct": [
      "Analiza szybkości działania aplikacji",
      "Dostosowanie interfejsu do RWD",
      "Testy dostępności WCAG",
      "Utrzymywanie spójności UI"
    ],
    "explanation": "Wymagania niefunkcjonalne w UX to m.in. wydajność, dostępność, responsywność i estetyka.",
    "auto_id": 308
  },
  {
    "type": "simple_select",
    "question": "Która technologia pośredniczy między aplikacją internetową a serwerem bazodanowym?",
    "options": {
      "A": "HTML",
      "B": "CSS",
      "C": "Backend/API (np. PHP, Node.js)",
      "D": "Photoshop"
    },
    "correct": "C",
    "explanation": "Aplikacja komunikuje się z bazą danych poprzez warstwę backendową/API.",
    "auto_id": 309
  },
  {
    "type": "simple_select",
    "question": "Czym jest REST API w kontekście aplikacji webowej?",
    "options": {
      "A": "Styl projektowania graficznego",
      "B": "Zestaw zasad komunikacji klient–serwer z wykorzystaniem HTTP",
      "C": "Rodzaj bazy danych",
      "D": "System operacyjny serwera"
    },
    "correct": "B",
    "explanation": "REST API to interfejs komunikacyjny oparty o HTTP, wykorzystywany m.in. do operacji na danych.",
    "auto_id": 310
  },
  {
    "type": "simple_select",
    "question": "Która technologia służy do wykonywania zapytań do bazy z poziomu backendu?",
    "options": {
      "A": "SQL",
      "B": "HTML",
      "C": "SASS",
      "D": "SVG"
    },
    "correct": "A",
    "explanation": "SQL (Structured Query Language) jest podstawowym językiem do komunikacji z relacyjną bazą danych.",
    "auto_id": 311
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych technologii frontendowych mogą komunikować się z backendem?",
    "options": {
      "A": "JavaScript (np. fetch, axios)",
      "B": "React",
      "C": "Vue.js",
      "D": "SQL"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "JavaScript i frameworki frontendowe (React, Vue) korzystają z API – SQL to język zapytań po stronie serwera.",
    "auto_id": 312
  },
  {
    "type": "multi_select",
    "question": "Jakie technologie mobilne umożliwiają komunikację z serwerami bazodanowymi?",
    "options": {
      "A": "Flutter (Dart)",
      "B": "React Native",
      "C": "Android (Java/Kotlin)",
      "D": "XML"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Aplikacje mobilne komunikują się z backendem przez HTTP/REST lub GraphQL – XML to tylko format danych.",
    "auto_id": 313
  },
  {
    "type": "multi_select",
    "question": "Które technologie mogą być używane do tworzenia REST API dla aplikacji internetowych?",
    "options": {
      "A": "Node.js",
      "B": "PHP",
      "C": "Python (np. Flask, Django)",
      "D": "Figma"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "REST API można tworzyć w Node.js, PHP, Pythonie – Figma to narzędzie graficzne.",
    "auto_id": 314
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy działania aplikacji webowej komunikującej się z bazą danych",
    "steps": [
      "Użytkownik wysyła żądanie z poziomu frontend",
      "Frontend komunikuje się z backendem przez API",
      "Backend wykonuje zapytanie do bazy danych",
      "Wynik jest zwracany i prezentowany użytkownikowi"
    ],
    "correct": [
      "Użytkownik wysyła żądanie z poziomu frontend",
      "Frontend komunikuje się z backendem przez API",
      "Backend wykonuje zapytanie do bazy danych",
      "Wynik jest zwracany i prezentowany użytkownikowi"
    ],
    "explanation": "To standardowy schemat komunikacji klient–serwer w aplikacjach webowych.",
    "auto_id": 315
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy działania aplikacji mobilnej korzystającej z REST API",
    "steps": [
      "Aplikacja mobilna wysyła żądanie HTTP",
      "Backend odbiera żądanie i przetwarza dane",
      "Backend pobiera dane z bazy",
      "Dane są przesyłane do aplikacji mobilnej i wyświetlane"
    ],
    "correct": [
      "Aplikacja mobilna wysyła żądanie HTTP",
      "Backend odbiera żądanie i przetwarza dane",
      "Backend pobiera dane z bazy",
      "Dane są przesyłane do aplikacji mobilnej i wyświetlane"
    ],
    "explanation": "Aplikacje mobilne komunikują się z serwerem przez API, który pośredniczy w kontakcie z bazą danych.",
    "auto_id": 316
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki konfiguracji backendu z dostępem do bazy danych",
    "steps": [
      "Zainstalowanie sterownika bazy danych",
      "Skonfigurowanie połączenia do bazy",
      "Zdefiniowanie zapytań lub modeli danych",
      "Utworzenie endpointów API"
    ],
    "correct": [
      "Zainstalowanie sterownika bazy danych",
      "Skonfigurowanie połączenia do bazy",
      "Zdefiniowanie zapytań lub modeli danych",
      "Utworzenie endpointów API"
    ],
    "explanation": "Połączenie z bazą w backendzie wymaga konfiguracji i przygotowania modelu danych/API.",
    "auto_id": 317
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy pobieraniu danych z bazy przez JavaScript (frontend)",
    "steps": [
      "Wywołanie fetch/axios",
      "Wysłanie żądania do API",
      "Otrzymanie odpowiedzi z backendu",
      "Wyświetlenie danych w interfejsie"
    ],
    "correct": [
      "Wywołanie fetch/axios",
      "Wysłanie żądania do API",
      "Otrzymanie odpowiedzi z backendu",
      "Wyświetlenie danych w interfejsie"
    ],
    "explanation": "JavaScript (frontend) łączy się z API za pomocą funkcji fetch lub bibliotek jak axios, by pobrać dane z bazy.",
    "auto_id": 318
  },
  {
    "type": "simple_select",
    "question": "Czym jest klucz główny (PRIMARY KEY) w tabeli relacyjnej?",
    "options": {
      "A": "Kolumna pozwalająca na duplikaty",
      "B": "Kolumna służąca do sortowania",
      "C": "Kolumna jednoznacznie identyfikująca każdy wiersz",
      "D": "Pole przechowujące sumę kontrolną"
    },
    "correct": "C",
    "explanation": "Klucz główny identyfikuje jednoznacznie każdy rekord – jego wartości muszą być unikalne i nie mogą być puste.",
    "auto_id": 319
  },
  {
    "type": "simple_select",
    "question": "Czym jest klucz obcy (FOREIGN KEY)?",
    "options": {
      "A": "Kolumna przechowująca datę ostatniej aktualizacji",
      "B": "Pole wskazujące na klucz główny w innej tabeli",
      "C": "Automatyczny indeks",
      "D": "Rodzaj aliasu SQL"
    },
    "correct": "B",
    "explanation": "Klucz obcy tworzy relację między tabelami – wskazuje na wartość klucza głównego w innej tabeli.",
    "auto_id": 320
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych stwierdzeń dotyczących klucza głównego jest prawdziwe?",
    "options": {
      "A": "Może zawierać wartości NULL",
      "B": "Może zawierać duplikaty",
      "C": "Musi być unikalny i niepusty",
      "D": "Jest opcjonalny w każdej tabeli"
    },
    "correct": "C",
    "explanation": "PRIMARY KEY wymusza unikalność i brak wartości NULL – jest podstawą integralności danych.",
    "auto_id": 321
  },
  {
    "type": "multi_select",
    "question": "Które typy kluczy występują w relacyjnych bazach danych?",
    "options": {
      "A": "Klucz główny (Primary Key)",
      "B": "Klucz obcy (Foreign Key)",
      "C": "Klucz kandydat (Candidate Key)",
      "D": "Klucz sortujący (Sorting Key)"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Sorting Key to termin z analizy danych, nie występuje jako typ klucza w SQL – pozostałe są standardowe.",
    "auto_id": 322
  },
  {
    "type": "multi_select",
    "question": "Jakie zasady obowiązują klucz główny?",
    "options": {
      "A": "Nie może zawierać NULL",
      "B": "Musi być unikalny",
      "C": "Może składać się z wielu kolumn",
      "D": "Musi wskazywać na klucz w innej tabeli"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Klucz główny może być złożony z kilku kolumn, ale musi być unikalny i niepusty.",
    "auto_id": 323
  },
  {
    "type": "multi_select",
    "question": "Jakie są funkcje kluczy obcych?",
    "options": {
      "A": "Tworzenie relacji między tabelami",
      "B": "Wymuszanie spójności referencyjnej",
      "C": "Umożliwienie JOIN-ów między tabelami",
      "D": "Automatyczne generowanie indeksów graficznych"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Klucze obce pozwalają łączyć dane z różnych tabel i zapewniają integralność danych – nie tworzą indeksów graficznych.",
    "auto_id": 324
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki przy definiowaniu klucza głównego w nowej tabeli",
    "steps": [
      "Wybór unikalnego atrybutu lub zestawu atrybutów",
      "Zdefiniowanie kolumny lub kolumn w tabeli",
      "Oznaczenie wybranej kolumny jako PRIMARY KEY",
      "Zablokowanie możliwości wprowadzenia wartości NULL"
    ],
    "correct": [
      "Wybór unikalnego atrybutu lub zestawu atrybutów",
      "Zdefiniowanie kolumny lub kolumn w tabeli",
      "Oznaczenie wybranej kolumny jako PRIMARY KEY",
      "Zablokowanie możliwości wprowadzenia wartości NULL"
    ],
    "explanation": "Tworzenie klucza głównego to proces projektowy, który kończy się walidacją poprawności danych.",
    "auto_id": 325
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki przy tworzeniu relacji 1:N między tabelami przy użyciu klucza obcego",
    "steps": [
      "Zidentyfikowanie relacji logicznej między tabelami",
      "Dodanie klucza obcego do tabeli \"wiele\"",
      "Wskazanie kolumny z kluczem głównym w tabeli \"jeden\"",
      "Zdefiniowanie reguł spójności referencyjnej"
    ],
    "correct": [
      "Zidentyfikowanie relacji logicznej między tabelami",
      "Dodanie klucza obcego do tabeli \"wiele\"",
      "Wskazanie kolumny z kluczem głównym w tabeli \"jeden\"",
      "Zdefiniowanie reguł spójności referencyjnej"
    ],
    "explanation": "Relacja 1:N wymaga klucza obcego w tabeli podrzędnej oraz określenia zachowania przy modyfikacjach.",
    "auto_id": 326
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy sprawdzania poprawności kluczy w istniejącej bazie danych",
    "steps": [
      "Sprawdzenie unikalności klucza głównego",
      "Weryfikacja wartości NULL",
      "Identyfikacja niespójnych kluczy obcych",
      "Naprawa błędów integralności"
    ],
    "correct": [
      "Sprawdzenie unikalności klucza głównego",
      "Weryfikacja wartości NULL",
      "Identyfikacja niespójnych kluczy obcych",
      "Naprawa błędów integralności"
    ],
    "explanation": "Sprawdzanie integralności danych zaczyna się od klucza głównego i przechodzi do relacji między tabelami.",
    "auto_id": 327
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy projektowaniu tabeli pośredniczącej dla relacji N:M",
    "steps": [
      "Stworzenie tabeli pośredniczącej",
      "Dodanie dwóch kluczy obcych",
      "Ustawienie klucza złożonego jako PRIMARY KEY",
      "Zdefiniowanie relacji do obu tabel głównych"
    ],
    "correct": [
      "Stworzenie tabeli pośredniczącej",
      "Dodanie dwóch kluczy obcych",
      "Ustawienie klucza złożonego jako PRIMARY KEY",
      "Zdefiniowanie relacji do obu tabel głównych"
    ],
    "explanation": "Relacja N:M wymaga tabeli pośredniczącej z dwoma kluczami obcymi i kluczem złożonym.",
    "auto_id": 328
  },
  {
    "type": "simple_select",
    "question": "Czym jest operacja JOIN w SQL?",
    "options": {
      "A": "Funkcja do szyfrowania danych",
      "B": "Złączenie kolumn z jednej tabeli",
      "C": "Sposób łączenia danych z dwóch lub więcej tabel na podstawie relacji między nimi",
      "D": "Tworzenie indeksu na kolumnie"
    },
    "correct": "C",
    "explanation": "JOIN umożliwia pobieranie danych z wielu tabel jednocześnie na podstawie wspólnych wartości.",
    "auto_id": 329
  },
  {
    "type": "simple_select",
    "question": "Które złączenie zwraca tylko pasujące rekordy z obu tabel?",
    "options": {
      "A": "LEFT JOIN",
      "B": "RIGHT JOIN",
      "C": "INNER JOIN",
      "D": "FULL OUTER JOIN"
    },
    "correct": "C",
    "explanation": "INNER JOIN zwraca tylko te rekordy, które mają dopasowanie w obu tabelach.",
    "auto_id": 330
  },
  {
    "type": "simple_select",
    "question": "Do czego służy LEFT JOIN?",
    "options": {
      "A": "Zwraca tylko pasujące rekordy z obu tabel",
      "B": "Zwraca wszystkie rekordy z lewej tabeli i dopasowane z prawej",
      "C": "Zwraca tylko unikalne rekordy z obu tabel",
      "D": "Łączy wszystkie rekordy bez warunku"
    },
    "correct": "B",
    "explanation": "LEFT JOIN zwraca wszystkie rekordy z lewej tabeli i pasujące dane z prawej – brak dopasowania to NULL.",
    "auto_id": 331
  },
  {
    "type": "multi_select",
    "question": "Które typy JOIN są standardowo dostępne w SQL?",
    "options": {
      "A": "INNER JOIN",
      "B": "LEFT JOIN",
      "C": "FULL OUTER JOIN",
      "D": "CROSS JOIN"
    },
    "correct": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Wszystkie te typy JOIN służą do różnych rodzajów łączenia danych między tabelami.",
    "auto_id": 332
  },
  {
    "type": "multi_select",
    "question": "Które złączenia mogą zwrócić rekordy z jednej tabeli, nawet jeśli brak dopasowania w drugiej?",
    "options": {
      "A": "LEFT JOIN",
      "B": "RIGHT JOIN",
      "C": "INNER JOIN",
      "D": "FULL OUTER JOIN"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "LEFT, RIGHT i FULL JOIN mogą zwrócić rekordy, które nie mają dopasowania – INNER tego nie zrobi.",
    "auto_id": 333
  },
  {
    "type": "multi_select",
    "question": "Jakie zagrożenia mogą wystąpić przy nieprawidłowym użyciu JOIN?",
    "options": {
      "A": "Duplikacja danych w wynikach",
      "B": "Pusta tabela wynikowa",
      "C": "Przeciążenie bazy danych",
      "D": "Skasowanie danych w tabeli"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Nieprawidłowe złączenia mogą prowadzić do błędnych wyników i problemów z wydajnością – ale JOIN nie kasuje danych.",
    "auto_id": 334
  },
  {
    "type": "order",
    "question": "Uporządkuj typy JOIN według zakresu zwracanych danych (od najmniej do najbardziej pełnego)",
    "steps": [
      "INNER JOIN",
      "LEFT JOIN",
      "RIGHT JOIN",
      "FULL OUTER JOIN"
    ],
    "correct": [
      "INNER JOIN",
      "LEFT JOIN",
      "RIGHT JOIN",
      "FULL OUTER JOIN"
    ],
    "explanation": "INNER – tylko dopasowania, LEFT/RIGHT – dopasowania + brak z jednej strony, FULL – wszystkie dane.",
    "auto_id": 335
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki wykonania zapytania SQL z JOIN",
    "steps": [
      "Wybranie tabel do złączenia",
      "Określenie typu złączenia (JOIN)",
      "Zdefiniowanie warunku ON",
      "Wybranie kolumn do zwrócenia"
    ],
    "correct": [
      "Wybranie tabel do złączenia",
      "Określenie typu złączenia (JOIN)",
      "Zdefiniowanie warunku ON",
      "Wybranie kolumn do zwrócenia"
    ],
    "explanation": "Poprawne zapytanie z JOIN wymaga wskazania tabel, typu złączenia, warunku i kolumn.",
    "auto_id": 336
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki interpretacji wyników LEFT JOIN",
    "steps": [
      "Zidentyfikowanie tabeli głównej (lewej)",
      "Sprawdzenie wartości z prawej tabeli",
      "Zwrócenie wartości NULL, jeśli brak dopasowania",
      "Analiza kompletności danych"
    ],
    "correct": [
      "Zidentyfikowanie tabeli głównej (lewej)",
      "Sprawdzenie wartości z prawej tabeli",
      "Zwrócenie wartości NULL, jeśli brak dopasowania",
      "Analiza kompletności danych"
    ],
    "explanation": "LEFT JOIN zawsze zwraca dane z lewej tabeli – dopasowania z prawej mogą być puste (NULL).",
    "auto_id": 337
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy debugowaniu błędnych wyników zapytania z JOIN",
    "steps": [
      "Sprawdzenie nazw i typów kolumn",
      "Weryfikacja warunku ON",
      "Zamiana JOIN na LEFT JOIN do testów",
      "Analiza danych wyjściowych"
    ],
    "correct": [
      "Sprawdzenie nazw i typów kolumn",
      "Weryfikacja warunku ON",
      "Zamiana JOIN na LEFT JOIN do testów",
      "Analiza danych wyjściowych"
    ],
    "explanation": "Błędy w JOIN często wynikają ze złych warunków lub typów danych – LEFT JOIN pomaga w diagnostyce.",
    "auto_id": 338
  },
  {
    "type": "simple_select",
    "question": "Czym jest responsywność w aplikacjach internetowych?",
    "options": {
      "A": "Zdolność do odpowiadania na e-maile użytkowników",
      "B": "Dostosowanie wyglądu aplikacji do różnych urządzeń i rozdzielczości ekranu",
      "C": "Szybkość działania zapytań do bazy danych",
      "D": "Rodzaj aplikacji desktopowej"
    },
    "correct": "B",
    "explanation": "Responsywność oznacza, że interfejs aplikacji dopasowuje się do urządzenia – telefonu, tabletu, laptopa.",
    "auto_id": 339
  },
  {
    "type": "simple_select",
    "question": "Która z technologii jest najczęściej wykorzystywana do tworzenia responsywnych interfejsów?",
    "options": {
      "A": "SQL",
      "B": "CSS media queries",
      "C": "PHP",
      "D": "JSON"
    },
    "correct": "B",
    "explanation": "Media queries w CSS pozwalają stosować różne style w zależności od wielkości ekranu.",
    "auto_id": 340
  },
  {
    "type": "simple_select",
    "question": "Który framework frontendowy oferuje gotowe klasy do budowy responsywnego UI?",
    "options": {
      "A": "Bootstrap",
      "B": "Laravel",
      "C": "Node.js",
      "D": "MySQL"
    },
    "correct": "A",
    "explanation": "Bootstrap zawiera gotowe siatki, klasy i komponenty ułatwiające tworzenie responsywnych layoutów.",
    "auto_id": 341
  },
  {
    "type": "multi_select",
    "question": "Które elementy wpływają na responsywność aplikacji internetowej?",
    "options": {
      "A": "Media queries",
      "B": "Elastyczne siatki (grids)",
      "C": "Obrazy skalujące się do rozmiaru ekranu",
      "D": "Stała szerokość wszystkich elementów w pikselach"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Responsywność opiera się na elastycznym układzie i elementach skalujących się – sztywne rozmiary ograniczają dostosowanie.",
    "auto_id": 342
  },
  {
    "type": "multi_select",
    "question": "Dlaczego responsywność jest ważna?",
    "options": {
      "A": "Poprawia doświadczenie użytkownika (UX)",
      "B": "Zwiększa dostępność na różnych urządzeniach",
      "C": "Ma wpływ na pozycjonowanie w Google",
      "D": "Przyspiesza działanie bazy danych"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "UX, dostępność i SEO są silnie powiązane z responsywnością – wydajność bazy to inny temat.",
    "auto_id": 343
  },
  {
    "type": "multi_select",
    "question": "Jakie dobre praktyki wspierają tworzenie responsywnych aplikacji?",
    "options": {
      "A": "Projektowanie mobile-first",
      "B": "Unikanie jednostek pikselowych na rzecz procentów i em",
      "C": "Testowanie na wielu urządzeniach",
      "D": "Wyłączanie skalowania strony w przeglądarce"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Mobile-first, elastyczne jednostki i testowanie to kluczowe praktyki – wyłączanie skalowania jest niezalecane.",
    "auto_id": 344
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki projektowania responsywnej aplikacji webowej",
    "steps": [
      "Projektowanie layoutu mobile-first",
      "Dodanie media queries dla większych ekranów",
      "Zastosowanie elastycznych siatek i jednostek",
      "Testowanie aplikacji na różnych urządzeniach"
    ],
    "correct": [
      "Projektowanie layoutu mobile-first",
      "Zastosowanie elastycznych siatek i jednostek",
      "Dodanie media queries dla większych ekranów",
      "Testowanie aplikacji na różnych urządzeniach"
    ],
    "explanation": "Responsywny design zwykle zaczyna się od najmniejszych ekranów, a następnie skalowany jest w górę.",
    "auto_id": 345
  },
  {
    "type": "order",
    "question": "Uporządkuj działania programisty implementującego layout responsywny",
    "steps": [
      "Stworzenie elastycznego układu strony",
      "Zdefiniowanie breakpointów w CSS",
      "Dostosowanie komponentów do rozmiaru ekranu",
      "Walidacja widoku na różnych rozdzielczościach"
    ],
    "correct": [
      "Stworzenie elastycznego układu strony",
      "Zdefiniowanie breakpointów w CSS",
      "Dostosowanie komponentów do rozmiaru ekranu",
      "Walidacja widoku na różnych rozdzielczościach"
    ],
    "explanation": "Każdy z etapów jest częścią procesu implementacji responsywnego interfejsu.",
    "auto_id": 346
  },
  {
    "type": "order",
    "question": "Uporządkuj działania testera sprawdzającego responsywność aplikacji",
    "steps": [
      "Uruchomienie aplikacji w przeglądarce",
      "Zmiana rozdzielczości/rozmiaru okna",
      "Sprawdzenie czy układ i komponenty się skalują",
      "Zgłoszenie błędów do zespołu"
    ],
    "correct": [
      "Uruchomienie aplikacji w przeglądarce",
      "Zmiana rozdzielczości/rozmiaru okna",
      "Sprawdzenie czy układ i komponenty się skalują",
      "Zgłoszenie błędów do zespołu"
    ],
    "explanation": "Testowanie responsywności polega na symulowaniu różnych ekranów i sprawdzeniu działania UI.",
    "auto_id": 347
  },
  {
    "type": "order",
    "question": "Uporządkuj działania UX designera przy planowaniu responsywnego interfejsu",
    "steps": [
      "Analiza grupy docelowej i typów urządzeń",
      "Projekt makiet w wersji mobilnej",
      "Projekt makiet w wersji desktopowej",
      "Przekazanie projektów do wdrożenia"
    ],
    "correct": [
      "Analiza grupy docelowej i typów urządzeń",
      "Projekt makiet w wersji mobilnej",
      "Projekt makiet w wersji desktopowej",
      "Przekazanie projektów do wdrożenia"
    ],
    "explanation": "Mobile-first to podejście UX zakładające projektowanie od najmniejszego widoku – z naciskiem na użyteczność.",
    "auto_id": 348
  },
  {
    "type": "simple_select",
    "question": "Czym jest konto użytkownika w systemie operacyjnym?",
    "options": {
      "A": "Aplikacja do testowania pamięci",
      "B": "Zestaw danych identyfikujących użytkownika i jego uprawnienia",
      "C": "Zestaw sterowników urządzeń",
      "D": "Tryb awaryjny systemu"
    },
    "correct": "B",
    "explanation": "Konto użytkownika definiuje tożsamość i poziom dostępu w systemie operacyjnym.",
    "auto_id": 349
  },
  {
    "type": "simple_select",
    "question": "Które konto ma pełne uprawnienia do systemu w systemie Linux?",
    "options": {
      "A": "user",
      "B": "admin",
      "C": "root",
      "D": "guest"
    },
    "correct": "C",
    "explanation": "Konto „root” w systemach Linux/Unix ma najwyższe możliwe uprawnienia administracyjne.",
    "auto_id": 350
  },
  {
    "type": "simple_select",
    "question": "Która z poniższych funkcji dotyczy zarządzania użytkownikami?",
    "options": {
      "A": "Tworzenie tabel SQL",
      "B": "Ustawianie rozdzielczości ekranu",
      "C": "Nadawanie uprawnień do plików",
      "D": "Włączanie Bluetooth"
    },
    "correct": "C",
    "explanation": "Uprawnienia do plików i katalogów są częścią zarządzania użytkownikami i bezpieczeństwem systemu.",
    "auto_id": 351
  },
  {
    "type": "multi_select",
    "question": "Jakie informacje są powiązane z kontem użytkownika w systemie?",
    "options": {
      "A": "Nazwa użytkownika (login)",
      "B": "Hasło",
      "C": "Identyfikator użytkownika (UID)",
      "D": "Model karty graficznej"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Dane identyfikacyjne konta to login, hasło i UID – karta graficzna nie ma związku z kontem.",
    "auto_id": 352
  },
  {
    "type": "multi_select",
    "question": "Jakie operacje można wykonywać w ramach zarządzania użytkownikami?",
    "options": {
      "A": "Tworzenie kont użytkowników",
      "B": "Usuwanie kont użytkowników",
      "C": "Zmiana uprawnień dostępu",
      "D": "Formatowanie partycji systemowej"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Zarządzanie użytkownikami obejmuje tworzenie, modyfikację i kontrolę dostępu – formatowanie to operacja systemowa.",
    "auto_id": 353
  },
  {
    "type": "multi_select",
    "question": "Dlaczego warto używać grup użytkowników?",
    "options": {
      "A": "Ułatwiają zarządzanie uprawnieniami wielu użytkowników",
      "B": "Pozwalają ograniczyć dostęp tylko do wybranych zasobów",
      "C": "Zwiększają bezpieczeństwo systemu",
      "D": "Zwiększają wydajność procesora"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Grupy pomagają w zarządzaniu dostępem i bezpieczeństwem – nie wpływają na wydajność CPU.",
    "auto_id": 354
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki tworzenia nowego użytkownika w systemie Linux (np. z użyciem terminala)",
    "steps": [
      "Wywołanie polecenia useradd",
      "Ustawienie hasła użytkownika",
      "Przypisanie do grup",
      "Nadanie uprawnień do katalogów"
    ],
    "correct": [
      "Wywołanie polecenia useradd",
      "Ustawienie hasła użytkownika",
      "Przypisanie do grup",
      "Nadanie uprawnień do katalogów"
    ],
    "explanation": "Tworzenie użytkownika to nie tylko dodanie konta, ale także konfiguracja hasła, grup i dostępów.",
    "auto_id": 355
  },
  {
    "type": "order",
    "question": "Uporządkuj działania przy zmianie uprawnień dostępu do pliku (Linux)",
    "steps": [
      "Sprawdzenie aktualnych uprawnień (ls -l)",
      "Wybranie użytkownika/grupy docelowej",
      "Użycie polecenia chmod",
      "Weryfikacja zmian"
    ],
    "correct": [
      "Sprawdzenie aktualnych uprawnień (ls -l)",
      "Wybranie użytkownika/grupy docelowej",
      "Użycie polecenia chmod",
      "Weryfikacja zmian"
    ],
    "explanation": "Zmiana uprawnień wymaga analizy obecnych ustawień, zastosowania chmod i weryfikacji efektu.",
    "auto_id": 356
  },
  {
    "type": "order",
    "question": "Uporządkuj działania administratora po wykryciu konta z nieautoryzowanym dostępem",
    "steps": [
      "Zablokowanie konta",
      "Przegląd logów aktywności",
      "Zmiana haseł i polityk bezpieczeństwa",
      "Zgłoszenie incydentu i utworzenie raportu"
    ],
    "correct": [
      "Zablokowanie konta",
      "Przegląd logów aktywności",
      "Zmiana haseł i polityk bezpieczeństwa",
      "Zgłoszenie incydentu i utworzenie raportu"
    ],
    "explanation": "W przypadku naruszenia bezpieczeństwa kluczowe są szybkie działania i dokumentacja.",
    "auto_id": 357
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy logowania użytkownika do systemu operacyjnego",
    "steps": [
      "Podanie loginu i hasła",
      "Weryfikacja danych w systemie",
      "Załadowanie profilu użytkownika",
      "Uzyskanie dostępu do zasobów systemu"
    ],
    "correct": [
      "Podanie loginu i hasła",
      "Weryfikacja danych w systemie",
      "Załadowanie profilu użytkownika",
      "Uzyskanie dostępu do zasobów systemu"
    ],
    "explanation": "Logowanie to proces uwierzytelnienia, załadowania środowiska i przydzielenia uprawnień.",
    "auto_id": 358
  },
  {
    "type": "simple_select",
    "question": "Czym jest sieć bezprzewodowa?",
    "options": {
      "A": "Sieć kablowa typu Ethernet",
      "B": "Sieć oparta o fale radiowe, umożliwiająca komunikację bez kabli",
      "C": "Sieć światłowodowa",
      "D": "Sieć oparta wyłącznie na Bluetooth"
    },
    "correct": "B",
    "explanation": "Sieci bezprzewodowe przesyłają dane przez fale radiowe lub podczerwień – bez fizycznych połączeń kablowych.",
    "auto_id": 359
  },
  {
    "type": "simple_select",
    "question": "Która technologia jest najczęściej stosowana w lokalnych sieciach bezprzewodowych?",
    "options": {
      "A": "LTE",
      "B": "5G",
      "C": "Wi-Fi",
      "D": "ZigBee"
    },
    "correct": "C",
    "explanation": "Wi-Fi (standardy IEEE 802.11) to dominująca technologia w sieciach lokalnych bezprzewodowych.",
    "auto_id": 360
  },
  {
    "type": "simple_select",
    "question": "Jakie urządzenie najczęściej umożliwia dostęp do sieci Wi-Fi w domu?",
    "options": {
      "A": "Switch",
      "B": "Router bezprzewodowy",
      "C": "Modem kablowy",
      "D": "Firewall"
    },
    "correct": "B",
    "explanation": "Router bezprzewodowy zapewnia dostęp do Internetu przez Wi-Fi oraz często łączy się z modemem.",
    "auto_id": 361
  },
  {
    "type": "multi_select",
    "question": "Które technologie są przykładami sieci bezprzewodowych?",
    "options": {
      "A": "Wi-Fi",
      "B": "Bluetooth",
      "C": "Ethernet",
      "D": "LTE"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Wi-Fi, Bluetooth i LTE to sieci bezprzewodowe – Ethernet to sieć przewodowa.",
    "auto_id": 362
  },
  {
    "type": "multi_select",
    "question": "Jakie są zalety sieci bezprzewodowych?",
    "options": {
      "A": "Mobilność użytkownika",
      "B": "Łatwa instalacja",
      "C": "Niższe opóźnienia niż w kablu",
      "D": "Brak potrzeby kabli fizycznych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Sieci bezprzewodowe zwiększają mobilność i upraszczają instalację – ale zwykle mają wyższe opóźnienia niż przewodowe.",
    "auto_id": 363
  },
  {
    "type": "multi_select",
    "question": "Jakie zagrożenia występują w sieciach bezprzewodowych?",
    "options": {
      "A": "Podsłuchiwanie transmisji",
      "B": "Nieautoryzowany dostęp",
      "C": "Zakłócenia radiowe",
      "D": "Brak możliwości szyfrowania danych"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Zagrożenia to m.in. podsłuch, ataki, zakłócenia – jednak szyfrowanie (np. WPA2) jest jak najbardziej możliwe.",
    "auto_id": 364
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy konfiguracji domowej sieci Wi-Fi",
    "steps": [
      "Podłączenie routera do Internetu",
      "Wejście do panelu administracyjnego",
      "Ustawienie nazwy sieci (SSID) i hasła",
      "Zapisanie i uruchomienie sieci"
    ],
    "correct": [
      "Podłączenie routera do Internetu",
      "Wejście do panelu administracyjnego",
      "Ustawienie nazwy sieci (SSID) i hasła",
      "Zapisanie i uruchomienie sieci"
    ],
    "explanation": "Konfiguracja sieci Wi-Fi wymaga dostępu do routera i ustawienia parametrów sieci.",
    "auto_id": 365
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy działania urządzenia podłączającego się do Wi-Fi",
    "steps": [
      "Wyszukanie dostępnych sieci",
      "Wybranie sieci i podanie hasła",
      "Nawiązanie połączenia",
      "Uzyskanie adresu IP od DHCP"
    ],
    "correct": [
      "Wyszukanie dostępnych sieci",
      "Wybranie sieci i podanie hasła",
      "Nawiązanie połączenia",
      "Uzyskanie adresu IP od DHCP"
    ],
    "explanation": "Urządzenie łączy się z siecią, a następnie uzyskuje konfigurację IP od serwera DHCP.",
    "auto_id": 366
  },
  {
    "type": "order",
    "question": "Uporządkuj technologie sieci bezprzewodowych od najmniejszego do największego zasięgu",
    "steps": [
      "Bluetooth",
      "Wi-Fi",
      "LTE",
      "5G"
    ],
    "correct": [
      "Bluetooth",
      "Wi-Fi",
      "LTE",
      "5G"
    ],
    "explanation": "Bluetooth działa lokalnie, Wi-Fi na większy zasięg, a LTE i 5G to sieci komórkowe o dużym zasięgu.",
    "auto_id": 367
  },
  {
    "type": "order",
    "question": "Uporządkuj działania administratora w celu zabezpieczenia sieci bezprzewodowej",
    "steps": [
      "Zmiana domyślnego hasła do routera",
      "Włączenie szyfrowania WPA2/WPA3",
      "Wyłączenie WPS",
      "Ograniczenie dostępu na podstawie adresów MAC"
    ],
    "correct": [
      "Zmiana domyślnego hasła do routera",
      "Włączenie szyfrowania WPA2/WPA3",
      "Wyłączenie WPS",
      "Ograniczenie dostępu na podstawie adresów MAC"
    ],
    "explanation": "To podstawowe kroki zabezpieczające domową lub biurową sieć bezprzewodową.",
    "auto_id": 368
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych jest przykładem technologii frontendowej?",
    "options": {
      "A": "Node.js",
      "B": "PHP",
      "C": "HTML",
      "D": "MySQL"
    },
    "correct": "C",
    "explanation": "HTML to podstawowy język znaczników używany do tworzenia struktury stron internetowych po stronie klienta.",
    "auto_id": 369
  },
  {
    "type": "simple_select",
    "question": "Która technologia backendowa umożliwia tworzenie dynamicznych stron po stronie serwera?",
    "options": {
      "A": "CSS",
      "B": "JavaScript",
      "C": "PHP",
      "D": "Bootstrap"
    },
    "correct": "C",
    "explanation": "PHP to popularny język backendowy służący do generowania dynamicznych treści HTML na serwerze.",
    "auto_id": 370
  },
  {
    "type": "simple_select",
    "question": "Za co odpowiada backend w aplikacji internetowej?",
    "options": {
      "A": "Wygląd interfejsu użytkownika",
      "B": "Obsługę stylów i animacji",
      "C": "Logikę biznesową, komunikację z bazą danych i przetwarzanie danych",
      "D": "Tylko za responsywność strony"
    },
    "correct": "C",
    "explanation": "Backend zajmuje się logiką działania aplikacji, przetwarzaniem danych i połączeniami z bazą danych.",
    "auto_id": 371
  },
  {
    "type": "multi_select",
    "question": "Które technologie frontendowe są najczęściej używane?",
    "options": {
      "A": "HTML",
      "B": "CSS",
      "C": "JavaScript",
      "D": "SQL"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "HTML, CSS i JavaScript to trzy filary frontendu – SQL to język zapytań do bazy danych, używany w backendzie.",
    "auto_id": 372
  },
  {
    "type": "multi_select",
    "question": "Które technologie są typowo backendowe?",
    "options": {
      "A": "Node.js",
      "B": "Python (np. Django, Flask)",
      "C": "PHP",
      "D": "React"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Node.js, Python i PHP to technologie serwerowe – React to biblioteka frontendowa.",
    "auto_id": 373
  },
  {
    "type": "multi_select",
    "question": "Jakie funkcje pełni frontend aplikacji internetowej?",
    "options": {
      "A": "Wyświetlanie treści użytkownikowi",
      "B": "Zbieranie danych wejściowych od użytkownika",
      "C": "Logowanie użytkownika do systemu",
      "D": "Stylowanie elementów i interaktywność"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Frontend odpowiada za interfejs – samo logowanie wymaga współpracy z backendem.",
    "auto_id": 374
  },
  {
    "type": "order",
    "question": "Uporządkuj technologie frontendowe według kolejności ładowania w typowej stronie HTML",
    "steps": [
      "HTML (struktura)",
      "CSS (stylowanie)",
      "JavaScript (interaktywność)",
      "Biblioteki i frameworki (np. React, jQuery)"
    ],
    "correct": [
      "HTML (struktura)",
      "CSS (stylowanie)",
      "JavaScript (interaktywność)",
      "Biblioteki i frameworki (np. React, jQuery)"
    ],
    "explanation": "Strona internetowa ładowana jest warstwowo: od struktury przez styl, po logikę i dodatki.",
    "auto_id": 375
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy działania aplikacji webowej przy komunikacji frontend ↔ backend",
    "steps": [
      "Użytkownik wykonuje akcję na stronie",
      "Frontend wysyła żądanie (np. fetch)",
      "Backend przetwarza żądanie i odpytuje bazę danych",
      "Frontend otrzymuje i prezentuje odpowiedź"
    ],
    "correct": [
      "Użytkownik wykonuje akcję na stronie",
      "Frontend wysyła żądanie (np. fetch)",
      "Backend przetwarza żądanie i odpytuje bazę danych",
      "Frontend otrzymuje i prezentuje odpowiedź"
    ],
    "explanation": "Frontend i backend współpracują w czasie rzeczywistym przy obsłudze użytkownika.",
    "auto_id": 376
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki przy tworzeniu prostej aplikacji webowej",
    "steps": [
      "Tworzenie struktury strony (HTML)",
      "Dodanie stylów (CSS)",
      "Zaimplementowanie interakcji (JavaScript)",
      "Połączenie z backendem (np. przez REST API)"
    ],
    "correct": [
      "Tworzenie struktury strony (HTML)",
      "Dodanie stylów (CSS)",
      "Zaimplementowanie interakcji (JavaScript)",
      "Połączenie z backendem (np. przez REST API)"
    ],
    "explanation": "Aplikację webową buduje się krok po kroku – od wyglądu po logikę i integrację.",
    "auto_id": 377
  },
  {
    "type": "order",
    "question": "Uporządkuj backendowe komponenty aplikacji webowej według działania przy zapytaniu klienta",
    "steps": [
      "Odbiór żądania HTTP",
      "Weryfikacja i przetwarzanie danych",
      "Zapytanie do bazy danych",
      "Wysłanie odpowiedzi do klienta"
    ],
    "correct": [
      "Odbiór żądania HTTP",
      "Weryfikacja i przetwarzanie danych",
      "Zapytanie do bazy danych",
      "Wysłanie odpowiedzi do klienta"
    ],
    "explanation": "Typowy backend przetwarza żądanie, komunikuje się z bazą i odpowiada klientowi.",
    "auto_id": 378
  },
  {
    "type": "simple_select",
    "question": "Czym jest web scraping?",
    "options": {
      "A": "Ręczne przepisywanie danych z dokumentów PDF",
      "B": "Proces pobierania danych ze stron internetowych za pomocą automatycznych narzędzi",
      "C": "Szyfrowanie danych w sieci",
      "D": "Typ sortowania danych w bazie danych"
    },
    "correct": "B",
    "explanation": "Web scraping to technika automatycznego zbierania danych ze stron internetowych.",
    "auto_id": 379
  },
  {
    "type": "simple_select",
    "question": "Która z poniższych metod służy do zbierania danych bezpośrednio od użytkowników?",
    "options": {
      "A": "Eksploracja danych",
      "B": "ETL",
      "C": "Formularz online",
      "D": "Backup danych"
    },
    "correct": "C",
    "explanation": "Formularze online są powszechnym sposobem pozyskiwania danych bezpośrednio od użytkowników.",
    "auto_id": 380
  },
  {
    "type": "simple_select",
    "question": "Co oznacza skrót API w kontekście pozyskiwania danych?",
    "options": {
      "A": "Automatic Privacy Integration",
      "B": "Application Programming Interface",
      "C": "Analytical Processing Instance",
      "D": "Active Protocol Interface"
    },
    "correct": "B",
    "explanation": "API to interfejs umożliwiający pobieranie danych i komunikację między aplikacjami.",
    "auto_id": 381
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych są technikami pozyskiwania danych?",
    "options": {
      "A": "Web scraping",
      "B": "Formularze online",
      "C": "Czujniki IoT",
      "D": "Cache przeglądarki"
    },
    "correct": [
      "A",
      "B",
      "C"
    ],
    "explanation": "Scraping, formularze i IoT to aktywne metody pozyskiwania danych – cache służy do przechowywania danych lokalnie.",
    "auto_id": 382
  },
  {
    "type": "multi_select",
    "question": "Jakie cechy powinna mieć dobra technika gromadzenia danych?",
    "options": {
      "A": "Zgodność z RODO lub innymi regulacjami",
      "B": "Niezawodność i skalowalność",
      "C": "Losowość wyników",
      "D": "Dokładność i integralność danych"
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "explanation": "Skuteczne gromadzenie danych musi być legalne, wydajne i zapewniać jakość danych – losowość nie jest cechą pożądaną.",
    "auto_id": 383
  },
  {
    "type": "multi_select",
    "question": "Z jakich źródeł mogą pochodzić dane?",
    "options": {
      "A": "Bazy danych",
      "B": "Aplikacje mobilne",
      "C": "Pliki CSV lub Excel",
      "D": "Kanały RSS i social media"
    },
    "correct": [
      "A",
      "B",
      "C",
      "D"
    ],
    "explanation": "Dane mogą pochodzić z wielu źródeł – zarówno ustrukturyzowanych, jak i nieustrukturyzowanych.",
    "auto_id": 384
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy procesu gromadzenia danych z formularza online",
    "steps": [
      "Użytkownik wypełnia formularz",
      "Dane trafiają do backendu",
      "Dane są walidowane",
      "Dane są zapisane w bazie danych"
    ],
    "correct": [
      "Użytkownik wypełnia formularz",
      "Dane trafiają do backendu",
      "Dane są walidowane",
      "Dane są zapisane w bazie danych"
    ],
    "explanation": "To klasyczny schemat zbierania danych przez aplikację webową.",
    "auto_id": 385
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki pobierania danych z API",
    "steps": [
      "Nawiązanie połączenia z API",
      "Wysłanie zapytania",
      "Odebranie odpowiedzi w formacie JSON lub XML",
      "Zapisanie danych do systemu"
    ],
    "correct": [
      "Nawiązanie połączenia z API",
      "Wysłanie zapytania",
      "Odebranie odpowiedzi w formacie JSON lub XML",
      "Zapisanie danych do systemu"
    ],
    "explanation": "API działa na zasadzie żądanie–odpowiedź – dane są odbierane i integrowane z aplikacją.",
    "auto_id": 386
  },
  {
    "type": "order",
    "question": "Uporządkuj etapy pozyskiwania danych z czujnika IoT",
    "steps": [
      "Odczyt danych przez czujnik",
      "Przesłanie danych do serwera",
      "Analiza danych w systemie",
      "Zapis danych do bazy"
    ],
    "correct": [
      "Odczyt danych przez czujnik",
      "Przesłanie danych do serwera",
      "Zapis danych do bazy",
      "Analiza danych w systemie"
    ],
    "explanation": "Dane z IoT trafiają do systemu, są zapisywane, a następnie analizowane.",
    "auto_id": 387
  },
  {
    "type": "order",
    "question": "Uporządkuj kroki legalnego pozyskiwania danych od użytkowników",
    "steps": [
      "Pozyskanie zgody użytkownika",
      "Zbieranie danych zgodnie z celem",
      "Zabezpieczenie danych przed nieautoryzowanym dostępem",
      "Zapewnienie możliwości usunięcia danych"
    ],
    "correct": [
      "Pozyskanie zgody użytkownika",
      "Zbieranie danych zgodnie z celem",
      "Zabezpieczenie danych przed nieautoryzowanym dostępem",
      "Zapewnienie możliwości usunięcia danych"
    ],
    "explanation": "Zgodność z RODO i innymi regulacjami wymaga świadomego i bezpiecznego przetwarzania danych.",
    "auto_id": 388
  },
  {
    "type": "advenced_simple_select",
    "question": "Który błąd najczęściej uniemożliwia poprawną komunikację aplikacji mobilnej z serwerem bazodanowym poprzez warstwę backend?",
    "options": {
      "A": "Brak stylów CSS w projekcie frontendowym",
      "B": "Odmowa dostępu do API z powodu błędnej konfiguracji CORS lub tokenu",
      "C": "Zastosowanie technologii serverless do aplikacji desktopowej",
      "D": "Użycie protokołu FTP zamiast HTTP w zapytaniach REST",
      "E": "Skonfigurowanie bazy danych w trybie tylko-do-odczytu (read-only)",
      "F": "Wymuszenie szyfrowania SSL jedynie po stronie aplikacji mobilnej bez wsparcia backendu",
      "G": "Umieszczenie kodu SQL we wtyczkach CSS"
    },
    "correct": "B",
    "explanation": "Najczęściej spotykane problemy komunikacji to błędna konfiguracja CORS, brak lub nieprawidłowy token, co prowadzi do odrzucenia żądań.",
    "auto_id": 389
  },
  {
    "type": "advenced_simple_select",
    "question": "W jaki sposób backend (np. REST API) może ułatwić skalowanie aplikacji mobilnej korzystającej z serwera bazodanowego?",
    "options": {
      "A": "Poprzez wyłączenie replikacji danych, aby unikać konfliktów",
      "B": "Stosując mechanizmy load balancera i poziomą replikację bazy wraz z logicznym routingiem zapytań",
      "C": "Wymuszając na kliencie mobilnym samodzielne wykonywanie zapytań SQL bezpośrednio do bazy",
      "D": "Instalując interpretator JavaScript w pamięci telefonu użytkownika",
      "E": "Unikając wszelkich pamięci podręcznych (cache) na warstwie serwera",
      "F": "Przydzielając każdemu użytkownikowi osobny fizyczny serwer w data center",
      "G": "Używając formatu CSV zamiast JSON w odpowiedziach"
    },
    "correct": "B",
    "explanation": "Rozproszone podejście (load balancer + replikacja) pozwala rozdzielić obciążenie i skalować aplikację w poziomie.",
    "auto_id": 390
  },
  {
    "type": "advenced_simple_select",
    "question": "Która konstrukcja klucza w bazie relacyjnej najczęściej prowadzi do problemów z aktualizacją danych?",
    "options": {
      "A": "Klucz główny automatycznie generowany typu auto_increment",
      "B": "Złożony klucz główny (Composite Key) oparty na dwóch kolumnach",
      "C": "Klucz obcy z opcją ON DELETE CASCADE",
      "D": "Użycie kolumny o zmiennym formacie (np. tekst) jako Primary Key",
      "E": "Oddzielenie klucza głównego i klucza unikalnego na dwóch różnych kolumnach",
      "F": "Tablica asocjacyjna z kluczem zewnętrznym do tabeli zwrotów"
    },
    "correct": "D",
    "explanation": "Klucz główny oparty na atrybucie typu tekstowego (zmienny format) może utrudniać i spowalniać aktualizacje oraz łączenia (JOIN).",
    "auto_id": 391
  },
  {
    "type": "advenced_simple_select",
    "question": "Która własność charakteryzuje klucz kandydujący (candidate key) w tabeli relacyjnej?",
    "options": {
      "A": "Każdy candidate key jest zawsze kluczem głównym",
      "B": "Może zawierać wartości NULL w większości wierszy",
      "C": "Jest to minimalny zestaw kolumn zapewniający unikalną identyfikację wierszy",
      "D": "Nie może być unikalny, bo służy do łączenia z innymi tabelami",
      "E": "Znajduje się zawsze w innej tabeli niż klucz główny",
      "F": "Tworzy replikację danych w osobnej bazie"
    },
    "correct": "C",
    "explanation": "Klucz kandydujący to minimalny zestaw atrybutów jednoznacznie identyfikujących rekord, ale niekoniecznie wybrany jako Primary Key.",
    "auto_id": 392
  },
  {
    "type": "advenced_simple_select",
    "question": "Które JOIN może zwrócić rekordy, dla których nie ma dopasowania w lewej tabeli?",
    "options": {
      "A": "INNER JOIN",
      "B": "LEFT JOIN",
      "C": "CROSS JOIN",
      "D": "RIGHT JOIN",
      "E": "SELF JOIN",
      "F": "SEMI JOIN",
      "G": "FULL OUTER JOIN"
    },
    "correct": "D",
    "explanation": "RIGHT JOIN zwraca wszystkie rekordy z prawej tabeli, a z lewej tylko te pasujące – brak dopasowania w lewej daje NULL.",
    "auto_id": 393
  },
  {
    "type": "advenced_simple_select",
    "question": "Która konstrukcja zapytania z JOIN szczególnie obciąża bazę przy dużych tabelach, jeśli brak odpowiednich indeksów?",
    "options": {
      "A": "SELECT * FROM A LEFT JOIN B ON A.id = B.a_id; — z utworzonymi indeksami na kolumnach id i a_id",
      "B": "SELECT * FROM A INNER JOIN B USING (id) — jeśli obie tabele mają klucz id zindeksowany",
      "C": "SELECT * FROM A CROSS JOIN B; — zwracający iloczyn kartezjański, jeśli brak warunków i indeksów",
      "D": "SELECT DISTINCT A.col FROM A RIGHT JOIN B ON B.key = A.key; — klucz jest indeksem klastrowanym",
      "E": "SELECT A.id, B.id FROM A FULL OUTER JOIN B ON A.x = B.x; — obie kolumny x są Primary Key",
      "F": "SELECT COUNT(*) FROM A NATURAL JOIN B; — klucze są znormalizowane i zindeksowane"
    },
    "correct": "C",
    "explanation": "CROSS JOIN generuje iloczyn kartezjański obu tabel, co przy braku indeksów (i warunków) prowadzi do ogromnej liczby połączeń.",
    "auto_id": 394
  },
  {
    "type": "advenced_simple_select",
    "question": "W responsywnym interfejsie, dlaczego kluczowe jest używanie media queries?",
    "options": {
      "A": "Pozwalają dynamicznie wymuszać generowanie zapytań SQL w CSS",
      "B": "Dzięki nim szerokości i układ elementów mogą się dostosowywać do rozdzielczości ekranu",
      "C": "Eliminują potrzebę obsługi dotyku w interfejsie mobilnym",
      "D": "To jedyna metoda na załadowanie obrazków w formacie SVG",
      "E": "Wymagają minimalnej wersji jQuery do obsługi stylów",
      "F": "Redukują liczbę zapytań HTTP do serwera statycznego"
    },
    "correct": "B",
    "explanation": "Media queries w CSS to podstawowy mechanizm dostosowujący layout do wielkości ekranu.",
    "auto_id": 395
  },
  {
    "type": "advenced_simple_select",
    "question": "Która praktyka może generować problemy w responsywności aplikacji?",
    "options": {
      "A": "Wykorzystanie % i viewport width (vw) zamiast px",
      "B": "Umieszczanie kluczowych breakpointów w pliku CSS",
      "C": "Brak meta viewport w sekcji head dokumentu HTML",
      "D": "Zastosowanie frameworka takiego jak Tailwind CSS",
      "E": "Użycie flexbox do rozmieszczenia elementów",
      "F": "Projekt mobile-first i potem rozbudowa stylów"
    },
    "correct": "C",
    "explanation": "Bez meta viewport przeglądarka często wyświetla witrynę w trybie desktop, zmniejszając ją na urządzeniach mobilnych.",
    "auto_id": 396
  },
  {
    "type": "advenced_simple_select",
    "question": "Który algorytm planowania procesów zapewnia w teorii najkrótszy średni czas oczekiwania, ale jest trudny do perfekcyjnej implementacji?",
    "options": {
      "A": "FIFO (First In First Out)",
      "B": "SJF (Shortest Job First)",
      "C": "Round Robin z kwantem czasu 10ms",
      "D": "Priority Scheduling z dynamiczną priorytetyzacją",
      "E": "RR + SJF hybrydowy na przerwaniach We/Wy",
      "F": "Multilevel Feedback Queue z wieloma kolejkami"
    },
    "correct": "B",
    "explanation": "SJF zapewnia najkrótszy średni czas oczekiwania, ale wymaga znajomości czasu wykonania procesów, co nie zawsze jest możliwe.",
    "auto_id": 397
  },
  {
    "type": "advenced_simple_select",
    "question": "Który scenariusz w systemie operacyjnym najczęściej prowadzi do zakleszczenia (deadlock)?",
    "options": {
      "A": "Procesy współdzielą zasoby w trybie tylko-do-odczytu i nigdy nie próbują pisać",
      "B": "Wiele procesów próbuje wykonać te same operacje sieciowe, ale z semaforami",
      "C": "Dwa procesy wzajemnie blokują się na zasobach — każdy czeka, aż drugi zwolni zasób, którego potrzebuje",
      "D": "Stan gotowości jest bardziej rozbudowany niż stan oczekiwania",
      "E": "Dokonujemy automatycznego usunięcia plików tymczasowych w folderze /tmp",
      "F": "Kolejkowanie zadań w trybie single-threaded"
    },
    "correct": "C",
    "explanation": "Deadlock występuje, gdy dwa procesy trzymają nawzajem potrzebne sobie zasoby, czekając w nieskończoność.",
    "auto_id": 398
  },
  {
    "type": "advenced_simple_select",
    "question": "Który plik w systemie Linux gromadzi podstawowe informacje o kontach użytkowników (login, UID, GID, shell)?",
    "options": {
      "A": "/etc/shadow",
      "B": "/etc/passwd",
      "C": "/etc/hosts",
      "D": "/etc/group",
      "E": "/etc/fstab",
      "F": "/usr/bin/users"
    },
    "correct": "B",
    "explanation": "Plik /etc/passwd zawiera login, UID, GID, ścieżkę do katalogu domowego i powłoki. /etc/shadow przechowuje hasła (zahashowane).",
    "auto_id": 399
  },
  {
    "type": "advenced_simple_select",
    "question": "Jaką korzyść zapewniają grupy administratorów (np. 'sudo' w Ubuntu)?",
    "options": {
      "A": "Uniemożliwiają dostęp do wszystkich poleceń systemowych",
      "B": "Pozwalają wybranym użytkownikom wykonywać zadania z uprawnieniami roota po podaniu hasła",
      "C": "Zastępują konto root i blokują jego istnienie",
      "D": "Automatycznie zmieniają właściciela wszystkich plików systemowych",
      "E": "Podwyższają priorytet procesów wszystkich w grupie",
      "F": "Wymagają stale włączonego SELinuxa w trybie enforcing"
    },
    "correct": "B",
    "explanation": "Członkowie grupy sudo mogą chwilowo przejść na wyższe uprawnienia, wykonując polecenia z prawami roota.",
    "auto_id": 400
  },
  {
    "type": "advenced_simple_select",
    "question": "W sieciach bezprzewodowych IEEE 802.11, czym jest SSID?",
    "options": {
      "A": "Identyfikator podsieci IPv4",
      "B": "Krótkofalowy standard łączności do czujników IoT",
      "C": "Nazwa sieci Wi-Fi, rozgłaszana przez punkt dostępu",
      "D": "Szyfrowanie kluczem publicznym w pasmach 2,4/5 GHz",
      "E": "Metoda przydzielania ruchu w protokole NAT",
      "F": "Specjalny rodzaj VPN tunelujący ruch bluetooth"
    },
    "correct": "C",
    "explanation": "SSID to nazwa rozgłaszanej sieci Wi-Fi, którą widzi użytkownik podczas wyboru punktu dostępu.",
    "auto_id": 401
  },
  {
    "type": "advenced_simple_select",
    "question": "Które pasmo częściej jest wykorzystywane do szybszej i mniej zakłóconej komunikacji Wi-Fi (choć o mniejszym zasięgu)?",
    "options": {
      "A": "2,4 GHz",
      "B": "UHF 868 MHz",
      "C": "5 GHz",
      "D": "700 MHz LTE",
      "E": "60 GHz (802.11ad) w domyślnych routerach",
      "F": "1,2 GHz pasmo telewizyjne"
    },
    "correct": "C",
    "explanation": "Pasmo 5 GHz zapewnia wyższe prędkości i mniejsze zakłócenia niż 2,4 GHz, ale zasięg jest zwykle mniejszy.",
    "auto_id": 402
  },
  {
    "type": "advenced_simple_select",
    "question": "Która biblioteka JavaScript jest dedykowana do warstwy frontend, umożliwiając budowę interfejsu w przeglądarce?",
    "options": {
      "A": "Express.js",
      "B": "Angular lub React",
      "C": "Django",
      "D": "Flask",
      "E": "ASP.NET MVC",
      "F": "PostgreSQL"
    },
    "correct": "B",
    "explanation": "Angular i React to popularne biblioteki/frameworki do tworzenia interfejsu frontendowego w JS.",
    "auto_id": 403
  },
  {
    "type": "advenced_simple_select",
    "question": "W kontekście backendu, które zadanie jest kluczowe przy komunikacji z bazą danych?",
    "options": {
      "A": "Generowanie styli CSS w locie",
      "B": "Implementacja zapytań SQL lub ORM, które pobierają i aktualizują dane",
      "C": "Tworzenie animacji 3D w Canvas API",
      "D": "Rozproszone renderowanie layoutu w Node.js bezpośrednio w przeglądarce",
      "E": "Zarządzanie geolokalizacją w plikach cookie",
      "F": "Odczyt wyłącznie metadanych z biblioteki jQuery"
    },
    "correct": "B",
    "explanation": "Backend typowo obsługuje logikę dostępu do bazy danych (SQL lub ORM), odpowiadając na zapytania klienta.",
    "auto_id": 404
  },
  {
    "type": "advenced_simple_select",
    "question": "W architekturze trójwarstwowej, co należy do warstwy danych (Data Layer)?",
    "options": {
      "A": "Frontend, który zarządza interfejsem użytkownika i estetyką strony",
      "B": "Logika biznesowa, która przetwarza reguły i algorytmy",
      "C": "Baza danych i mechanizmy dostępu do niej, np. repozytorium, DAO",
      "D": "Wbudowane style CSS i breakpoints w media queries",
      "E": "Testy eksploracyjne w metodyce Agile",
      "F": "Fizyczna warstwa routera w sieci WAN"
    },
    "correct": "C",
    "explanation": "Warstwa danych w architekturze trójwarstwowej obejmuje bazy danych i komponenty dostępu do nich.",
    "auto_id": 405
  },
  {
    "type": "advenced_simple_select",
    "question": "Która z tych cech najmocniej wskazuje na poprawne wdrożenie architektury trójwarstwowej?",
    "options": {
      "A": "Wszystkie klasy i zapytania SQL w jednym pliku .php",
      "B": "Warstwa prezentacji, logiki i danych są fizycznie i logicznie odseparowane",
      "C": "Brak warstwy bazodanowej, bo wszystko trzymamy w pliku txt",
      "D": "Warstwa logiki biznesowej i frontendu zawsze tożsama",
      "E": "Użycie wyłącznie technologii JavaScript w każdej warstwie",
      "F": "Dostęp do bazy jedynie przez kod CSS w stylach"
    },
    "correct": "B",
    "explanation": "W trójwarstwowej architekturze UI, logika i dane są oddzielone, co poprawia czytelność i ułatwia utrzymanie.",
    "auto_id": 406
  },
  {
    "type": "advenced_simple_select",
    "question": "W pozyskiwaniu danych, czym charakteryzuje się metoda 'crowdsourcingu'?",
    "options": {
      "A": "Zbiórka danych z wielu źródeł, gdzie użytkownicy chętnie i dobrowolnie je dostarczają (np. Wikipedia, ankiety online)",
      "B": "Replikacja za pośrednictwem klastrów Hadoop w topologii master-slave",
      "C": "Blokowanie danych w pamięci wspólnej jednego wątku systemu",
      "D": "Zakaz łączenia się z dowolnym API w chmurze publicznej",
      "E": "Migracja fizycznych dysków twardych z modelu SAN na NAS",
      "F": "Wymaganie protokołu SFTP do każdej transmisji"
    },
    "correct": "A",
    "explanation": "Crowdsourcing polega na gromadzeniu danych od szerokiej społeczności lub użytkowników końcowych.",
    "auto_id": 407
  },
  {
    "type": "advenced_simple_select",
    "question": "W technikach gromadzenia danych, co najczęściej jest powodem stosowania sensorów IoT?",
    "options": {
      "A": "Przetwarzanie jedynie w warstwie frontendu",
      "B": "Unikanie fizycznych pomiarów w czasie rzeczywistym",
      "C": "Automatyczne, ciągłe zbieranie danych z otoczenia (temperatura, wilgotność, lokalizacja itp.) bez udziału człowieka",
      "D": "Zastąpienie potrzeby posiadania serwera bazodanowego",
      "E": "Wyłączne wykorzystanie protokołu FTP w sieciach przewodowych",
      "F": "Całkowite uniemożliwienie komunikacji z chmurą"
    },
    "correct": "C",
    "explanation": "Sensory IoT dokonują automatycznych pomiarów i przesyłają dane, co minimalizuje konieczność manualnego pozyskiwania.",
    "auto_id": 408
  },
  {
    "type": "advenced_simple_select",
    "question": "W jaki sposób backend może obsługiwać transakcje, aby zapewnić integralność danych dla aplikacji mobilnej komunikującej się z bazą?",
    "options": {
      "A": "Przekazując kontrolę transakcji w całości do plików cookies w przeglądarce",
      "B": "Wykorzystując mechanizmy begin/commit/rollback w kodzie backendu lub ORM",
      "C": "Bazując wyłącznie na nadpisywaniu plików .env przy każdym zapisie",
      "D": "Rezygnując z używania kluczy głównych w tabelach bazodanowych",
      "E": "Zmuszając aplikację mobilną do własnoręcznego blokowania rekordów",
      "F": "Podnosząc wyjątkową rolę REST do warstwy SSR (Server-Side Rendering)",
      "G": "Obciążając jedynie front mechaniką potwierdzenia zapisu"
    },
    "correct": "B",
    "explanation": "Obsługa transakcji (BEGIN/COMMIT/ROLLBACK) na poziomie backendu/ORM zapewnia spójność danych przy równoczesnych operacjach.",
    "auto_id": 409
  },
  {
    "type": "advenced_simple_select",
    "question": "Które działanie najskuteczniej usprawnia komunikację między aplikacją mobilną a serwerem bazodanowym przez warstwę API?",
    "options": {
      "A": "Implementacja GraphQL lub dobrze zdefiniowanych endpointów REST, by elastycznie pobierać tylko potrzebne dane",
      "B": "Wstrzyknięcie wszystkich rekordów bazy w jednym wielkim wywołaniu GET bez paginacji",
      "C": "Trzymanie tokenów JWT w plikach logów systemu i odwoływanie się do nich losowo",
      "D": "Zmuszanie klientów do ciągłego polling-u co 50 ms",
      "E": "Wysyłanie struktury surowych plików binarnych w odpowiedziach do minimalizacji JSON",
      "F": "Przetrzymywanie danych w pamięci RAM wyłącznie w aplikacji mobilnej"
    },
    "correct": "A",
    "explanation": "Zarówno GraphQL, jak i dobrze zaprojektowane REST endpoints z paginacją czy filtrami usprawniają komunikację i ograniczają nadmiar przesyłanych danych.",
    "auto_id": 410
  },
  {
    "type": "advenced_simple_select",
    "question": "Który przypadek najlepiej oddaje ideę klucza obcego z relacją 1:1?",
    "options": {
      "A": "Tabelę 'produkty' i 'zdjęcia_produktu', gdzie każdemu produktowi towarzyszy dokładnie jedno zdjęcie",
      "B": "Encję 'klienci' łączącą się z wieloma adresami w relacji 1:N",
      "C": "Tabelę pośredniczącą do reprezentowania związku N:M",
      "D": "Unikalną kolumnę e-mail w tej samej tabeli, co ID klienta",
      "E": "Wspólny klucz główny, który nie jest unikatowy w żadnej tabeli",
      "F": "Relację opartą o kolumnę auto_increment w jednej tabeli i brak klucza w drugiej"
    },
    "correct": "A",
    "explanation": "Relacja 1:1 powstaje, gdy każdemu rekordowi w tabeli A odpowiada dokładnie jeden rekord w tabeli B (np. produkt–jego unikatowe zdjęcie).",
    "auto_id": 411
  },
  {
    "type": "advenced_simple_select",
    "question": "W jakim celu można użyć klucza obcego z opcją ON UPDATE CASCADE?",
    "options": {
      "A": "Aby ignorować aktualizacje klucza w tabeli nadrzędnej",
      "B": "By automatycznie modyfikować wartości w tabeli potomnej, gdy klucz główny w tabeli nadrzędnej ulegnie zmianie",
      "C": "Zawsze uniemożliwia zmiany klucza w tabeli nadrzędnej",
      "D": "Do ograniczenia replikacji binarnej w MySQL",
      "E": "Aby w pełni unieważnić relację 1:N",
      "F": "Wyeliminować regułę ON DELETE CASCADE"
    },
    "correct": "B",
    "explanation": "ON UPDATE CASCADE zapewnia synchronizację wartości klucza w tabeli podrzędnej, gdy zmienia się klucz nadrzędny.",
    "auto_id": 412
  },
  {
    "type": "advenced_simple_select",
    "question": "Który zapis SQL najlepiej opisuje sytuację, w której łączymy się z tabelą samą w sobie (SELF JOIN)?",
    "options": {
      "A": "SELECT * FROM tabela CROSS JOIN tabela2",
      "B": "SELECT a.*, b.* FROM tabela a INNER JOIN tabela b ON a.id=b.id",
      "C": "SELECT e.*, m.name as ManagerName FROM Employees e LEFT JOIN Employees m ON e.ManagerID = m.EmpID",
      "D": "SELECT t.* FROM tabela t FULL JOIN inna_tabela i ON t.x = i.x",
      "E": "SELECT * FROM T CROSS JOIN T",
      "F": "SELECT a.col1, b.col2 FROM T a LEFT JOIN T b ON (1=1)"
    },
    "correct": "C",
    "explanation": "Self join występuje, gdy łączymy w zapytaniu jedną tabelę z samą sobą, np. pracownik–jego menedżer w obrębie tabeli Employees.",
    "auto_id": 413
  },
  {
    "type": "advenced_simple_select",
    "question": "Jakie może być typowe zastosowanie NATURAL JOIN w SQL (choć jest rzadko zalecane)?",
    "options": {
      "A": "Automatyczne łączenie tabel na podstawie kolumn o tej samej nazwie",
      "B": "Ręczne wyszczególnienie wszystkich kolumn w klauzuli ON",
      "C": "Generowanie złączenia kartezjańskiego bez warunków",
      "D": "Podmiana wartości NULL na domyślne w kolumnach klucza",
      "E": "Asocjacja tabel T i T2 w relacji 1:0",
      "F": "Wymuszenie użycia CROSS JOIN w każdej klauzuli FROM"
    },
    "correct": "A",
    "explanation": "NATURAL JOIN automatycznie łączy na kolumnach, które mają identyczne nazwy w obu tabelach, co bywa niebezpieczne jeśli nazwy kolumn zmienią się.",
    "auto_id": 414
  },
  {
    "type": "advenced_simple_select",
    "question": "Który breakpoints w CSS jest najczęściej używany jako punkt przejścia z widoku mobilnego do tabletowego?",
    "options": {
      "A": "640px lub 768px (w zależności od frameworka)",
      "B": "1920px",
      "C": "280px – dedykowany dla smartwatchy",
      "D": "9999px – aby pokryć największe ekrany",
      "E": "320px – stricte telefony retro",
      "F": "1440px – raczej przejście do wielkich monitorów"
    },
    "correct": "A",
    "explanation": "Często 768px jest umownie przyjmowana jako standardowy breakpoint na tablety (choć w różnych frameworkach bywa różnie).",
    "auto_id": 415
  },
  {
    "type": "advenced_simple_select",
    "question": "Który styl CSS bardziej wspiera responsywność strony?",
    "options": {
      "A": "section { width: 1024px; }",
      "B": "img { max-width: 100%; height: auto; }",
      "C": "header { position: fixed; top: 0; }",
      "D": "article { float: left; margin-left: 300px; }",
      "E": "nav { overflow: hidden; }",
      "F": "footer { display: block; max-height: 100px !important; }",
      "G": "div { width: 800px; min-height: 600px; }"
    },
    "correct": "B",
    "explanation": "Stosowanie max-width: 100% i height: auto dla obrazów pozwala im skalować się zgodnie z szerokością rodzica.",
    "auto_id": 416
  },
  {
    "type": "advenced_simple_select",
    "question": "Która cecha planowania Round Robin (RR) sprzyja uczciwości (fairness) w przydzielaniu CPU?",
    "options": {
      "A": "Każdy proces otrzymuje CPU na równy kwant czasu w cyklu",
      "B": "Proces z najkrótszym czasem wykonania jest uprzywilejowany",
      "C": "Priorytet jest zwiększany dla procesów, które najdłużej czekają",
      "D": "Procesy w stanie oczekiwania mają najwyższy priorytet priorytetowy",
      "E": "Pierwszy proces w kolejce otrzymuje CAŁY czas CPU, aż skończy",
      "F": "Kwant czasu jest dynamicznie skracany w zależności od stanu pamięci"
    },
    "correct": "A",
    "explanation": "Round Robin dzieli CPU w sposób cykliczny, każdy proces ma jednakowy przedział czasowy, co zapewnia względną uczciwość.",
    "auto_id": 417
  },
  {
    "type": "advenced_simple_select",
    "question": "Który stan procesu oznacza, że proces oczekuje na zdarzenie zewnętrzne (np. zakończenie operacji I/O), nie rywalizując w tym czasie o CPU?",
    "options": {
      "A": "Running",
      "B": "Ready",
      "C": "Waiting (Blocked)",
      "D": "Terminated",
      "E": "Spawning",
      "F": "Foreground"
    },
    "correct": "C",
    "explanation": "W stanie Waiting/Blocked proces czeka na zakończenie zdarzenia (np. I/O), nie zużywając CPU.",
    "auto_id": 418
  },
  {
    "type": "advenced_simple_select",
    "question": "W systemie Linux, które polecenie służy do trwałego zablokowania konta użytkownika (bez usuwania go)?",
    "options": {
      "A": "passwd -d nazwa_uzytkownika",
      "B": "usermod -L nazwa_uzytkownika (lock)",
      "C": "groupdel nazwa_uzytkownika",
      "D": "chown nazwa_uzytkownika /home/nazwa_uzytkownika",
      "E": "sudo usermod -U nazwa_uzytkownika (unlock)",
      "F": "shadowclear /etc/shadow nazwa_uzytkownika"
    },
    "correct": "B",
    "explanation": "Opcja -L usermod blokuje hasło użytkownika, uniemożliwiając mu logowanie, ale nie usuwa konta.",
    "auto_id": 419
  },
  {
    "type": "advenced_simple_select",
    "question": "Czym charakteryzuje się model uprawnień 'DACL' w systemie Windows NT?",
    "options": {
      "A": "Określa, że każdy proces ma dostęp do wszystkich plików",
      "B": "Definiuje listy kontroli dostępu, gdzie poszczególni użytkownicy/grupy mają określone uprawnienia",
      "C": "Umożliwia wyłącznie dostęp w trybie read-only do całego systemu",
      "D": "Jedynym administratorem jest konto 'guest'",
      "E": "Trzyma definicje uprawnień w pliku /etc/passwd",
      "F": "Nie jest stosowany w Windows, dotyczy jedynie systemów BSD"
    },
    "correct": "B",
    "explanation": "DACL (Discretionary Access Control List) opisuje, kto i w jaki sposób może uzyskiwać dostęp do obiektów w systemie Windows.",
    "auto_id": 420
  },
  {
    "type": "advenced_simple_select",
    "question": "Który standard sieci bezprzewodowych jest przeznaczony do komunikacji o niskim zużyciu energii i krótkim zasięgu, np. w smartbandach?",
    "options": {
      "A": "802.11n (Wi-Fi)",
      "B": "Bluetooth Low Energy (BLE)",
      "C": "NFC (Near Field Communication) w trybie pass-through",
      "D": "WiGig (802.11ad) w paśmie 60 GHz",
      "E": "5G mmWave w sieciach komórkowych",
      "F": "Z-Wave dedykowane wyłącznie do rolet zewnętrznych"
    },
    "correct": "B",
    "explanation": "Bluetooth Low Energy (BLE) jest zoptymalizowany pod kątem niewielkiego zużycia energii w urządzeniach przenośnych.",
    "auto_id": 421
  },
  {
    "type": "advenced_simple_select",
    "question": "Która praktyka najczęściej podnosi bezpieczeństwo sieci Wi-Fi w firmie?",
    "options": {
      "A": "Otwarty dostęp bez hasła w celu łatwej kontroli",
      "B": "Korzystanie z filtrowania adresów MAC jako jedynego zabezpieczenia",
      "C": "Zastosowanie WPA2 lub WPA3 z silnym hasłem i wyłączenie rozgłaszania SSID",
      "D": "Zmiana kanału Wi-Fi co 15 sekund",
      "E": "Wykorzystanie WEP do uproszczenia konfiguracji",
      "F": "Konfigurowanie DHCP na stałe IP"
    },
    "correct": "C",
    "explanation": "Szyfrowanie WPA2/WPA3 i mocne hasło to podstawa; ukrycie SSID może minimalnie zmniejszyć widoczność, choć nie jest kluczowym zabezpieczeniem.",
    "auto_id": 422
  },
  {
    "type": "advenced_simple_select",
    "question": "Który framework Node.js jest głównie dedykowany do szybkiego tworzenia backendu, a nie frontendu?",
    "options": {
      "A": "Express.js",
      "B": "React",
      "C": "Vue.js",
      "D": "Ember",
      "E": "jQuery UI",
      "F": "Next.js (tryb SSR i SSG)"
    },
    "correct": "A",
    "explanation": "Express.js to minimalny framework Node.js do budowania aplikacji serwerowych (backend).",
    "auto_id": 423
  },
  {
    "type": "advenced_simple_select",
    "question": "W warstwie frontendu, dlaczego powszechnie stosuje się bundlery (np. Webpack, Parcel)?",
    "options": {
      "A": "Pozwalają łączyć i optymalizować pliki JS, CSS i zasoby, zmniejszając liczbę żądań i wielkość pakietu",
      "B": "Służą do migracji danych w bazie za pomocą CLI",
      "C": "Umożliwiają konwersję zapytań SQL na format JSON",
      "D": "Wykonują testy jednostkowe w backendzie",
      "E": "Separują definicje kluczy głównych i obcych w ERD",
      "F": "Pozwalają dynamicznie zmieniać strukturę tabel MySQL"
    },
    "correct": "A",
    "explanation": "Bundlery łączą i minimalizują zasoby frontendu, co wpływa na wydajność i organizację projektu.",
    "auto_id": 424
  },
  {
    "type": "advenced_simple_select",
    "question": "W architekturze trójwarstwowej, co znajduje się między warstwą prezentacji a warstwą danych?",
    "options": {
      "A": "Bezpośredni dostęp do bazy z plików HTML",
      "B": "Warstwa logiki aplikacji/biznesowej (np. serwer aplikacji)",
      "C": "Plik PDF z opisem UML",
      "D": "Zbiór pamięci podręcznej w przeglądarce klienta",
      "E": "Tabela rejestrująca logi systemowe",
      "F": "Sekcja HEAD w dokumencie HTML"
    },
    "correct": "B",
    "explanation": "Warstwa logiczna pośredniczy między interfejsem użytkownika a bazą danych, wykonując reguły biznesowe.",
    "auto_id": 425
  },
  {
    "type": "advenced_simple_select",
    "question": "Która sytuacja najlepiej pokazuje skalowanie poziome warstwy danych w architekturze trójwarstwowej?",
    "options": {
      "A": "Zwiększenie pamięci RAM w jednym serwerze SQL",
      "B": "Dodanie wielu węzłów bazodanowych w klastrze replikacji, rozkładając obciążenie zapytań",
      "C": "Zastosowanie nowego szablonu CSS w warstwie prezentacji",
      "D": "Wydzielenie serwera aplikacji na osobny serwer wirtualny",
      "E": "Zastąpienie frontendu biblioteka React",
      "F": "Podniesienie priorytetu procesu bazy w systemie operacyjnym"
    },
    "correct": "B",
    "explanation": "Skalowanie poziome oznacza dodawanie kolejnych instancji (node'ów) w warstwie bazy danych, np. replikacja i load balancing.",
    "auto_id": 426
  },
  {
    "type": "advenced_simple_select",
    "question": "W kontekście pozyskiwania danych, czym różni się metoda ankietowania online od monitoringu logów serwera?",
    "options": {
      "A": "Ankietowanie zbiera dane od serwera, a logi od użytkowników",
      "B": "Ankietowanie wymaga interakcji użytkownika, a logi mogą być zbierane pasywnie bez udziału użytkownika",
      "C": "Tylko logi serwera mogą przetwarzać dane w formacie XML",
      "D": "Ankietowanie jest całkowicie anonimowe, a logi zawsze zawierają dane personalne",
      "E": "Logi nie wymagają żadnych narzędzi do analizy, ankiety są trudne w interpretacji",
      "F": "Ankietowanie nie musi podlegać regulacjom RODO, a logi – tak"
    },
    "correct": "B",
    "explanation": "Ankietowanie wymaga aktywnego wypełnienia formularza przez użytkownika, a logi zbierają się automatycznie.",
    "auto_id": 427
  },
  {
    "type": "advenced_simple_select",
    "question": "W jakim celu stosuje się data scraping z platform mediów społecznościowych?",
    "options": {
      "A": "By wyłącznie generować nowe konta spamerskie",
      "B": "Aby automatycznie usunąć posty z feedu użytkownika",
      "C": "Zebranie informacji (np. sentyment, trend) do dalszych analiz marketingowych lub badawczych",
      "D": "Przekierowywanie ruchu do pliku Dockerfile",
      "E": "Kompresja zasobów do formatu CSV w bazie",
      "F": "Aktualizacja stylów CSS w postach"
    },
    "correct": "C",
    "explanation": "Scraping danych z mediów społecznościowych pozwala analizować zachowania użytkowników, trendy i sentyment.",
    "auto_id": 428
  },
  {
    "type": "definition_typeA",
    "question": "Poniżej przedstawiono trzy definicje różnych terminów związanych z dostępem aplikacji do serwerów bazodanowych. Wskaż, która definicja dotyczy technologii pozwalającej na komunikację między aplikacją mobilną a bazą przez warstwę backend.",
    "definitions": {
      "A": "Mechanizm szyfrowania plików statycznych na serwerze w celu ochrony przed odczytem z dysku.",
      "B": "Zbiór protokołów i narzędzi (np. REST, GraphQL) umożliwiający aplikacjom (również mobilnym) wykonywanie zapytań do bazy poprzez logiczną warstwę serwera.",
      "C": "Metoda bezpośredniego połączenia sterownika JDBC w aplikacji mobilnej z relacyjną bazą danych bez udziału serwera pośredniczącego."
    },
    "correct": "B",
    "explanation": "Definicja B dotyczy technologii backendowej (API, REST, GraphQL) pośredniczącej w dostępie do bazy przez aplikację mobilną.",
    "auto_id": 429
  },
  {
    "type": "definition_typeB",
    "question": "Poniżej znajdziesz trzy z pozoru podobne definicje związane z przesyłaniem danych między aplikacją a serwerem. Która z nich w pełni i poprawnie opisuje pojęcie „API REST”?",
    "definitions": {
      "A": "Interfejs, w którym aplikacja kliencka bezpośrednio wykonuje zapytania SQL do bazy, unikając warstwy serwera.",
      "B": "Zbiór zasad i metod (GET, POST, PUT, DELETE) wykorzystujących protokół HTTP do wymiany danych w formacie JSON lub XML, zwykle implementowany w warstwie serwerowej.",
      "C": "Standard szyfrowania danych w warstwie transportu, pozwalający na tunelowanie ruchu TCP między mikrousługami."
    },
    "correct": "B",
    "explanation": "Definicja B ujmuje zarówno stosowane metody, protokół HTTP i format wymiany (JSON/XML) w pełnej zgodzie z REST.",
    "auto_id": 430
  },
  {
    "type": "definition_typeA",
    "question": "Trzy definicje dotyczą kluczy w kontekście relacyjnych baz danych. Która dotyczy klucza obcego (Foreign Key)?",
    "definitions": {
      "A": "Atrybut (lub atrybuty) identyfikujący unikatowo każdy wiersz w tabeli, nierzadko auto-increment.",
      "B": "Kolumna lub zestaw kolumn wskazujący na klucz główny w innej tabeli, wymuszający relację i spójność referencyjną.",
      "C": "Dodatkowa kolumna nieunikalna, przeznaczona do przechowywania tymczasowych znaczników transakcji."
    },
    "correct": "B",
    "explanation": "Definicja B opisuje klucz obcy, który wiąże tabelę podrzędną z nadrzędną (z kluczem głównym).",
    "auto_id": 431
  },
  {
    "type": "definition_typeB",
    "question": "Poniżej znajdują się trzy definicje zbliżone do klucza kandydującego. Która najtrafniej określa klucz kandydujący (candidate key)?",
    "definitions": {
      "A": "Dowolny atrybut tekstowy, który często się powtarza i nie pełni funkcji identyfikacyjnej w tabeli.",
      "B": "Najmniejszy zestaw kolumn, który może jednoznacznie identyfikować rekord, choć niekoniecznie wybrany jako klucz główny.",
      "C": "Kolumna sum kontrolnych, pozwalająca sprawdzić integralność wiersza po imporcie CSV."
    },
    "correct": "B",
    "explanation": "Klucz kandydujący to minimalny (najmniejszy) zestaw kolumn gwarantujący unikalność, ale niekoniecznie stanowiący Primary Key.",
    "auto_id": 432
  },
  {
    "type": "definition_typeA",
    "question": "Trzy definicje opisują różne rodzaje złączeń w SQL. Wskaż, która dotyczy FULL OUTER JOIN.",
    "definitions": {
      "A": "Złączenie, które zwraca wyłącznie rekordy wspólne dla obu tabel.",
      "B": "Złączenie zwracające wszystkie rekordy z jednej tabeli i dopasowane z drugiej, a brakujące jako NULL.",
      "C": "Złączenie, które zwraca wszystkie rekordy z obu tabel, także te bez dopasowania, wypełniając braki wartościami NULL."
    },
    "correct": "C",
    "explanation": "FULL OUTER JOIN łączy rekordy pasujące i niepasujące, tworząc pełny zbiór z lewej i prawej tabeli.",
    "auto_id": 433
  },
  {
    "type": "definition_typeB",
    "question": "Poniżej przedstawiono trzy definicje, każda opisuje nieco inaczej koncepcję 'INNER JOIN'. Która jest poprawna?",
    "definitions": {
      "A": "Złączenie, które tworzy iloczyn kartezjański wszystkich rekordów z obu tabel, ignorując warunki.",
      "B": "Złączenie, które zwraca rekordy, dla których wartości w klauzuli ON mają dopasowanie w obu tabelach.",
      "C": "Złączenie, które zwraca wyłącznie rekordy z lewej tabeli, nawet jeśli nie ma dopasowania w prawej."
    },
    "correct": "B",
    "explanation": "Inner Join zwraca jedynie pasujące pary rekordów z obu tabel na podstawie warunku ON.",
    "auto_id": 434
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja odnosi się do zjawiska 'responsywności' w aplikacjach webowych?",
    "definitions": {
      "A": "Umiejętność serwera do jednoczesnego obsłużenia tysięcy zapytań HTTP w sekundę bez blokady.",
      "B": "Dostosowanie interfejsu użytkownika (UI) do różnych rozdzielczości ekranu i urządzeń, tak aby zachować czytelność i funkcjonalność.",
      "C": "Protokół szyfrowania ruchu w przeglądarce klienckiej umożliwiający weryfikację tożsamości serwera."
    },
    "correct": "B",
    "explanation": "Responsywność dotyczy dopasowania layoutu i elementów do ekranów o różnej wielkości i orientacji.",
    "auto_id": 435
  },
  {
    "type": "definition_typeB",
    "question": "Poniżej masz trzy definicje pojęcia 'Mobile-first'. Która jest w pełni poprawna?",
    "definitions": {
      "A": "Projektowanie desktopowe w pierwszej kolejności i późniejsze skalowanie w dół.",
      "B": "Rozwijanie interfejsu od najmniejszych wyświetlaczy mobilnych, a następnie dostosowanie do większych ekranów.",
      "C": "Użycie osobnej domeny .mobi i przekierowanie ruchu mobilnego do wersji uproszczonej."
    },
    "correct": "B",
    "explanation": "Mobile-first oznacza projektowanie pod kątem urządzeń mobilnych (smartfonów) jako punktu wyjścia, a później rozbudowę na większe ekrany.",
    "auto_id": 436
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja określa 'zarządzanie procesami' w systemach operacyjnych?",
    "definitions": {
      "A": "Kontrolowanie uprawnień użytkowników i szyfrowanie partycji systemowej.",
      "B": "Mechanizmy tworzenia, planowania i eliminowania procesów, a także przydzielania im zasobów (CPU, pamięci).",
      "C": "Kompresja plików tymczasowych w systemie plików w celu oszczędzania miejsca."
    },
    "correct": "B",
    "explanation": "Zarządzanie procesami obejmuje cykl życia procesów, scheduling CPU, przydział pamięci, obsługę kontekstu itp.",
    "auto_id": 437
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe trzy definicje dotyczą planisty procesów (scheduler). Która jest w pełni poprawna?",
    "definitions": {
      "A": "Planista to moduł systemu, który kopiuje wszystkie wątki do pamięci swap, aby zwolnić RAM.",
      "B": "Planista decyduje, w jakiej kolejności i w jakim czasie poszczególne procesy otrzymują CPU, biorąc pod uwagę priorytety czy kwant czasu.",
      "C": "Planista to proces użytkownika, który ustawia zewnętrzne parametry dysku w rejestrze kernelowym."
    },
    "correct": "B",
    "explanation": "Scheduler przydziela czas procesora procesom, uwzględniając różne algorytmy (FIFO, Round Robin, SJF, Priority).",
    "auto_id": 438
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja właściwie opisuje 'zarządzanie użytkownikami' w systemie operacyjnym?",
    "definitions": {
      "A": "Mechanizm zarządzania modułami jądra do obsługi dysków SSD.",
      "B": "Proces tworzenia i kontrolowania kont użytkowników, grup, przydziału uprawnień oraz uwierzytelniania.",
      "C": "System przydzielania adresów IP w sieci LAN."
    },
    "correct": "B",
    "explanation": "Zarządzanie użytkownikami obejmuje tworzenie kont, ustawianie haseł, przypisywanie ról i kontrolę dostępu.",
    "auto_id": 439
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja dotyczy pojęcia 'hasło cieniowane' (shadowed password) w systemach Unix/Linux?",
    "definitions": {
      "A": "Przechowywanie jawnego hasła użytkownika w pliku /etc/passwd bez ograniczeń dostępu.",
      "B": "Przechowywanie zaszyfrowanego (lub hashowanego) hasła w pliku /etc/shadow, do którego ma ograniczony dostęp tylko root.",
      "C": "Mechanizm generowania haseł jednorazowych w pliku .ssh/authorized_keys."
    },
    "correct": "B",
    "explanation": "Shadowed password umieszczone jest w /etc/shadow i jest dostępne jedynie dla administratora, chroniąc przed odczytem przez zwykłych użytkowników.",
    "auto_id": 440
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja dotyczy 'sieci bezprzewodowej' w kontekście lokalnych połączeń (WLAN)?",
    "definitions": {
      "A": "Fizyczna topologia światłowodowa w sieciach rozległych.",
      "B": "Technologia pozwalająca łączyć urządzenia w obrębie domu lub firmy za pomocą fal radiowych zamiast kabli, np. Wi-Fi.",
      "C": "Metoda sygnowania cyfrowego pakietów IPv6 w globalnym Internecie."
    },
    "correct": "B",
    "explanation": "WLAN (np. Wi-Fi) korzysta z fal radiowych do komunikacji w ograniczonym zasięgu, zastępując przewody.",
    "auto_id": 441
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja najdokładniej opisuje standard 802.11?",
    "definitions": {
      "A": "Protokół routingu OSPF stosowany w sieciach WAN.",
      "B": "Zestaw specyfikacji dotyczących sieci Ethernet w paśmie światłowodowym.",
      "C": "Rodzina standardów IEEE dla sieci bezprzewodowych (Wi-Fi), określająca sposoby modulacji, częstotliwości i mechanizmy bezpieczeństwa."
    },
    "correct": "C",
    "explanation": "IEEE 802.11 to główna rodzina standardów dla sieci Wi-Fi, obejmująca różne warianty (a/b/g/n/ac/ax).",
    "auto_id": 442
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej charakteryzuje podział na frontend i backend?",
    "definitions": {
      "A": "Frontend – warstwa danych, backend – warstwa graficzna.",
      "B": "Frontend – część aplikacji wykonywana w przeglądarce lub na urządzeniu klienta (UI), backend – logika serwerowa, przetwarzanie i dostęp do bazy.",
      "C": "Backend – zbiory stylów CSS, frontend – kompilowany kod Javy do bytecode."
    },
    "correct": "B",
    "explanation": "Frontend obejmuje UI w przeglądarce, a backend implementuje logikę biznesową i zarządza dostępem do danych na serwerze.",
    "auto_id": 443
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja dotyczy frameworka 'frontendowego' w JavaScript?",
    "definitions": {
      "A": "Zbiór narzędzi do zarządzania bazami danych i transakcjami w Node.js",
      "B": "Rozszerzenie linuksowego kernela pozwalające na niskopoziomową kontrolę wątków",
      "C": "Biblioteka (np. React, Angular) służąca do tworzenia interaktywnego interfejsu w przeglądarce, zarządzania stanem UI i aktualizacji widoków dynamicznie"
    },
    "correct": "C",
    "explanation": "Biblioteki/Frameworki (React, Angular, Vue) stanowią narzędzia JS do budowy UI (frontendu) w modelu komponentowym.",
    "auto_id": 444
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja opisuje architekturę trójwarstwową?",
    "definitions": {
      "A": "Model, w którym UI, logika biznesowa i warstwa danych są odseparowane, co ułatwia utrzymanie i rozwój systemu.",
      "B": "Podejście, w którym łączymy bazę danych z warstwą wizualną w jednym monolicie, bez logiki pośredniej.",
      "C": "Rozwiązanie stricte mobilne, dzielące kod na trzy pliki .java, .xml i .gradle"
    },
    "correct": "A",
    "explanation": "Trójwarstwowa architektura (UI, logika biznesowa, dane) separuje odpowiedzialności i upraszcza skalowanie.",
    "auto_id": 445
  },
  {
    "type": "definition_typeB",
    "question": "Poniżej znajdziesz trzy podobne definicje 'warstwy prezentacji'. Która jest najbardziej precyzyjna?",
    "definitions": {
      "A": "Warstwa odpowiedzialna za mechanizmy transakcyjne i kontrolę spójności w bazie danych.",
      "B": "Warstwa dostarczająca interfejs i logikę prezentacyjną użytkownikowi (np. przeglądarka, UI), bez głębokiej logiki biznesowej.",
      "C": "Moduł, który realizuje procesy integracji z systemami zewnętrznymi i asynchronicznymi kolejkami."
    },
    "correct": "B",
    "explanation": "Warstwa prezentacji zajmuje się wyświetlaniem danych i interakcją z użytkownikiem, delegując złożoną logikę do warstwy biznesowej.",
    "auto_id": 446
  },
  {
    "type": "definition_typeA",
    "question": "Która z definicji wyjaśnia koncepcję 'web scrappingu' w kontekście pozyskiwania danych?",
    "definitions": {
      "A": "Manualne przepisywanie danych z plików PDF do arkusza kalkulacyjnego.",
      "B": "Automatyczne pobieranie i parsowanie zawartości stron WWW celem wydobycia informacji (np. cenników).",
      "C": "Generowanie kluczy obcych w relacyjnej bazie danych bez udziału użytkownika."
    },
    "correct": "B",
    "explanation": "Web scraping polega na automatycznym pobieraniu i analizie kodu HTML stron, by wyodrębnić dane.",
    "auto_id": 447
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja najlepiej opisuje pojęcie 'crowdsourcing danych'?",
    "definitions": {
      "A": "Technika gromadzenia rekordów z logów serwerowych w celu analizy wewnętrznej firmy.",
      "B": "Pozyskiwanie dużych wolumenów danych dzięki współpracy społeczności lub użytkowników końcowych, dzielących się informacjami.",
      "C": "Pobieranie plików XLSX z API publicznego i import do hurtowni danych."
    },
    "correct": "B",
    "explanation": "Crowdsourcing oznacza zaangażowanie wielu osób (społeczności) w dostarczanie i weryfikację danych.",
    "auto_id": 448
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja trafnie opisuje koncepcję CRUD w kontekście aplikacji internetowej?",
    "definitions": {
      "A": "Zbiór czterech podstawowych operacji na danych (Create, Read, Update, Delete), stanowiących fundament typowych aplikacji bazodanowych.",
      "B": "Model obliczeń rozproszonych z podziałem na węzły klastrowe realizujące read i write osobno.",
      "C": "Metoda kompresji danych w plikach logów, wykonywana cyklicznie przez CRON."
    },
    "correct": "A",
    "explanation": "CRUD oznacza najważniejsze operacje na danych: tworzenie, odczyt, aktualizację, usuwanie.",
    "auto_id": 449
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą operacji 'Read' w CRUD. Która z nich jest poprawna?",
    "definitions": {
      "A": "Operacja manipulacji danymi w warstwie prezentacji, zmieniająca wygląd UI bez dostępu do bazy.",
      "B": "Pozyskiwanie danych z bazy (lub innego magazynu) i ich prezentacja użytkownikowi, bez modyfikowania zawartości.",
      "C": "Sprawdzanie uprawnień użytkownika do usunięcia zasobów w systemie, a następnie nadpisywanie wierszy."
    },
    "correct": "B",
    "explanation": "W CRUD „Read” służy wyłącznie do odczytu i wyświetlenia danych, bez ich zmiany.",
    "auto_id": 450
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja opisuje 'testy jednostkowe' (unit tests) w aplikacji internetowej?",
    "definitions": {
      "A": "Sprawdzanie działania całego systemu end-to-end z punktu widzenia użytkownika.",
      "B": "Testowanie izolowanych, najmniejszych możliwych fragmentów kodu (funkcji, metod) w odosobnieniu od reszty aplikacji.",
      "C": "Weryfikowanie współpracy wielu modułów jednocześnie w środowisku produkcyjnym."
    },
    "correct": "B",
    "explanation": "Testy jednostkowe skupiają się na najmniejszych jednostkach kodu, najczęściej pojedynczych funkcjach.",
    "auto_id": 451
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje opisują 'testy regresyjne'. Która jest właściwa?",
    "definitions": {
      "A": "Testy wykonywane tylko wtedy, gdy nastąpiła aktualizacja systemu operacyjnego na serwerze bazy.",
      "B": "Powtórne testowanie kluczowych funkcjonalności po zmianach (poprawkach, nowej funkcji), aby sprawdzić, czy nic innego nie uległo uszkodzeniu.",
      "C": "Pojedynczy zestaw testów manualnych weryfikujący dostęp do warstwy logiki w modelu MVC."
    },
    "correct": "B",
    "explanation": "Testy regresyjne mają upewnić się, że wprowadzone zmiany w kodzie nie spowodowały błędów w już działającej funkcjonalności.",
    "auto_id": 452
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja trafnie opisuje 'bazy NoSQL'?",
    "definitions": {
      "A": "Tradycyjne relacyjne bazy danych oparte na tabelach, kluczach głównych i SQL.",
      "B": "Bazy danych nierelacyjne, często klucz-wartość, kolumnowe, dokumentowe lub grafowe, zaprojektowane do elastycznej struktury i łatwego skalowania.",
      "C": "Tylko pliki tekstowe do przechowywania rekordów JSON bez interfejsu zapytań."
    },
    "correct": "B",
    "explanation": "NoSQL obejmuje różnorodne modele (dokumentowe, kolumnowe, grafowe) charakteryzujące się elastycznym schematem i skalowalnością.",
    "auto_id": 453
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą bazy dokumentowej (np. MongoDB). Która jest poprawna?",
    "definitions": {
      "A": "Baza, w której dane przechowuje się jako pojedyncze wiersze w tabelach o twardym schemacie.",
      "B": "System przechowujący dane w formie dokumentów (np. JSON), o elastycznej strukturze i zapytaniach podobnych do JSON.",
      "C": "Platforma streamingowa do przetwarzania logów w trybie batch."
    },
    "correct": "B",
    "explanation": "Bazy dokumentowe przechowują dane w formie dokumentów (np. JSON), bez sztywnego schematu tabel.",
    "auto_id": 454
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja opisuje 'bazę relacyjną'?",
    "definitions": {
      "A": "System przechowujący dane w postaci kluczy-wartości bez możliwości JOIN-owania.",
      "B": "Model oparty na tabelach z kolumnami, kluczami głównymi i obcymi, wspomagany językiem SQL do zapytań.",
      "C": "Mechanizm z automatycznym replikowaniem danych w klastrze peer-to-peer, bez struktury kolumn."
    },
    "correct": "B",
    "explanation": "Bazy relacyjne używają tabel, kluczy i JOIN-ów, a zapytania formułuje się w języku SQL.",
    "auto_id": 455
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą 'normalizacji' w bazach relacyjnych. Która jest poprawna?",
    "definitions": {
      "A": "Proces upraszczania połączeń sieciowych w warstwie fizycznej z użyciem VLAN.",
      "B": "Redukowanie redundancji danych i unikanie anomalii (aktualizacji, wstawiania, usuwania) poprzez odpowiedni podział tabel i zależności.",
      "C": "Mechanizm tymczasowego przechowywania danych w pamięci podręcznej zapytań, by poprawić wydajność."
    },
    "correct": "B",
    "explanation": "Normalizacja porządkuje schemat bazy, minimalizując duplikację danych oraz problemy z aktualizacjami.",
    "auto_id": 456
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja dotyczy 'zagrożeń w bazach danych'?",
    "definitions": {
      "A": "Wyłącznie błędy w formatowaniu plików CSV podczas importu.",
      "B": "Ryzyka nieautoryzowanego dostępu, ataków typu SQL Injection, utraty integralności lub spójności danych.",
      "C": "Konieczność replikacji odczytu w środowisku testowym bez logów transakcji."
    },
    "correct": "B",
    "explanation": "W kontekście zagrożeń w bazach danych istotne są ataki i problemy bezpieczeństwa, np. SQL Injection, brak autoryzacji, utrata integralności.",
    "auto_id": 457
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja wyjaśnia koncepcję 'SQL Injection'?",
    "definitions": {
      "A": "Wyłącznie formatowanie zapytań w stylu JSON do bazy",
      "B": "Atak wstrzykujący dodatkowe lub złośliwe polecenia SQL poprzez wejścia użytkownika, omijając oczekiwaną logikę aplikacji",
      "C": "Metoda szyfrowania danych przed zapisaniem w rekordach bazy"
    },
    "correct": "B",
    "explanation": "SQL Injection pozwala atakującemu dołączyć do zapytania SQL własny kod, jeśli wejście użytkownika nie jest odpowiednio walidowane.",
    "auto_id": 458
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja trafnie opisuje 'zagrożenia w systemach operacyjnych'?",
    "definitions": {
      "A": "Ryzyka związane z interpretacją stylów CSS i animacji w przeglądarce",
      "B": "Potencjalne luki i ataki (rootkit, exploit, brak aktualizacji), które mogą umożliwić przejęcie kontroli lub uszkodzenie systemu",
      "C": "Przeprowadzanie testów jednostkowych w warstwie UI, ignorując jądro OS"
    },
    "correct": "B",
    "explanation": "Zagrożenia w OS to m.in. exploity, rootkity czy brak aktualizacji bezpieczeństwa.",
    "auto_id": 459
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja opisuje 'rootkit' w kontekście systemów operacyjnych?",
    "definitions": {
      "A": "Zbiór legalnych sterowników do obsługi urządzeń w jądrze systemu Linux",
      "B": "Złośliwe narzędzie ukrywające swoją obecność i procesy, pozwalające atakującemu na utrzymywanie się w systemie z uprawnieniami root",
      "C": "Kompilator jądra do dynamicznych modułów konfiguracyjnych"
    },
    "correct": "B",
    "explanation": "Rootkit służy do ukrywania aktywności w systemie operacyjnym i umożliwia przywileje administratorskie atakującemu.",
    "auto_id": 460
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja obejmuje 'zagrożenia w sieciach komputerowych'?",
    "definitions": {
      "A": "Jedynie brak kabla Ethernet do podłączenia stacji roboczej",
      "B": "Możliwość ataku typu sniffing, DDoS, Man-in-the-Middle, podszycie się pod IP czy MAC, prowadzące do utraty danych lub paraliżu sieci",
      "C": "Dedykowane problemy z wyświetlaniem interfejsu CLI w routerze"
    },
    "correct": "B",
    "explanation": "Zagrożenia w sieci to podsłuchiwanie, ataki odmowy usług, spoofing, MitM itp.",
    "auto_id": 461
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja poprawnie opisuje 'Man-in-the-Middle' (MitM)?",
    "definitions": {
      "A": "Atak polegający na odrzucaniu wszystkich pakietów węzła ofiary",
      "B": "Podsłuchiwanie i potencjalna modyfikacja komunikacji między dwoma stronami przez ukrytego pośrednika",
      "C": "Inicjalizacja jedynie połączeń DHCP w trybie offline"
    },
    "correct": "B",
    "explanation": "MitM to wstrzykiwanie się atakującego w ścieżkę komunikacji, by przechwytywać i ewentualnie zmieniać przesyłane dane.",
    "auto_id": 462
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej opisuje 'model TCP/IP'?",
    "definitions": {
      "A": "Siedmiowarstwowy model OSI, skupiający się na warstwach aplikacji i łącza danych",
      "B": "Czterowarstwowy model komunikacji sieciowej: warstwa dostępu do sieci, internetowa, transportowa i aplikacji",
      "C": "Zestaw protokołów graficznych do prezentacji UI w chmurze"
    },
    "correct": "B",
    "explanation": "Model TCP/IP to prostszy, czterowarstwowy model (dostęp, internet, transport, aplikacja), będący bazą komunikacji w Internecie.",
    "auto_id": 463
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja oddaje istotę 'warstwy transportowej' w modelu TCP/IP?",
    "definitions": {
      "A": "Warstwa odpowiedzialna za adresację i routowanie pakietów IP",
      "B": "Warstwa zapewniająca niezawodny (TCP) lub bezpołączeniowy (UDP) transport danych między hostami, zarządza portami i kolejnością pakietów",
      "C": "Mechanizm szyfrowania wszystkich pakietów przychodzących do routera"
    },
    "correct": "B",
    "explanation": "Warstwa transportowa to TCP/UDP – zarządzanie portami, niezawodnością i kolejnością danych.",
    "auto_id": 464
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja opisuje 'diagram ERD' (Entity-Relationship Diagram)?",
    "definitions": {
      "A": "Schemat reprezentujący algorytmy kodowania w jawnym formacie JSON",
      "B": "Graficzne przedstawienie encji (tabel), ich atrybutów i relacji (połączeń) w projektowaniu baz danych",
      "C": "Zbiór wzorców projektowych do warstwy serwisu"
    },
    "correct": "B",
    "explanation": "ERD pokazuje, jak encje łączą się ze sobą w bazach danych, uwzględniając ich atrybuty i relacje.",
    "auto_id": 465
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje opisują 'relację wiele-do-wielu (N:M)' w ERD. Która jest poprawna?",
    "definitions": {
      "A": "Związek, w którym każdej encji A może odpowiadać co najwyżej jedna encja B",
      "B": "Relacja, w której jeden rekord w A może łączyć się z wieloma rekordami w B, a jeden rekord w B może łączyć się z wieloma rekordami w A",
      "C": "Sposób jednorazowego kopiowania wartości kluczy głównych do plików CSV"
    },
    "correct": "B",
    "explanation": "Relacja N:M oznacza, że encja z jednej strony może być powiązana z wieloma rekordami w drugiej tabeli i odwrotnie.",
    "auto_id": 466
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej tłumaczy 'wymagania funkcjonalne' w aplikacjach internetowych?",
    "definitions": {
      "A": "Wymagania dotyczące szybkości odpowiedzi, wydajności i dostępności systemu",
      "B": "Wymagania określające konkretne działania, jakie użytkownicy mogą wykonać w systemie (np. rejestracja, logowanie, wyszukiwanie)",
      "C": "Wymagania budżetowe i marketingowe, decydujące o opłacalności projektu"
    },
    "correct": "B",
    "explanation": "Wymagania funkcjonalne opisują, co system ma robić: funkcjonalności, zadania, reakcje na działania użytkowników.",
    "auto_id": 467
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje odnoszą się do 'wymagań niefunkcjonalnych'. Która jest właściwa?",
    "definitions": {
      "A": "Wymagania mówiące o cechach jakościowych systemu, takich jak wydajność, bezpieczeństwo, skalowalność, ale nie definiujące konkretnej funkcji.",
      "B": "Lista operacji CRUD, które system ma wspierać w modelu danych.",
      "C": "Zbiór reguł budżetowych i sprawozdań księgowych, powiązanych z przepływami finansowymi."
    },
    "correct": "A",
    "explanation": "Wymagania niefunkcjonalne odnoszą się do atrybutów jakości: np. performance, security, reliability, usability itp.",
    "auto_id": 468
  },
  {
    "type": "definition_typeA",
    "question": "Która z poniższych definicji najtrafniej opisuje 'metadane w uczeniu nadzorowanym'?",
    "definitions": {
      "A": "Dodatkowe informacje o zestawie danych (np. opis cech, pochodzenie), które nie wchodzą do modelu, ale są kluczowe przy interpretacji wyników.",
      "B": "Dane służące bezpośrednio do trenowania modelu i weryfikacji jego jakości (np. etykiety i cechy).",
      "C": "Zbiór parametrów hiperbolicznych modelu, inicjowanych przed procesem backpropagation."
    },
    "correct": "A",
    "explanation": "Metadane mogą zawierać kontekst dotyczący źródła, formatu czy znaczenia cech, co jest kluczowe w procesie uczenia.",
    "auto_id": 469
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą 'walidacji krzyżowej' (cross-validation). Która wyczerpująco wyjaśnia tę technikę w uczeniu nadzorowanym?",
    "definitions": {
      "A": "Metoda sprawdzania wpływu rekurencyjnego dziedziczenia w klastrze HPC.",
      "B": "Sposób oceny modelu przez wielokrotne dzielenie danych na zbiór treningowy i testowy w różnych podziałach, by uzyskać bardziej wiarygodną miarę jakości.",
      "C": "Proces równoległego trenowania modelu na wszystkich dostępnych danych, bez wydzielania zestawu weryfikacyjnego."
    },
    "correct": "B",
    "explanation": "Cross-validation rozkłada dane na wiele par trening/test, co uśrednia wyniki i zapewnia solidną ocenę zdolności generalizacji modelu.",
    "auto_id": 470
  },
  {
    "type": "definition_typeA",
    "question": "Która z poniższych definicji precyzyjnie dotyczy 'warstwy normalizacyjnej' (batch normalization) w głębokich sieciach neuronowych?",
    "definitions": {
      "A": "Warstwa odpowiedzialna za ograniczenie przepływu gradientu przez węzły konwolucyjne w CNN.",
      "B": "Mechanizm normalizowania rozkładu aktywacji w danej warstwie w trakcie treningu, co stabilizuje i przyspiesza uczenie.",
      "C": "Zestaw funkcji aktywacji (sigmoid, tanh, ReLU) stosowanych naprzemiennie w każdej warstwie."
    },
    "correct": "B",
    "explanation": "Batch normalization reguluje rozkład aktywacji (średnią i wariancję) w mini-batchu, stabilizując przepływ gradientu.",
    "auto_id": 471
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje opisują 'transfer learning' w kontekście głębokiego uczenia. Która jest poprawna?",
    "definitions": {
      "A": "Przełączanie się z jednej optymalizacji (np. Adam) na inną (np. RMSProp) bez zmiany architektury sieci.",
      "B": "Wykorzystanie sieci wytrenowanej na dużym zestawie danych do przyspieszenia trenowania na innej, często mniejszej dziedzinie.",
      "C": "Proces odwrotnego splotu sygnałów w warstwach poolingowych."
    },
    "correct": "B",
    "explanation": "Transfer learning polega na ponownym użyciu już wytrenowanego modelu (lub jego fragmentów) w nowym zadaniu, co znacznie przyspiesza i ulepsza proces uczenia.",
    "auto_id": 472
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja opisuje 'mutację' w algorytmach genetycznych?",
    "definitions": {
      "A": "Wybieranie najlepszych osobników z populacji i krzyżowanie ich cech.",
      "B": "Losowe, niewielkie modyfikacje genotypu (reprezentacji rozwiązania), wprowadzane w celu uniknięcia lokalnych minimów i zwiększenia różnorodności.",
      "C": "Usunięcie z populacji osobników o najwyższej funkcji przystosowania."
    },
    "correct": "B",
    "explanation": "Mutacja to losowe zmiany w strukturze rozwiązania, pozwalające eksplorować nowe obszary przestrzeni.",
    "auto_id": 473
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja najlepiej wyjaśnia pojęcie 'fenotyp' w kontekście algorytmów genetycznych?",
    "definitions": {
      "A": "Kod genetyczny rozwiązania w postaci surowej tablicy bitów, przechowywany w pamięci VRAM.",
      "B": "Widzialna reprezentacja rozwiązania — czyli to, jak genotyp (kod) jest interpretowany jako realne parametry problemu.",
      "C": "Parametr decydujący o częstotliwości mutacji w kolejnych pokoleniach."
    },
    "correct": "B",
    "explanation": "Fenotyp to realna interpretacja genotypu — np. gdy ciąg bitów oznacza parametry rozwiązania w przestrzeni rzeczywistej.",
    "auto_id": 474
  },
  {
    "type": "definition_typeA",
    "question": "Która z definicji precyzyjnie oddaje sens 'skalowania poziomego' (horizontal scaling) w systemach rozproszonych?",
    "definitions": {
      "A": "Dodawanie kolejnych instancji (serwerów, węzłów) do systemu w celu zwiększenia wydajności i przepustowości.",
      "B": "Rozbudowa pojedynczego serwera o większą ilość RAM, CPU, dysków SSD.",
      "C": "Migracja danych z bazy relacyjnej do plików CSV w folderze współdzielonym."
    },
    "correct": "A",
    "explanation": "Skalowanie poziome polega na powiększaniu systemu o kolejne węzły, w przeciwieństwie do rozbudowy jednego serwera (skalowania pionowego).",
    "auto_id": 475
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja dotyczy 'konsensusu' w środowisku rozproszonym (np. protokoły Paxos, Raft)?",
    "definitions": {
      "A": "Metoda opisująca jednorazowy backup danych na jednym węźle przed migracją",
      "B": "Sposób osiągnięcia zgody co do wartości lub stanu w systemie, mimo potencjalnych awarii lub opóźnień, tak by wszystkie węzły ustaliły spójny stan",
      "C": "Algorytm porządkujący kolejność pakietów w warstwie transportowej w TCP"
    },
    "correct": "B",
    "explanation": "Konsensus pozwala węzłom w systemie rozproszonym osiągnąć wspólne ustalenie stanu nawet przy zawodności niektórych węzłów.",
    "auto_id": 476
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej oddaje cel 'synchronizacji wątków' w programowaniu współbieżnym?",
    "definitions": {
      "A": "Umożliwienie wykonywania kilku operacji równolegle bez dbałości o spójność danych.",
      "B": "Koordynacja dostępu do zasobów (danych) przez wiele wątków, tak by uniknąć race condition i zapewnić poprawność działania.",
      "C": "Generowanie pseudolosowych numerów identyfikujących wątki w procesie"
    },
    "correct": "B",
    "explanation": "Synchronizacja zapobiega konfliktom przy współdzielonych zasobach i pozwala na bezpieczne równoległe przetwarzanie.",
    "auto_id": 477
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje nawiązują do 'semafora' w kontekście współbieżności. Która jest poprawna?",
    "definitions": {
      "A": "Zmienna całkowita pozwalająca zablokować dostęp pewnej liczbie wątków, w oparciu o dekrement i inkrement, służąca do zarządzania liczbą jednoczesnych wejść do sekcji krytycznej.",
      "B": "Metoda uspójniania duplikatów danych w systemie rozproszonym w warstwie replikacji",
      "C": "Mechanizm priorytetyzacji procesów w planowaniu Round Robin"
    },
    "correct": "A",
    "explanation": "Semafor to licznik ograniczający liczbę wątków w sekcji krytycznej (w przypadku semaforów ogólnych), bądź 1 w wypadku semafora binarnego.",
    "auto_id": 478
  },
  {
    "type": "definition_typeA",
    "question": "Która z definicji precyzuje 'backpropagation' w sieciach neuronowych (np. rekurencyjnych)?",
    "definitions": {
      "A": "Algorytm aktualizacji wag sieci na podstawie gradientu błędu, obliczanego od warstwy wyjściowej do warstw wcześniejszych.",
      "B": "Metoda do budowania drzew decyzyjnych w stylu C4.5.",
      "C": "Losowa propagacja sygnału wejściowego do wszystkich neuronów w równym stopniu."
    },
    "correct": "A",
    "explanation": "Backpropagation propaguje błąd wstecz przez warstwy sieci, umożliwiając dostosowanie wag w trakcie uczenia.",
    "auto_id": 479
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe trzy definicje mówią o 'funkcji aktywacji' w sieciach neuronowych. Która odnosi się do ReLU (Rectified Linear Unit)?",
    "definitions": {
      "A": "nieliniowa funkcja f(x) = tanh(x) — ograniczająca wartości do przedziału [-1, 1].",
      "B": "f(x) = max(0, x), wyzerowująca wartości ujemne, a dodatnie przepuszczająca liniowo.",
      "C": "funkcja modelująca rozkład prawdopodobieństwa, sumująca się do 1 w warstwie wyjściowej."
    },
    "correct": "B",
    "explanation": "ReLU to max(0, x), która obcina wartości poniżej zera, upraszczając obliczenia i eliminując problem zanikania gradientu do pewnego stopnia.",
    "auto_id": 480
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja w pełni oddaje 'wymaganie biznesowe' w procesie projektowania systemu informatycznego?",
    "definitions": {
      "A": "Parametr testowy sprawdzany tylko w warstwie QA, dotyczący ilości testów jednostkowych.",
      "B": "Opis celu biznesowego lub funkcjonalności, który system ma zapewnić, np. „system ma umożliwiać automatyczne fakturowanie klientów co miesiąc”.",
      "C": "Polityka rejestracji użytkowników oparta na limicie znaków w haśle i składni SQL."
    },
    "correct": "B",
    "explanation": "Wymagania biznesowe wyrażają potrzeby firmy (lub klienta) dotyczące funkcji i rezultatów, jakie system ma dostarczać.",
    "auto_id": 481
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja opisuje 'dokumentację SRS (Software Requirements Specification)'?",
    "definitions": {
      "A": "Zbiór automatycznie wygenerowanych logów serwera, przechowywanych w formacie binarnym.",
      "B": "Formalny dokument zawierający szczegółowy opis wymagań systemu (funkcjonalnych i niefunkcjonalnych), często używany jako podstawa kontraktu.",
      "C": "Tabelaryczny spis ról użytkowników i ich haseł w plikach konfiguracyjnych aplikacji."
    },
    "correct": "B",
    "explanation": "SRS zwykle stanowi najważniejszą, sformalizowaną dokumentację opisującą, co system ma robić i w jakich warunkach.",
    "auto_id": 482
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej opisuje 'diagram sekwencji' w UML?",
    "definitions": {
      "A": "Diagram przedstawiający powiązania między klasami i relacjami dziedziczenia.",
      "B": "Diagram ukazujący w porządku czasowym wymianę komunikatów i interakcje między obiektami (liniach życia).",
      "C": "Schemat blokowy pokazujący logiczny przepływ sterowania i decyzyjne rozgałęzienia w procesie."
    },
    "correct": "B",
    "explanation": "Diagram sekwencji ilustruje wymianę komunikatów między obiektami wraz z upływem czasu.",
    "auto_id": 483
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja najtrafniej określa 'przypadek użycia' (use case) w UML?",
    "definitions": {
      "A": "Dokładna specyfikacja wewnętrznego przepływu metody w klasie bazowej.",
      "B": "Opis interakcji aktora z systemem w celu osiągnięcia określonego rezultatu (funkcjonalności), często zwizualizowany w diagramie przypadków użycia.",
      "C": "Reprezentacja hierarchii klas i ich wzajemnego dziedziczenia wraz z polimorfizmem."
    },
    "correct": "B",
    "explanation": "Use case opisuje, jak aktor wchodzi w interakcję z systemem, by zrealizować konkretny scenariusz funkcjonalny.",
    "auto_id": 484
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja odnosi się bezpośrednio do 'harmonogramu ETL' w gromadzeniu i eksploracji danych?",
    "definitions": {
      "A": "Plan regularnego uruchamiania procesu Extract-Transform-Load o określonych porach (np. co noc), by odświeżać hurtownię danych.",
      "B": "Algorytm redukcji wymiaru cech w uczeniu maszynowym do minimalizacji overfittingu.",
      "C": "Sposób szeregowania zadań analitycznych w pamięci GPU w czasie rzeczywistym."
    },
    "correct": "A",
    "explanation": "Harmonogram ETL określa, kiedy i jak często automatycznie uruchamiane są zadania pobierania, przetwarzania i ładowania danych.",
    "auto_id": 485
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja opisuje 'profilowanie danych' (data profiling) w kontekście eksploracji?",
    "definitions": {
      "A": "Proces oceny struktury, jakości i zawartości danych (np. rozkład wartości, braków), by wychwycić anomalia i niezgodności przed modelowaniem.",
      "B": "Tworzenie hurtowni danych w klastrze Hadoop do testowania odporności na awarie.",
      "C": "Wyłączne generowanie losowych wartości w celu zapełnienia zbioru treningowego do testów."
    },
    "correct": "A",
    "explanation": "Data profiling to analiza danych pod kątem ich jakości, formatu i rozkładów, co jest ważne w początkowej fazie eksploracji.",
    "auto_id": 486
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej oddaje sens 'hurtowni danych' w kontekście Big Data i BI?",
    "definitions": {
      "A": "System rejestrujący wyłącznie transakcje bieżące w modelu OLTP z minimalną liczbą tabel.",
      "B": "Zcentralizowany magazyn danych historycznych z różnych źródeł, zorganizowany pod kątem analizy i raportowania (OLAP).",
      "C": "Pojedynczy plik CSV z historią logów z serwera."
    },
    "correct": "B",
    "explanation": "Hurtownia danych (data warehouse) to zintegrowany, tematyczny magazyn danych do analiz, zwykle w modelu OLAP.",
    "auto_id": 487
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje opisują 'MapReduce' w ekosystemie Big Data. Która jest poprawna?",
    "definitions": {
      "A": "Operacja łączenia rekordów z dwóch tabel w relacyjnym modelu, prowadzona lokalnie na serwerze.",
      "B": "Paradygmat przetwarzania rozproszonego polegający na fazie map (przetwarzanie danych w węzłach) i fazie reduce (agregacja wyników) w klastrze.",
      "C": "Proces pobierania danych offline z pliku CSV i kompresowania do formatu binaryzowanego RLE."
    },
    "correct": "B",
    "explanation": "MapReduce to model dzielący zadanie na map (lokalne przetworzenie) i reduce (podsumowanie/ agregacja) w rozproszonym środowisku.",
    "auto_id": 488
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najtrafniej opisuje kluczowe zagadnienie „komunikacja aplikacji mobilnej z bazą poprzez backend”?",
    "definitions": {
      "A": "Zestaw praktyk programistycznych w architekturze monolitycznej, koncentrujący się na przesyłaniu plików konfiguracyjnych.",
      "B": "Udostępnienie przez warstwę serwerową (API) mechanizmów odbierania żądań od aplikacji mobilnej i wykonywania operacji na bazie (czytanie, zapisywanie danych), z ewentualnym szyfrowaniem i autoryzacją.",
      "C": "Schemat bezpośredniego łączenia aplikacji mobilnej z bazą MySQL, omijający wszelkie serwisy pośredniczące i wykorzystywanie protokołu SFTP."
    },
    "correct": "B",
    "explanation": "Typowo aplikacja mobilna komunikuje się z bazą przez backend (REST/GraphQL), zapewniając logikę, autoryzację i manipulacje danymi.",
    "auto_id": 489
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą tzw. „endpointów API” w architekturze mobilne-app ↔ server. Która jest poprawna?",
    "definitions": {
      "A": "Endpointy to wyłącznie nazwy kolumn w tabeli bazy danych, zarządzane przez kontroler routera sieciowego.",
      "B": "Zdefiniowane adresy URL (np. /api/v1/users), które przyjmują żądania (GET, POST, PUT, DELETE), przetwarzają logikę i zwracają dane do aplikacji klienta.",
      "C": "Mechanizm łączenia pakietów CSS w pliki stylów w warstwie frontendu."
    },
    "correct": "B",
    "explanation": "Endpoint w REST API to konkretny URL, gdzie aplikacja kliencka może wysłać żądanie, a serwer wykona odpowiednie akcje.",
    "auto_id": 490
  },
  {
    "type": "definition_typeA",
    "question": "Która z definicji pasuje do koncepcji 'klucza głównego złożonego' (Composite Primary Key)?",
    "definitions": {
      "A": "Pojedyncza kolumna auto_increment, która unikalnie identyfikuje wiersz w tabeli.",
      "B": "Zestaw dwóch lub więcej kolumn, których kombinacja musi być unikalna w tabeli i służy jako PRIMARY KEY.",
      "C": "Klucz obcy wskazujący na wiele innych tabel jednocześnie."
    },
    "correct": "B",
    "explanation": "Klucz główny złożony składa się z kilku kolumn, razem gwarantujących unikalną identyfikację rekordu.",
    "auto_id": 491
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą 'restrykcji ON DELETE RESTRICT' w kluczu obcym. Która jest poprawna?",
    "definitions": {
      "A": "Jeśli spróbujemy usunąć rekord w tabeli nadrzędnej, a istnieją powiązane rekordy w tabeli podrzędnej, operacja usunięcia zostanie zablokowana.",
      "B": "Zawsze usuwa powiązane rekordy w tabeli potomnej podczas kasowania rekordu nadrzędnego.",
      "C": "Modyfikuje w tabeli podrzędnej klucz obcy na wartości NULL zamiast usunięcia rekordów."
    },
    "correct": "A",
    "explanation": "ON DELETE RESTRICT nie pozwala na usunięcie rekordu w tabeli nadrzędnej, jeśli są powiązane rekordy podrzędne.",
    "auto_id": 492
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja wyjaśnia „NATURAL JOIN” w SQL?",
    "definitions": {
      "A": "JOIN, który łączy tabele wyłącznie na podstawie jawnie zdefiniowanego klucza obcego w klauzuli ON.",
      "B": "JOIN automatycznie dobierający kolumny do porównania według identycznych nazw, co może być ryzykowne przy niechcianych dopasowaniach.",
      "C": "JOIN tworzący wirtualną tabelę tymczasową, zawsze bez warunku dopasowania rekordów."
    },
    "correct": "B",
    "explanation": "NATURAL JOIN używa nazw kolumn, które się pokrywają w obu tabelach; brak jawnej klauzuli ON czyni go potencjalnie niebezpiecznym.",
    "auto_id": 493
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje opisują 'USING' w zapytaniach SQL. Która jest najbardziej trafna?",
    "definitions": {
      "A": "Klauzula w stylu FULL JOIN do wykrywania zduplikowanych wierszy w jednej tabeli.",
      "B": "Sposób definiowania kolumn, które mają tę samą nazwę w obu tabelach do łączenia (ułatwienie w JOIN), np. JOIN ... USING (kolumna).",
      "C": "Mechanizm łączenia tablic w pamięci podręcznej procesora, obecny tylko w MySQL 8.0."
    },
    "correct": "B",
    "explanation": "Klauzula USING upraszcza warunek ON, jeśli kolumny do łączenia mają identyczną nazwę w obu tabelach.",
    "auto_id": 494
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja tłumaczy 'flexbox' w kontekście responsywnego webdesignu?",
    "definitions": {
      "A": "Metoda testowania szybkości ładowania stron w przeglądarkach mobilnych.",
      "B": "Moduł CSS umożliwiający elastyczne rozmieszczanie elementów w osi głównej i pomocniczej, wspierający responsywne układy.",
      "C": "Specjalny kompilator Sass do konwersji stylów w oparciu o breakpoints."
    },
    "correct": "B",
    "explanation": "Flexbox to layout w CSS, który pozwala na elastyczne ustawianie elementów w wierszach lub kolumnach, przydatne w responsywnych projektach.",
    "auto_id": 495
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje nawiązują do 'grid layout' w CSS. Która jest prawidłowa?",
    "definitions": {
      "A": "Mechanizm siatki pozwalający na podział obszaru strony w wiersze i kolumny, z możliwością definiowania obszarów i dopasowywania do różnych rozdzielczości.",
      "B": "Funkcja polimorficzna C++ do dynamicznego dziedziczenia stylów",
      "C": "Format pliku rasterowanego do obsługi obrazów w CSS"
    },
    "correct": "A",
    "explanation": "CSS Grid Layout to system wierszy i kolumn, który znacznie upraszcza tworzenie złożonych, responsywnych układów.",
    "auto_id": 496
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja wyjaśnia pojęcie 'kontekstu procesu' (process context)?",
    "definitions": {
      "A": "Zestaw stylów CSS zdefiniowanych w warstwie frontendu w przeglądarce",
      "B": "Zbiór informacji potrzebnych do przywrócenia procesu do stanu wykonywania (m.in. rejestry CPU, wskaźnik stosu, licznik rozkazów, informacje o pamięci).",
      "C": "Konfiguracja shell w systemie Linux dotycząca aliasów i zmiennych środowiskowych"
    },
    "correct": "B",
    "explanation": "Kontekst procesu zawiera stan potrzebny do kontynuowania wykonania procesu po przełączeniu z innego procesu.",
    "auto_id": 497
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje odnoszą się do 'priorytetu procesu' w systemach operacyjnych. Która jest właściwa?",
    "definitions": {
      "A": "Wartość, która decyduje, czy proces jest w stanie Running czy Terminated po starcie.",
      "B": "Parametr pozwalający planiscie CPU przyznać większą lub mniejszą szansę na CPU, np. proces z wysokim priorytetem dostaje CPU częściej lub wcześniej.",
      "C": "Funkcja jądra określająca minimalny czas do wygaśnięcia licencji systemu operacyjnego."
    },
    "correct": "B",
    "explanation": "Priorytet procesu mówi planiscie, który proces powinien być obsługiwany najpierw lub częściej.",
    "auto_id": 498
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja obejmuje 'grupę użytkowników' (user group) w systemie operacyjnym?",
    "definitions": {
      "A": "Pojedynczy plik binarny zawierający hasła wszystkich użytkowników.",
      "B": "Logiczne zgrupowanie kont użytkowników, które można obdarzać zestawem wspólnych uprawnień do zasobów (plików, katalogów).",
      "C": "Mechanizm replikacji uprawnień z innego systemu operacyjnego w warstwie sieci."
    },
    "correct": "B",
    "explanation": "Grupa to zbiór kont użytkowników, który upraszcza zarządzanie uprawnieniami do zasobów wspólnych.",
    "auto_id": 499
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje traktują o 'politykach haseł' w systemach operacyjnych. Która jest słuszna?",
    "definitions": {
      "A": "Zbiór reguł (min. długość, złożoność, czas ważności) wymuszających odpowiednie standardy bezpieczeństwa podczas tworzenia i zmiany hasła.",
      "B": "Metoda automatycznej rotacji kluczy publicznych w SSH co 10 sekund.",
      "C": "Mechanizm archiwizacji plików konfiguracyjnych w trybie read-only."
    },
    "correct": "A",
    "explanation": "Polityka haseł określa wymogi co do skomplikowania, długości i okresu ważności hasła w systemie.",
    "auto_id": 500
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej oddaje istotę 'autentykacji w sieciach bezprzewodowych' (np. WPA2-PSK)?",
    "definitions": {
      "A": "Konieczność logowania się do systemu operacyjnego routera za każdym razem, gdy włączamy komputer",
      "B": "Proces sprawdzenia hasła sieci w urządzeniu klienckim (klucz PSK) przed umożliwieniem połączenia z siecią Wi-Fi",
      "C": "Synonim bezpiecznego tunelowania w protokole SSHv2"
    },
    "correct": "B",
    "explanation": "W WPA2-PSK klient musi dostarczyć klucz wstępny (PSK), który router porównuje z przechowywanym hasłem.",
    "auto_id": 501
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja trafnie opisuje 'handshake' w sieciach Wi-Fi (WPA2)?",
    "definitions": {
      "A": "Operację formatującą twardy dysk routera przy starcie systemu",
      "B": "Proces wymiany kluczy pomiędzy klientem a punktem dostępowym w celu ustanowienia szyfrowanego połączenia",
      "C": "Metodę ustalania priorytetów w protokole RIP"
    },
    "correct": "B",
    "explanation": "Handshake WPA2 to procedura, w której klient i AP ustalają wspólne klucze do zabezpieczania ruchu.",
    "auto_id": 502
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najtrafniej wyjaśnia 'serwer aplikacji' w architekturze frontend-backend?",
    "definitions": {
      "A": "Oprogramowanie, które zawiera wyłącznie pliki .html i .css do serwowania stronom statycznym, bez logiki dynamicznej.",
      "B": "Środowisko uruchomieniowe (np. Node.js, Tomcat, Django), obsługujące żądania klientów, wykonujące logikę i komunikujące się z bazą danych.",
      "C": "Interfejs użytkownika w formie aplikacji desktopowej, przesyłany do przeglądarki w formie surowych obrazów .png."
    },
    "correct": "B",
    "explanation": "Serwer aplikacji (backend) implementuje reguły biznesowe, przetwarza żądania i łączy się z bazą.",
    "auto_id": 503
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą 'SPA' (Single Page Application). Która jest poprawna?",
    "definitions": {
      "A": "Model, w którym cała logika i kod serwera jest spakowany w jednym pliku .exe.",
      "B": "Struktura strony internetowej, która przeładowuje się w całości przy każdej nawigacji do nowego zasobu.",
      "C": "Aplikacja webowa, która ładuje jedną stronę HTML i dynamicznie aktualizuje jej zawartość po stronie klienta (np. React, Vue), minimalizując pełne przeładowania."
    },
    "correct": "C",
    "explanation": "SPA używa dynamicznego odświeżania fragmentów UI, unikając przeładowywania całej strony i polega na intensywnym JavaScript.",
    "auto_id": 504
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja właściwie oddaje znaczenie 'warstwy danych' w architekturze trójwarstwowej?",
    "definitions": {
      "A": "Moduł UI zarządzający stylami i animacjami w CSS",
      "B": "Składowisko (np. baza danych, repozytoria) i mechanizmy dostępu, w których są przechowywane i pobierane informacje niezbędne aplikacji",
      "C": "Moduł służący do weryfikacji spójności kodu CSS z HTML"
    },
    "correct": "B",
    "explanation": "Warstwa danych to fizyczne i logiczne miejsce przechowywania informacji, np. RDBMS, NoSQL.",
    "auto_id": 505
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje odnoszą się do „warstwy logiki biznesowej” (Business Logic Layer). Która jest najbardziej wyczerpująca?",
    "definitions": {
      "A": "Zbiór styli CSS, które koncentrują się na atrakcyjnej prezentacji komponentów UI",
      "B": "Warstwa pośrednicząca między UI a bazą danych, gdzie kod realizuje reguły biznesowe, walidacje, przepływ procesów, zapewniając spójność i bezpieczeństwo transakcji",
      "C": "Serwer plików, który przechowuje obrazy w formacie .svg"
    },
    "correct": "B",
    "explanation": "Logika biznesowa to serce aplikacji, gdzie zachodzą operacje i decyzje biznesowe, a nie tylko prezentacja czy persystencja.",
    "auto_id": 506
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja wyjaśnia 'ankietę online' jako metodę pozyskiwania danych?",
    "definitions": {
      "A": "Proces automatycznego skanowania kodu HTML i metadanych stron internetowych w trybie headless.",
      "B": "Zbiór pytań zadawanych użytkownikom przez formularz w Internecie, którego wypełnienie stanowi aktywne przekazanie informacji (opinii, faktów) do bazy danych.",
      "C": "Ciągłe monitorowanie stanu procesów w systemie operacyjnym na serwerze aplikacyjnym."
    },
    "correct": "B",
    "explanation": "Ankiety online polegają na tym, że użytkownicy sami wprowadzają dane w formie odpowiedzi, co pozwala je gromadzić w bazie.",
    "auto_id": 507
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja najlepiej ujmuje 'logi serwera' jako źródło danych w procesie gromadzenia?",
    "definitions": {
      "A": "Wynik testów automatycznych, który nie ma żadnych informacji o realnym użyciu systemu.",
      "B": "Rejestr zdarzeń (żądań, odpowiedzi, błędów, zachowań użytkowników) zapisywany przez serwer w celu diagnostyki i analizy, często wykorzystywany do wyciągania wniosków o ruchu czy problemach w systemie.",
      "C": "Losowo generowane pakiety danych stosowane w uczeniu maszynowym do augmentacji zbioru."
    },
    "correct": "B",
    "explanation": "Logi serwera przechowują chronologiczną historię zdarzeń i stanowią cenne źródło danych do analizy wydajności, bezpieczeństwa czy trendów.",
    "auto_id": 508
  },
  {
    "type": "definition_typeA",
    "question": "Która z poniższych definicji najtrafniej opisuje 'walidację hiperparametrów' w kontekście uczenia nadzorowanego?",
    "definitions": {
      "A": "Proces generowania macierzy pomyłek dla każdego wytrenowanego modelu, bez wpływu na parametry inicjalne.",
      "B": "Dobór i ocena wartości parametrów sterujących uczeniem (np. współczynnik uczenia, rozmiar drzewa) przy użyciu metod takich jak siatka (grid search) lub optymalizacja bayesowska.",
      "C": "Wyłączne wprowadzanie szumu do cech w celu zapobiegania zbieżności modelu."
    },
    "correct": "B",
    "explanation": "Walidacja hiperparametrów polega na systematycznym sprawdzaniu różnych konfiguracji parametrów, by odnaleźć optymalne ustawienia dla modelu.",
    "auto_id": 509
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą 'regresji' w uczeniu nadzorowanym. Która jest właściwa i kompletna?",
    "definitions": {
      "A": "Metoda klasyfikacji binarnej, dzieląca dane na dwie kategorie w oparciu o perceptron liniowy.",
      "B": "Zadanie przewidywania ciągłej zmiennej wyjściowej (np. cen, temperatur, trendów), na podstawie zestawu cech wejściowych.",
      "C": "Technika grupowania danych bez etykiet, wykorzystywana do redukcji wymiaru w bazie."
    },
    "correct": "B",
    "explanation": "Regresja to przewidywanie wartości liczbowych (np. realnych), w przeciwieństwie do klasyfikacji (kategorie).",
    "auto_id": 510
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja oddaje sens 'fine-tuning' w głębokich sieciach neuronowych?",
    "definitions": {
      "A": "Zawsze trenowanie sieci od zera na obszernym zestawie danych, bez wcześniejszego modelu.",
      "B": "Dostosowanie już wytrenowanego modelu (np. z transfer learning) do nowego zadania, często z mniejszym zbiorem treningowym, zmieniając wagi wyższych warstw.",
      "C": "Równoległe zredukowanie liczby warstw w celu uzyskania lepszej interpretowalności."
    },
    "correct": "B",
    "explanation": "Fine-tuning polega na wzięciu modelu nauczonego na dużym zbiorze i dopasowaniu go do bardziej szczegółowych lub nowych danych.",
    "auto_id": 511
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą 'funkcji aktywacji Softmax' w głębokim uczeniu. Która jest prawidłowa?",
    "definitions": {
      "A": "Funkcja liniowa, która wyjście neuronu ogranicza do wartości nieujemnych, max(0, x).",
      "B": "Funkcja przekształcająca wektor logitów w rozkład prawdopodobieństwa, gdzie suma wszystkich wyjść równa się 1.",
      "C": "Mechanizm regulacji zanikania gradientu w rekurencyjnych warstwach LSTM."
    },
    "correct": "B",
    "explanation": "Softmax przekształca logity (wyjścia liniowe) w wartości z przedziału (0,1), których suma wynosi 1, interpretowane jako prawdopodobieństwa klas.",
    "auto_id": 512
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej tłumaczy 'selekcję elity' (elitism) w algorytmach genetycznych?",
    "definitions": {
      "A": "Usuwanie wszystkich najlepszych osobników, by dać szansę słabszym na rozwój.",
      "B": "Zachowanie pewnej liczby najlepszych osobników z każdej generacji bez zmian, by zagwarantować, że dobre rozwiązania nie zostaną utracone.",
      "C": "Wyłączne mutowanie osobników o najwyższym fitness."
    },
    "correct": "B",
    "explanation": "W elitism niewielki odsetek najlepszych osobników jest kopiowany do następnej populacji bez modyfikacji.",
    "auto_id": 513
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą 'reprezentacji chromosomu' w algorytmach genetycznych. Która jest najbardziej kompletna?",
    "definitions": {
      "A": "Zbiór losowo wygenerowanych współczynników w modelu sieci neuronowej, zawsze przechowywany w formacie CSV.",
      "B": "Sposób kodowania rozwiązania problemu (np. ciąg bitów, liczb całkowitych, wartości rzeczywistych), który algorytm genetyczny modyfikuje poprzez krzyżowanie i mutację.",
      "C": "Procedura bezpośredniego opisu stanu bazy danych w trakcie replikacji."
    },
    "correct": "B",
    "explanation": "Chromosom to sposób, w jaki dany algorytm genetyczny wewnętrznie reprezentuje pojedyncze rozwiązanie w populacji.",
    "auto_id": 514
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najlepiej charakteryzuje koncepcję 'rozproszonego systemu plików' w systemach rozproszonych?",
    "definitions": {
      "A": "Standardowa funkcjonalność pliku swap w pojedynczym systemie Linux, niewidoczna dla innych węzłów.",
      "B": "System plików, w którym dane są podzielone i przechowywane na wielu serwerach/węzłach, a użytkownik widzi go jako jedną logiczną przestrzeń.",
      "C": "Skrypt automatyzujący instalację baz danych w chmurze prywatnej."
    },
    "correct": "B",
    "explanation": "W rozproszonym systemie plików dane są dystrybuowane między węzłami, ale użytkownik widzi spójny zasób.",
    "auto_id": 515
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje opisują 'asynchronię' w systemach rozproszonych. Która jest poprawna?",
    "definitions": {
      "A": "Model, w którym nadawca i odbiorca komunikują się w tym samym czasie (połączenie synchroniczne).",
      "B": "Sytuacja, gdzie wysłanie i odbiór komunikatów nie musi zachodzić równocześnie, a nadawca nie czeka blokująco na odbiorcę.",
      "C": "Proces odczytywania plików w pamięci współdzielonej przez wszystkie wątki jednocześnie."
    },
    "correct": "B",
    "explanation": "Asynchronia zakłada, że komunikaty są przekazywane bez blokowania nadawcy; odbiorca może je odebrać w późniejszym czasie.",
    "auto_id": 516
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja oddaje sens 'testów równoległych' (parallel tests) w kontekście aplikacji współbieżnych?",
    "definitions": {
      "A": "Testowanie, czy CSS ładuje się w odpowiedniej kolejności w warstwie UI.",
      "B": "Uruchamianie scenariuszy testowych w wielu wątkach lub procesach, aby wykryć błędy wynikające z jednoczesnego dostępu do wspólnych zasobów.",
      "C": "Weryfikacja, czy model AI generuje te same predykcje w różnych epokach."
    },
    "correct": "B",
    "explanation": "Testy równoległe pozwalają wykryć race conditions, deadlocki i inne problemy współbieżności.",
    "auto_id": 517
  },
  {
    "type": "definition_typeB",
    "question": "Która definicja najlepiej tłumaczy 'asynchronię' w programowaniu współbieżnym (w kontekście jednej maszyny)?",
    "definitions": {
      "A": "Wykonywanie kodu tylko w trybie sekwencyjnym, bez przerw i przełączeń.",
      "B": "Możliwość uruchamiania operacji, które nie blokują głównego wątku na czekanie — zadania są przetwarzane w tle, a powiadomienie o wyniku dociera do wątku głównego w dogodnym momencie.",
      "C": "Wyłączne użycie sygnałów jądra do monitorowania stanu klastrów HPC."
    },
    "correct": "B",
    "explanation": "Asynchroniczność pozwala na nieblokujące wykonywanie zadań, co zwiększa efektywność przy operacjach I/O lub dłużej trwających operacjach.",
    "auto_id": 518
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja trafnie przedstawia rolę 'warstwy rekurencyjnej' w RNN (ang. Recurrent Layer)?",
    "definitions": {
      "A": "Splotowe przetwarzanie macierzy 2D w sieciach CNN do detekcji krawędzi.",
      "B": "Moduł pamięci poprzednich kroków (stan ukryty), pozwalający sieci analizować dane sekwencyjne w kolejnych krokach czasowych.",
      "C": "Płaska warstwa bez funkcji aktywacji, używana wyłącznie w autoenkoderach denoising."
    },
    "correct": "B",
    "explanation": "Warstwa rekurencyjna przechowuje stan poprzednich wejść, co jest kluczowe do przetwarzania sekwencji.",
    "auto_id": 519
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje odnoszą się do 'gradientu zanikającego' (vanishing gradient). Która jest właściwa?",
    "definitions": {
      "A": "Zjawisko, gdzie wartości gradientu rosną wykładniczo, destabilizując trening sieci głębokiej.",
      "B": "Efekt, w którym gradient w kolejnych warstwach staje się bardzo mały, uniemożliwiając efektywną aktualizację wag warstw wstecznych (bliskich wejścia).",
      "C": "Wyłączne stosowanie warstw konwolucyjnych do obrazów wysokiej rozdzielczości."
    },
    "correct": "B",
    "explanation": "Gradient zanikający pojawia się, gdy w głębokich sieciach sygnał błędu jest tak słaby, że wczesne warstwy nie uczą się efektywnie.",
    "auto_id": 520
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najwierniej charakteryzuje 'kamienie milowe' (milestones) w procesie projektowania systemu informatycznego?",
    "definitions": {
      "A": "Zależności w UML między klasami, reprezentowane za pomocą linii dziedziczenia.",
      "B": "Kluczowe punkty osiągnięć (np. ukończenie analizy, prototypu, fazy testów), pozwalające mierzyć postęp w projekcie.",
      "C": "Szczegółowe rejestry błędów pojawiających się przy kompilacji oprogramowania."
    },
    "correct": "B",
    "explanation": "Kamienie milowe to ważne etapy projektu pozwalające ocenić postęp i zgodność z planem.",
    "auto_id": 521
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje traktują o 'zarządzaniu ryzykiem' w metodykach projektowych. Która najlepiej opisuje ten proces?",
    "definitions": {
      "A": "Losowe wyliczanie potencjalnych zagrożeń bez planu zapobiegania.",
      "B": "Identyfikowanie potencjalnych zagrożeń, ich priorytetyzacja i planowanie działań ograniczających lub unikających ryzyko w projekcie.",
      "C": "Stałe rozdzielanie zadań testerskich do jednego pracownika, by minimalizować błędy w kodzie."
    },
    "correct": "B",
    "explanation": "Zarządzanie ryzykiem polega na systematycznym określaniu zagrożeń, ocenie ich wpływu/prawdopodobieństwa i opracowaniu planu reakcji.",
    "auto_id": 522
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja najbardziej trafnie oddaje 'komponent UML' (component diagram)?",
    "definitions": {
      "A": "Diagram prezentujący interakcje użytkownika w postaci przypadków użycia.",
      "B": "Diagram ilustrujący moduły aplikacji (komponenty) i zależności między nimi, często używany do wizualizacji architektury systemu.",
      "C": "Schemat przepływu aktywności w kontekście procesów biznesowych i decyzyjnych."
    },
    "correct": "B",
    "explanation": "Diagram komponentów pokazuje moduły (np. pakiety, biblioteki) systemu i ich wzajemne zależności/interfejsy.",
    "auto_id": 523
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje opisują 'diagram wdrożenia' (deployment diagram). Która jest właściwa?",
    "definitions": {
      "A": "Opisuje klasy, interfejsy i ich relacje w systemie obiektowym.",
      "B": "Pokazuje fizyczne rozmieszczenie artefaktów (np. komponentów oprogramowania) na węzłach (serwerach, urządzeniach) w środowisku wykonawczym.",
      "C": "Schemat przepływu zdarzeń i wiadomości między obiektami w porządku czasowym."
    },
    "correct": "B",
    "explanation": "Diagram wdrożenia prezentuje, na jakich serwerach/węzłach uruchamiane są elementy systemu.",
    "auto_id": 524
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja tłumaczy 'złączenie wielu źródeł' (data integration) przed etapem eksploracji w hurtowni?",
    "definitions": {
      "A": "Technika łączenia tabel z identycznymi kolumnami w jednej bazie.",
      "B": "Proces zebrania danych z różnych systemów (np. pliki, bazy relacyjne, API), ujednolicenia ich struktur, formatów i wprowadzenia do wspólnego repozytorium.",
      "C": "Eksport pojedynczego formatu XML do arkusza offline i rezygnacja z analizy."
    },
    "correct": "B",
    "explanation": "Data integration łączy dane z różnych źródeł w spójny format, co jest kluczowe przed analizą w hurtowni.",
    "auto_id": 525
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje dotyczą „danych odstających” (outliers) w eksploracji danych. Która jest poprawna?",
    "definitions": {
      "A": "Wiersze, które idealnie pasują do modelu, a przez to nie wpływają na wynik analizy.",
      "B": "Punkty, które znacząco odbiegają od reszty populacji, mogące wskazywać błędy pomiaru, anomalię lub nietypowe przypadki.",
      "C": "Wszystkie rekordy, które mają wartości 0 lub NULL."
    },
    "correct": "B",
    "explanation": "Outliery to dane istotnie różniące się od głównego rozkładu, wymagające uwzględnienia przy analizie, bo mogą zaburzać wyniki.",
    "auto_id": 526
  },
  {
    "type": "definition_typeA",
    "question": "Która definicja wyjaśnia pojęcie 'Velocity' w kontekście Big Data?",
    "definitions": {
      "A": "Różnorodność typów danych (tekst, obraz, wideo).",
      "B": "Ogromna szybkość napływu, przetwarzania i generowania danych w czasie zbliżonym do rzeczywistego.",
      "C": "Stabilność formatu CSV przy importowaniu do Hadoop."
    },
    "correct": "B",
    "explanation": "Jedno z 3V Big Data to Velocity – prędkość generowania i przetwarzania danych, często w trybie strumieniowym.",
    "auto_id": 527
  },
  {
    "type": "definition_typeB",
    "question": "Poniższe definicje opisują 'data mart' w środowisku Business Intelligence. Która jest najbliższa prawdy?",
    "definitions": {
      "A": "Pełna replika hurtowni danych obejmująca wszystkie obszary tematyczne całej firmy.",
      "B": "Mniejszy, wyodrębniony fragment hurtowni lub samodzielny obszar tematyczny skoncentrowany na konkretnym dziale (np. sprzedaż, marketing).",
      "C": "Metoda przenoszenia danych w formacie binarnym z produkcyjnego systemu OLTP do jednego pliku CSV."
    },
    "correct": "B",
    "explanation": "Data mart to wycinek hurtowni (np. dedykowany działowi sprzedaży), uproszczony i dostosowany do konkretnych potrzeb.",
    "auto_id": 528
  },
  {
    "type": "practical_example",
    "question": "Masz zbiór danych dotyczących ocen uczniów i chcesz przewidzieć, czy dany uczeń zaliczy przedmiot (tak/nie). Masz już gotowe etykiety (zaliczył / nie zaliczył). Który rodzaj modelu pozwoli Ci na stworzenie klasyfikatora tak/nie w kontekście uczenia nadzorowanego?",
    "options": {
      "A": "Algorytm klasteryzacji k-means",
      "B": "Regresja liniowa na wartości punktowe",
      "C": "Klasyfikacja binarna (np. drzewa decyzyjne, SVM binarny)",
      "D": "Sieć Hopfielda do zapamiętywania wzorców"
    },
    "correct": "C",
    "explanation": "Klasyfikator binarny w uczeniu nadzorowanym rozwiązuje problem tak/nie (zaliczył / nie zaliczył).",
    "auto_id": 529
  },
  {
    "type": "practical_example",
    "question": "Chcesz nauczyć sieć neuronową rozpoznawania obiektów na obrazach (kot, pies). Obrazy są zróżnicowane, a sieć ma wiele warstw ukrytych. Który rodzaj sieci głębokiej będzie najbardziej odpowiedni dla tego zadania?",
    "options": {
      "A": "Rekurencyjna sieć neuronowa (RNN) do przetwarzania sygnału sekwencyjnego",
      "B": "Sieć konwolucyjna (CNN) z kilkoma warstwami splotu i pooling",
      "C": "Autoenkoder do kompresji danych tabelarycznych",
      "D": "Sieć Hopfielda do rekonstrukcji zapamiętanych wektorów"
    },
    "correct": "B",
    "explanation": "CNN najlepiej nadaje się do zadań wizji komputerowej i klasyfikacji obrazów.",
    "auto_id": 530
  },
  {
    "type": "practical_example",
    "question": "Masz problem optymalizacyjny polegający na doborze parametrów produkcji (wiele zmiennych liczbowych) tak, aby zminimalizować koszty i zmaksymalizować wydajność. Potrzebujesz metody inspirowanej naturą, która iteracyjnie polepsza populację rozwiązań. Które podejście wybierzesz?",
    "options": {
      "A": "Wykorzystasz proste wnioskowanie z baz wiedzy (system ekspertowy).",
      "B": "Wykorzystasz drzewo decyzyjne z losowym wyborem gałęzi.",
      "C": "Sięgniesz po algorytmy genetyczne do ewolucyjnej optymalizacji.",
      "D": "Zastosujesz klasteryzację hierarchiczną w celu podziału parametrów."
    },
    "correct": "C",
    "explanation": "Algorytmy genetyczne świetnie sprawdzają się w złożonych problemach optymalizacyjnych, iteracyjnie poprawiając rozwiązania.",
    "auto_id": 531
  },
  {
    "type": "practical_example",
    "question": "Projektujesz aplikację, która musi działać na wielu serwerach jednocześnie (każdy serwer może przetwarzać fragment zadań). Jak najlepiej zorganizować ten system, by nie było pojedynczego punktu awarii i by można było dołączyć kolejne serwery w razie wzrostu obciążenia?",
    "options": {
      "A": "Zaplanować monolityczną aplikację na jednym serwerze i wymagać większego CPU.",
      "B": "Zbudować system rozproszony, gdzie kolejne węzły można dodawać i usuwać dynamicznie.",
      "C": "Włączyć tryb offline, który nie potrzebuje przetwarzania równoległego.",
      "D": "Użyć bazy Excel w sieci SMB z plikiem do współdzielenia obliczeń."
    },
    "correct": "B",
    "explanation": "System rozproszony pozwala na rozdzielenie zadań między węzłami, co eliminuje pojedynczy punkt awarii i wspiera skalowalność.",
    "auto_id": 532
  },
  {
    "type": "practical_example",
    "question": "Tworzysz serwer czatu, który może mieć tysiące jednoczesnych połączeń użytkowników. Operacje to głównie wejście/wyjście (wysyłanie, odbieranie wiadomości). Jakie podejście będzie najbardziej efektywne?",
    "options": {
      "A": "Pojedynczy wątek obsługujący wszystkich użytkowników sekwencyjnie.",
      "B": "Wielowątkowość lub asynchroniczny event loop (np. Node.js), aby równolegle obsługiwać wiele zapytań I/O.",
      "C": "Nadawanie najwyższego priorytetu jednemu procesowi w systemie i kolejka FIFO dla reszty.",
      "D": "Ręczny upgrade pakietów basha do wersji multi-socket."
    },
    "correct": "B",
    "explanation": "Aplikacja I/O bound (jak czat) najlepiej działa w modelu wielowątkowym lub asynchronicznym, co zapewnia wysoka równoległość obsługi.",
    "auto_id": 533
  },
  {
    "type": "practical_example",
    "question": "Masz do przetworzenia sekwencję zdania w celu przewidzenia następnego słowa (np. w predykcji tekstu). Która sieć neuronowa jest do tego najlepiej dostosowana?",
    "options": {
      "A": "Klasyczny perceptron wielowarstwowy (MLP) bez pamięci stanu",
      "B": "Konwolucyjna sieć neuronowa skonfigurowana do wykrywania krawędzi",
      "C": "Rekurencyjna sieć neuronowa (RNN), np. LSTM do danych sekwencyjnych",
      "D": "Drzewo decyzyjne ograniczone do 2 poziomów"
    },
    "correct": "C",
    "explanation": "RNN (szczególnie LSTM/GRU) przetwarzają sekwencje, przewidując kolejne słowa, uwzględniając kontekst poprzednich kroków.",
    "auto_id": 534
  },
  {
    "type": "practical_example",
    "question": "Twoja firma musi opracować nowy system sprzedaży online. Wymagania często się zmieniają na podstawie feedbacku klienta. Które podejście do zarządzania projektem najlepiej się tu sprawdzi?",
    "options": {
      "A": "Sztywny Waterfall, żeby raz na początku spisać wszystkie wymagania i unikać zmian",
      "B": "Zwinne (Agile), z podziałem na sprinty, umożliwiające częste zmiany i szybkie dostarczanie funkcjonalności",
      "C": "Model Big Bang z brakiem analizy i implementacją od razu w kodzie produkcyjnym",
      "D": "Nieformalna metoda, bez żadnego planu i dokumentacji"
    },
    "correct": "B",
    "explanation": "Agile umożliwia szybkie reagowanie na zmieniające się wymagania i częste dostarczanie nowych funkcji klientowi.",
    "auto_id": 535
  },
  {
    "type": "practical_example",
    "question": "Projektujesz system, w którym użytkownik (aktor) rezerwuje bilety w kinie. Chcesz pokazać interakcję między użytkownikiem a systemem: logowanie, wybór filmu, wybór miejsc, płatność. Który diagram UML najlepiej to zobrazowuje z perspektywy funkcjonalności?",
    "options": {
      "A": "Diagram przypadków użycia (use case)",
      "B": "Diagram klas i dziedziczenia",
      "C": "Diagram komponentów",
      "D": "Diagram wdrożenia (deployment)"
    },
    "correct": "A",
    "explanation": "Diagram przypadków użycia przedstawia scenariusze (rezerwacja biletów, płatność) z perspektywy aktora (użytkownika).",
    "auto_id": 536
  },
  {
    "type": "practical_example",
    "question": "Masz dane z różnych plików CSV i bazy MySQL, które chcesz przetworzyć i załadować do jednej hurtowni w spójnym formacie. Który proces powinnaś zastosować?",
    "options": {
      "A": "Analiza klastrów (k-means) w fazie modelowania",
      "B": "ETL: Extraction z CSV i bazy, Transform (ujednolicenie formatu), Load do hurtowni",
      "C": "Bezpośrednia replikacja binarna z MySQL do pliku XLS"
    },
    "correct": "B",
    "explanation": "ETL jest standardowym procesem przetwarzania i łączenia danych z różnych źródeł w docelowym systemie.",
    "auto_id": 537
  },
  {
    "type": "practical_example",
    "question": "Chcesz analizować ogromne wolumeny zróżnicowanych danych (teksty, logi, zdjęcia) napływających w czasie rzeczywistym. Który z poniższych scenariuszy pasuje do koncepcji Big Data?",
    "options": {
      "A": "Przechowywanie wyłącznie małych, prostych plików tekstowych w jednym folderze",
      "B": "Strumieniowe przetwarzanie w klastrze (np. Hadoop, Spark), skalowanie i analiza wielkich zestawów rozmaitych danych",
      "C": "Wykluczenie replikacji i ograniczenie do jednej maszyny stacjonarnej z 8 GB RAM"
    },
    "correct": "B",
    "explanation": "Big Data obejmuje duże, różnorodne i szybko napływające dane, co wymaga specjalnych narzędzi i architektury (Spark, Hadoop).",
    "auto_id": 538
  },
  {
    "type": "practical_example",
    "question": "Przykładowy scenariusz: aplikacja mobilna do zamawiania jedzenia musi pobierać listę restauracji wraz z menu z serwera. Jak powinna wyglądać komunikacja z serwerem bazodanowym?",
    "options": {
      "A": "Aplikacja mobilna łączy się bezpośrednio z portem MySQL i wysyła zapytania SELECT",
      "B": "Aplikacja wysyła żądania do API (np. REST) z endpointem /restaurants i serwer zwraca dane z bazy w formacie JSON",
      "C": "Aplikacja mobilna musi wgrać sterowniki ODBC i pisać zapytania w SQL do pliku .env"
    },
    "correct": "B",
    "explanation": "Najlepsze rozwiązanie to wykorzystanie warstwy backend/API, a nie bezpośredni dostęp aplikacji do bazy.",
    "auto_id": 539
  },
  {
    "type": "practical_example",
    "question": "Chcesz zdefiniować tabelę 'Zamowienia' z kluczem głównym 'zamowienie_id' i kluczem obcym 'klient_id' odnoszącym się do tabeli 'Klienci'. Jak powinieneś opisać klucz obcy w SQL (upraszczając)?",
    "options": {
      "A": "FOREIGN KEY (klient_id) REFERENCES Klienci(klient_id)",
      "B": "PRIMARY KEY (zamowienie_id) REFERENCES Klienci(klient_id)",
      "C": "PRIMARY KEY (klient_id) ON DELETE SET NULL",
      "D": "NO KEY (zamowienie_id) CASCADE do Klienci(klient_id)"
    },
    "correct": "A",
    "explanation": "Klucz obcy to FOREIGN KEY (klient_id) REFERENCES Klienci(klient_id) – opisuje relację Zamowienia→Klienci.",
    "auto_id": 540
  },
  {
    "type": "practical_example",
    "question": "Masz tabele 'Users' i 'Orders'. Chcesz wybrać wszystkich użytkowników, nawet jeśli nie złożyli żadnego zamówienia, wraz z informacją o ewentualnej dacie ostatniego zamówienia. Jaki rodzaj JOIN będzie potrzebny?",
    "options": {
      "A": "INNER JOIN",
      "B": "LEFT JOIN",
      "C": "RIGHT JOIN",
      "D": "FULL OUTER JOIN"
    },
    "correct": "B",
    "explanation": "LEFT JOIN zwróci wszystkich użytkowników (z lewej tabeli) i dopasowane zamówienia (z prawej). Jeśli brak zamówień, pola z Orders będą NULL.",
    "auto_id": 541
  },
  {
    "type": "practical_example",
    "question": "Tworzysz stronę sklepu, która musi wyglądać dobrze na telefonie i na dużym ekranie komputera. Które techniki musisz zastosować?",
    "options": {
      "A": "Tylko ustawianie szerokości elementów na stałe w px",
      "B": "Responsywny układ z użyciem media queries, aby dostosowywać layout do różnych szerokości ekranu",
      "C": "Generowanie pełnej strony w rozdzielczości 4K i skalowanie w dół w przeglądarce",
      "D": "Zablokowanie orientacji pionowej (portrait) na telefonach"
    },
    "correct": "B",
    "explanation": "Media queries i elastyczne style to klucz do responsywności, by layout pasował na różne ekrany.",
    "auto_id": 542
  },
  {
    "type": "practical_example",
    "question": "W systemie Linux masz wiele procesów generujących spore obciążenie. Chcesz tymczasowo zwiększyć priorytet jednego z nich, by szybciej się wykonał. Co możesz zrobić?",
    "options": {
      "A": "Użyć polecenia 'nice' lub 'renice', aby obniżyć wartość 'nice' (czyli podnieść priorytet).",
      "B": "Edytować plik /etc/passwd i ustawić parametr Priority=High.",
      "C": "Zrestartować komputer w trybie single-user i zostawić tylko ten proces.",
      "D": "Uruchomić 'nohup' bez żadnych argumentów, co automatycznie daje wyższy priorytet."
    },
    "correct": "A",
    "explanation": "W systemach Linux polecenia nice/renice zmieniają priorytety procesów. Mniejszy 'nice value' oznacza wyższy priorytet.",
    "auto_id": 543
  },
  {
    "type": "practical_example",
    "question": "Chcesz dodać nowego użytkownika w systemie Linux z ograniczonym dostępem do plików systemowych. Co wykonasz?",
    "options": {
      "A": "Polecenie 'groupadd restricted -f', by tworzyć plik konfiguracyjny w /etc/shadow",
      "B": "Polecenie 'useradd nowyuser' i przypisanie go do ograniczonej grupy, skonfigurowanie uprawnień w /etc/sudoers (lub brak dostępu do sudo).",
      "C": "Edytowanie pliku /boot/ i dopisanie user=nowyuser w linii kernel"
    },
    "correct": "B",
    "explanation": "useradd tworzy konto, a grupy i sudoers pozwalają ograniczyć przywileje.",
    "auto_id": 544
  },
  {
    "type": "practical_example",
    "question": "Konfigurujesz domowe Wi-Fi i chcesz je zabezpieczyć. Które działania powinieneś podjąć?",
    "options": {
      "A": "Zezwolić na tryb open (bez hasła) z silnym hasłem administracyjnym do routera",
      "B": "Używać WEP, bo jest łatwiejszy do skonfigurowania",
      "C": "Ustawić WPA2/WPA3 z mocnym hasłem, zmienić domyślną nazwę i hasło do routera, rozważyć wyłączenie WPS",
      "D": "Nie używać żadnego szyfrowania i spisać MAC swojego laptopa"
    },
    "correct": "C",
    "explanation": "Najbezpieczniej używać WPA2/WPA3, mocnego hasła i wyłączyć WPS, bo jest podatne na ataki.",
    "auto_id": 545
  },
  {
    "type": "practical_example",
    "question": "Musisz wysłać z klienta HTTP (frontend) formularz rejestracji do serwera, który zapisze dane w bazie. Jak to zorganizować?",
    "options": {
      "A": "Frontend wywołuje metodę fetch() do endpointu POST /api/register na backendzie, backend waliduje dane i zapisuje do bazy.",
      "B": "Frontend bezpośrednio wstawia rekord do tabeli MySQL przez port 3306.",
      "C": "Backend wysyła zapytanie GET do pliku CSV z przeglądarki, generując rejestrację.",
      "D": "W pliku .env wstawiasz hasło do bazy i udostępniasz je w HTML do wypełnienia."
    },
    "correct": "A",
    "explanation": "Standardem jest warstwa backendu (REST, np. POST /api/register), gdzie dane są przetwarzane i zapisywane do bazy.",
    "auto_id": 546
  },
  {
    "type": "practical_example",
    "question": "Tworzysz aplikację o architekturze trójwarstwowej. Użytkownik klika przycisk 'dodaj produkt' na stronie. Co się dzieje w warstwie logiki?",
    "options": {
      "A": "Bezpośrednio przesyła zawartość do bazy, pomijając reguły walidacji.",
      "B": "Sprawdza reguły (czy nazwa niepusta, cena > 0), tworzy obiekt produkt, odwołuje się do warstwy danych, by zapisać.",
      "C": "Zamyka proces przeglądarki i edytuje plik CSV w folderze /tmp.",
      "D": "Renderuje styl CSS w zależności od formatu obrazu produktu."
    },
    "correct": "B",
    "explanation": "Warstwa logiki wykonuje walidacje i reguły, a następnie przekazuje dane do warstwy danych w celu zapisu.",
    "auto_id": 547
  },
  {
    "type": "practical_example",
    "question": "Potrzebujesz zebrać informacje o satysfakcji klientów z Twojej aplikacji. Chcesz, aby wypełnili krótki kwestionariusz. Jaką metodę pozyskiwania danych zastosujesz?",
    "options": {
      "A": "Web scraping stron konkurencji",
      "B": "Ankietę online, gdzie użytkownicy dobrowolnie podadzą opinię",
      "C": "Automatyczne logi systemowe rejestrujące jedynie komunikaty debug",
      "D": "Klasteryzację produktów w bazie bez pytania klientów"
    },
    "correct": "B",
    "explanation": "Formularz/ankieta online to metoda, w której klienci wypełniają dane zwrotne, idealna do badania satysfakcji.",
    "auto_id": 548
  },
  {
    "type": "practical_example",
    "question": "Tworzysz aplikację mobilną do rezerwacji hotelu. Chcesz zapewnić skuteczną synchronizację danych rezerwacji z bazą, by uniknąć konfliktów. Jak to zorganizujesz?",
    "options": {
      "A": "Aplikacja mobilna bezpośrednio łączy się z portem bazy SQL, omijając jakikolwiek serwer",
      "B": "Korzystasz z REST API w backendzie, który obsługuje transakcje w bazie, a aplikacja mobilna wywołuje je z odpowiednimi danymi (np. POST /reserve).",
      "C": "Masz prosty plik .txt, w którym jednocześnie wszyscy zapisują rezerwacje",
      "D": "Proponujesz rezerwacje offline, bez możliwości rozwiązywania konfliktów"
    },
    "correct": "B",
    "explanation": "Bezpieczna komunikacja przez backend (API) i użycie transakcji w bazie unika konfliktów i zapewnia spójność rezerwacji.",
    "auto_id": 549
  },
  {
    "type": "practical_example",
    "question": "Masz tabelę 'Książki' z kluczem głównym (isbn) i tabelę 'Wypożyczenia' z kluczem obcym (isbn), aby wiedzieć, która książka została wypożyczona. Jak zapewnić, że gdy książka zostanie usunięta, związane wypożyczenia też znikną?",
    "options": {
      "A": "Ustawić ON DELETE CASCADE w kluczu obcym (isbn) w tabeli 'Wypożyczenia'",
      "B": "Użyć klucza ON DELETE RESTRICT",
      "C": "Przechowywać klucz isbn w pliku .env i usuwać go ręcznie przy each commit",
      "D": "Zignorować tę kwestię, bo DBMS zawsze automatycznie usuwa wszystkie powiązane wiersze"
    },
    "correct": "A",
    "explanation": "ON DELETE CASCADE automatycznie usuwa powiązane rekordy, gdy usuwamy wpis w tabeli nadrzędnej.",
    "auto_id": 550
  },
  {
    "type": "practical_example",
    "question": "Dysponujesz tabelami 'Pracownicy' i 'Projekty'. Każdy projekt może mieć przypisanego Pracownika jako menedżera, ale chcesz pobrać wszystkie Projekty nawet bez menedżera przypisanego. Jakiego JOIN-a użyć?",
    "options": {
      "A": "INNER JOIN na Pracownicy i Projekty",
      "B": "LEFT JOIN na Projekty do Pracownicy po kluczu menedżera",
      "C": "RIGHT JOIN na Pracownicy w stronę Projekty",
      "D": "CROSS JOIN bez warunków ON"
    },
    "correct": "B",
    "explanation": "LEFT JOIN zwróci wszystkie Projekty (lewa tabela) i ewentualnie dopasowanych Pracowników (prawa); brak menedżera daje NULL.",
    "auto_id": 551
  },
  {
    "type": "practical_example",
    "question": "Twój layout wygląda dobrze na komputerze, ale na telefonie elementy się rozjeżdżają. Zauważasz, że w HTML brakuje meta viewport. Jak powinien on wyglądać?",
    "options": {
      "A": "<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">",
      "B": "<meta name=\\\"responsive\\\" content=\\\"initial-scale=desktop\\\">",
      "C": "<meta name=\\\"zoom\\\" content=\\\"0.5, device-scale=2.0\\\">",
      "D": "<meta name=\\\"mobile-friendly\\\" content=\\\"true\\\">"
    },
    "correct": "A",
    "explanation": "Najpopularniejsze ustawienie to width=device-width, initial-scale=1.0, zapewniające poprawne skalowanie strony na urządzeniach mobilnych.",
    "auto_id": 552
  },
  {
    "type": "practical_example",
    "question": "Masz dwa procesy odczytujące różne pliki i niezależne w sobie. Czy planista w systemie operacyjnym musi stosować blokady między tymi procesami?",
    "options": {
      "A": "Tak, bo każdy dostęp do pliku wymaga synchronizacji w single-user mode",
      "B": "Niekoniecznie, jeśli procesy używają różnych zasobów i nie kolidują, system daje im CPU według priorytetu lub kwantu czasu",
      "C": "Zawsze planista tworzy semafory binarne do wszystkich plików w /etc",
      "D": "Brak możliwości uruchomienia dwóch procesów jednocześnie w nowoczesnych systemach"
    },
    "correct": "B",
    "explanation": "Jeśli procesy nie współdzielą tych samych zasobów, nie jest wymagana synchronizacja ich dostępu. Planista i tak przydziela CPU w ramach standardowych algorytmów.",
    "auto_id": 553
  },
  {
    "type": "practical_example",
    "question": "Chcesz w Windows utworzyć konto użytkownika 'Adam', który ma mieć ograniczone możliwości, np. brak dostępu do Panelu Sterowania. Jak to można osiągnąć?",
    "options": {
      "A": "Nadać mu uprawnienia 'Administrator' i oczekiwać, że sam się ograniczy",
      "B": "Utworzyć konto standardowe (non-admin) 'Adam' i skonfigurować zasady grupy (Group Policy) ograniczające dostęp do Panelu Sterowania",
      "C": "Przestawić komputer w tryb offline i w ogóle nie tworzyć konta",
      "D": "Zdefiniować w pliku shadow w rejestrze klucz 'Restricted=Yes'"
    },
    "correct": "B",
    "explanation": "Konto standardowe plus ograniczenia w Group Policy to typowe sposoby w Windows na ograniczenie funkcji dla danego użytkownika.",
    "auto_id": 554
  },
  {
    "type": "practical_example",
    "question": "W sieci Wi-Fi odczuwasz zakłócenia, bo wokół jest wiele innych routerów na tym samym kanale (2,4 GHz). Jak możesz poprawić sytuację?",
    "options": {
      "A": "Ustawić protokół WEP, bo to gwarantuje mniejszą interferencję",
      "B": "Przestawić kanał Wi-Fi na mniej obciążony (np. 1, 6 lub 11) albo przejść na pasmo 5 GHz, jeśli router to wspiera",
      "C": "Wyłączyć DNS w routerze",
      "D": "Przeprowadzić cross-site request forging na sąsiednie routery"
    },
    "correct": "B",
    "explanation": "Zmiana kanału lub użycie pasma 5 GHz zmniejsza zakłócenia od innych sieci w 2,4 GHz.",
    "auto_id": 555
  },
  {
    "type": "practical_example",
    "question": "Masz aplikację typu Single Page Application (SPA) w React oraz backend w Node.js (Express). Chcesz, by użytkownik w przeglądarce wchodził na /login, a serwer po stronie Node odpowiadał. Jak to zwykle wygląda?",
    "options": {
      "A": "SPA (React) obsługuje routing po stronie klienta (np. /login), a zapytania do Node (np. /api) służą do logiki i bazy. Serwer Express może też służyć plikiem index.html.",
      "B": "Kod React kompiluje się do pliku .exe, który działa w systemie Windows na serwerze",
      "C": "Plik .jsx z definicją /login jest przenoszony do bazy MySQL i stamtąd generowany dynamicznie",
      "D": "Nie ma takiej możliwości, bo React i Node są niekompatybilne"
    },
    "correct": "A",
    "explanation": "W SPA routing jest obsługiwany przez React, a komunikacja z backendem (Express) odbywa się przez endpointy /api (lub inne). Serwer może udostępniać także pliki statyczne.",
    "auto_id": 556
  },
  {
    "type": "practical_example",
    "question": "Chcesz podzielić aplikację na trzy warstwy: front (HTML+JS), serwis (logika) i bazę. Front jest na serwerze A, serwis na B, baza na C. Co zyskujesz?",
    "options": {
      "A": "Łatwiejsze utrzymanie (można zmieniać warstwę serwis bez wpływu na front, i odwrotnie) oraz skalowanie (np. replikacja bazy).",
      "B": "Konieczność przepisywania całego systemu przy każdej modyfikacji warstwy frontu.",
      "C": "Zwiększone ryzyko, bo wszystkie warstwy są w jednym węźle.",
      "D": "Brak możliwości testowania jednostkowego kodu serwisu."
    },
    "correct": "A",
    "explanation": "Architektura trójwarstwowa zwiększa elastyczność rozwoju i możliwość skalowania/utrzymania poszczególnych warstw niezależnie.",
    "auto_id": 557
  },
  {
    "type": "practical_example",
    "question": "Masz setki PDF z raportami i chcesz z nich wyciągnąć dane liczbowe do dalszej analizy. Jak możesz to rozwiązać?",
    "options": {
      "A": "Uruchamiając automatyczny web scraping stron, które nie istnieją",
      "B": "Wykorzystując OCR lub dedykowane narzędzia do parsowania zawartości PDF, by wyciągnąć potrzebne dane do zorganizowanej formy (np. CSV)",
      "C": "Zostawiając je w spoczynku, bo PDF nigdzie indziej się nie przyda",
      "D": "Zmuszając użytkowników do ręcznego przepisywania"
    },
    "correct": "B",
    "explanation": "Aby pozyskać dane z PDF, zwykle stosuje się narzędzia do konwersji/parsowania (czasem też OCR, jeśli PDF to skany).",
    "auto_id": 558
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Model uczenia nadzorowanego wymaga zbioru etykiet, które należy losowo modyfikować, aby uzyskać lepsze wyniki.",
      "B": "Model uczenia nadzorowanego korzysta ze zbioru przykładów z poprawnymi etykietami, by nauczyć się przewidywać te etykiety dla nowych danych."
    },
    "correct": "B",
    "explanation": "W uczeniu nadzorowanym potrzebne są etykiety, których model uczy się rozpoznawać w nowych przykładach.",
    "auto_id": 559
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Funkcja kosztu w uczeniu nadzorowanym nie wpływa na proces dostosowywania wag w modelu, a służy wyłącznie do weryfikacji wyniku po treningu.",
      "B": "Funkcja kosztu wskazuje różnicę pomiędzy przewidywaniami a etykietami, co pozwala zoptymalizować wagi w trakcie uczenia."
    },
    "correct": "B",
    "explanation": "Funkcja kosztu (loss function) informuje model, jak bardzo rozmija się z oczekiwanym wynikiem, i jest minimalizowana podczas treningu.",
    "auto_id": 560
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W uczeniu nadzorowanym klasy decyduje się wyłącznie losowo, aby zapewnić różnorodność wyników.",
      "B": "W uczeniu nadzorowanym system otrzymuje przykłady wraz z właściwymi etykietami, a celem jest nauczenie się reguły przyporządkowania."
    },
    "correct": "B",
    "explanation": "W nadzorowanym modelu musi istnieć informacja o prawidłowej etykiecie (label), na podstawie której model się uczy.",
    "auto_id": 561
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W sieciach głębokich najważniejsze są warstwy konwolucyjne służące wyłącznie do przetwarzania sygnałów dźwiękowych.",
      "B": "W sieciach głębokich można stosować wiele warstw (ukrytych), co pozwala na hierarchiczną ekstrakcję cech, np. w CNN dla obrazów."
    },
    "correct": "B",
    "explanation": "Głębokie sieci neuronowe (np. CNN) stosują wiele warstw, ucząc się coraz bardziej złożonych cech.",
    "auto_id": 562
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Warstwa dropout zawsze zwiększa overfitting, bo losowo wyłącza neurony, uniemożliwiając naukę.",
      "B": "Warstwa dropout może ograniczyć przeuczenie, wyłączając losowo pewien procent neuronów, co zmusza sieć do bardziej ogólnych wzorców."
    },
    "correct": "B",
    "explanation": "Dropout działa jako regularizacja, zapobiegając nadmiernemu dopasowaniu do zbioru treningowego.",
    "auto_id": 563
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Funkcja aktywacji Softmax służy do przypisywania prawdopodobieństw w zadaniu wieloklasowym, sumując się do 1.",
      "B": "Funkcja aktywacji Softmax zawsze generuje ujemne wartości dla klas, by odrzucić klasy nieistotne."
    },
    "correct": "A",
    "explanation": "Softmax przekształca logity w wektor prawdopodobieństw (wartości dodatnie, suma = 1).",
    "auto_id": 564
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W algorytmach genetycznych mutacja służy wyłącznie do kopiowania najlepszych rozwiązań bez wprowadzania zmian.",
      "B": "W algorytmach genetycznych mutacja wprowadza losowe niewielkie modyfikacje do osobników, by zwiększać różnorodność populacji."
    },
    "correct": "B",
    "explanation": "Mutacja wnosi losowe zmiany w osobniku, co zapobiega zbytniej jednorodności i lokalnemu optimum.",
    "auto_id": 565
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Funkcja przystosowania (fitness) ocenia jakość osobnika w alg. genetycznym, decydując, czy jest on dobry do dalszego krzyżowania.",
      "B": "Funkcja przystosowania jest zbędna, gdyż selekcję osobników wykonuje się w pełni losowo."
    },
    "correct": "A",
    "explanation": "Fitness function określa, jak dobre jest rozwiązanie. Algorytmy genetyczne wybierają osobniki na podstawie oceny fitness.",
    "auto_id": 566
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Algorytmy genetyczne nie korzystają z koncepcji pokoleń, lecz z jednorazowego sortowania rozwiązań.",
      "B": "Algorytmy genetyczne iteracyjnie przechodzą przez kolejne generacje, stosując selekcję, krzyżowanie i mutację osobników."
    },
    "correct": "B",
    "explanation": "Z każdą generacją algorytm genetyczny tworzy nową populację na bazie poprzedniej, stale ewoluując.",
    "auto_id": 567
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W systemie rozproszonym pojedynczy punkt awarii jest nieunikniony, bo zawsze istnieje serwer główny do sterowania.",
      "B": "Systemy rozproszone często projektuje się tak, by eliminować single point of failure, używając replikacji i klastrów."
    },
    "correct": "B",
    "explanation": "Główną zaletą rozproszenia jest uniknięcie centralnego węzła, którego awaria zatrzymuje cały system.",
    "auto_id": 568
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W systemach rozproszonych synchronizacja czasu (np. NTP, protokoły Lamporta) może być istotna do porządkowania zdarzeń.",
      "B": "System rozproszony nie wymaga żadnego modelu synchronizacji, bo każdy węzeł posiada identyczny fizyczny zegar atomowy."
    },
    "correct": "A",
    "explanation": "Systemy rozproszone potrzebują mechanizmów synchronizacji czasu (chociaż przybliżonych), by uporządkować sekwencje zdarzeń.",
    "auto_id": 569
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W systemach rozproszonych zawsze używa się pamięci współdzielonej dostępnej przez wszystkie węzły.",
      "B": "Komunikacja w systemach rozproszonych zwykle zachodzi poprzez przesyłanie komunikatów w sieci, a nie przez globalny obszar pamięci."
    },
    "correct": "B",
    "explanation": "Węzły w systemie rozproszonym zazwyczaj komunikują się przez sieć (wymianę komunikatów), bo nie mają wspólnej pamięci fizycznej.",
    "auto_id": 570
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Współbieżność służy tylko do przyspieszania algorytmów obliczeniowych CPU-bound bez I/O.",
      "B": "Współbieżność pozwala obsługiwać wiele zadań (np. I/O) w przeplatany lub równoległy sposób, poprawiając reakcję systemu."
    },
    "correct": "B",
    "explanation": "Współbieżność ma zastosowanie i w zadaniach CPU-bound (równoległość na wielu rdzeniach), i I/O-bound (przeplatanie).",
    "auto_id": 571
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Deadlock to sytuacja, w której żaden proces nie może kontynuować, bo wzajemnie blokują zasoby.",
      "B": "Deadlock jest synonimem race condition i oznacza wyłącznie nieuporządkowany dostęp do pamięci wspólnej."
    },
    "correct": "A",
    "explanation": "W deadlocku procesy/wątki czekają na zasoby blokowane przez siebie nawzajem, nikt nie może ruszyć dalej.",
    "auto_id": 572
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Race condition pojawia się, gdy wątki synchronizują dostęp do zasobów i zawsze kolejno oczekują, unikając kolizji.",
      "B": "Race condition występuje, gdy kilka wątków jednocześnie modyfikuje wspólny zasób bez odpowiedniej synchronizacji."
    },
    "correct": "B",
    "explanation": "Race condition to kolizja wielu wątków do zasobu, powodująca nieprzewidywalne wyniki w braku synchronizacji.",
    "auto_id": 573
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Sieci RNN nie potrafią pamiętać wcześniejszych stanów, więc przeznaczone są tylko do przetwarzania obrazów statycznych.",
      "B": "Sieci RNN mają stan ukryty, co umożliwia przetwarzanie sekwencji (tekst, sygnały, serie czasowe)."
    },
    "correct": "B",
    "explanation": "RNN zostały zaprojektowane do pracy z sekwencjami, bo stan ukryty przenosi informację z poprzednich kroków.",
    "auto_id": 574
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Warstwy LSTM stosuje się, gdy wystarczą krótkie zależności (1-2 kroki).",
      "B": "Warstwy LSTM radzą sobie z długimi zależnościami w sekwencji dzięki mechanizmom bram i komórce pamięci."
    },
    "correct": "B",
    "explanation": "LSTM wprowadza bramy, które pozwalają zapamiętać lub odrzucić informację przez wiele kroków czasowych.",
    "auto_id": 575
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Vanishing gradient polega na tym, że gradienty rozrastają się wykładniczo przy głębokich sieciach RNN.",
      "B": "Vanishing gradient oznacza, że sygnał błędu zanika w głębokich warstwach, utrudniając uczenie wcześniejszych etapów sieci."
    },
    "correct": "B",
    "explanation": "Zanikający gradient utrudnia efektywną aktualizację wag w głębszych warstwach sieci.",
    "auto_id": 576
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Waterfall pozwala na łatwe zmiany wymagań w trakcie, bo każda faza może cofnąć się do poprzedniej.",
      "B": "Agile kładzie nacisk na iteracje i adaptację wymagań, Waterfall jest sekwencyjny i trudniej zmienić założenia po zakończeniu fazy."
    },
    "correct": "B",
    "explanation": "W modelu kaskadowym trudno wprowadzać zmiany w późnych etapach, Agile jest z natury iteracyjny i elastyczny.",
    "auto_id": 577
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W prototypowaniu tworzy się wczesne, uproszczone wersje systemu, aby sprawdzić założenia i zebrać feedback.",
      "B": "Prototypowanie polega wyłącznie na pisaniu finalnego kodu w stylu release candidate."
    },
    "correct": "A",
    "explanation": "Prototyp to wczesna i uproszczona wersja, używana do weryfikacji koncepcji i wymagań.",
    "auto_id": 578
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W modelu spiralnym każda iteracja pomija analizę ryzyka, by przyspieszyć projekt.",
      "B": "W modelu spiralnym cykle obejmują analizę ryzyka, prototypowanie i ocenę, co pozwala ograniczyć błędy w dalszych fazach."
    },
    "correct": "B",
    "explanation": "Model spiralny uwzględnia ryzyko i prototypy w każdej pętli, by weryfikować i minimalizować potencjalne błędy.",
    "auto_id": 579
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Diagram przypadków użycia (Use Case) przedstawia strukturę klas i metody dziedziczenia w systemie obiektowym.",
      "B": "Diagram przypadków użycia opisuje interakcje użytkownika (aktora) z systemem i funkcjonalności, jakie system oferuje."
    },
    "correct": "B",
    "explanation": "Use Case pokazuje, co system ma robić z perspektywy aktorów, a nie strukturę wewnętrzną.",
    "auto_id": 580
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Diagram sekwencji ilustruje przepływ zdarzeń w czasie między obiektami, w tym przekazy komunikatów.",
      "B": "Diagram sekwencji służy tylko do wizualizacji zależności dziedziczenia klas w UML."
    },
    "correct": "A",
    "explanation": "Sekwencja ukazuje kolejność komunikatów między obiektami w czasie, nie opisuje dziedziczenia.",
    "auto_id": 581
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Diagram klas skupia się na kolejności wywołań metod w run-time.",
      "B": "Diagram klas przedstawia statyczną strukturę systemu: klasy, pola, metody i relacje (dziedziczenie, asocjacje)."
    },
    "correct": "B",
    "explanation": "Diagram klas to strukturalny widok systemu, z definicją klas i ich relacji, a nie sekwencji czasowej.",
    "auto_id": 582
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Eksploracja danych polega tylko na trenowaniu modelu i ocenianiu metryk w trybie batch.",
      "B": "Eksploracja danych to wstępne poznanie rozkładów, braków i zależności, bez budowania docelowego modelu."
    },
    "correct": "B",
    "explanation": "Eksploracja danych (data exploration) to etap przed modelowaniem, by zrozumieć cechy i potencjalne problemy zbioru.",
    "auto_id": 583
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Proces ETL to jednorazowe wyeksportowanie bazy do pliku .csv i koniec.",
      "B": "Proces ETL (Extract, Transform, Load) regularnie pobiera dane ze źródeł, przekształca je (czyszczenie, standaryzacja) i ładuje do docelowego systemu (np. hurtowni)."
    },
    "correct": "B",
    "explanation": "ETL jest często cykliczny, integruje i przetwarza dane przed zapisaniem do docelowego repozytorium.",
    "auto_id": 584
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Identyfikowanie outlierów i brakujących wartości to część przygotowania i eksploracji danych.",
      "B": "Brakujące wartości zawsze zamienia się na -9999, by uprościć analizę."
    },
    "correct": "A",
    "explanation": "Eksploracja obejmuje wykrywanie anomalii i braków, natomiast sposoby ich wypełniania mogą się różnić.",
    "auto_id": 585
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Big Data dotyczy wyłącznie baz relacyjnych z tysiącami tabel i kluczami obcymi.",
      "B": "Big Data obejmuje duże, zróżnicowane i szybko napływające dane, często przekraczające możliwości tradycyjnych rozwiązań."
    },
    "correct": "B",
    "explanation": "Big Data opisuje Volume, Variety, Velocity (i czasem inne V) – duże i szybko zmieniające się zasoby danych.",
    "auto_id": 586
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Business Intelligence skupia się na integracji i analizie danych, dostarczając raporty i dashboards do decyzji biznesowych.",
      "B": "Business Intelligence to metoda kompresji plików JSON w analizie offline."
    },
    "correct": "A",
    "explanation": "BI to zestaw narzędzi/technik analitycznych wspierających decyzje na bazie przekształconych danych.",
    "auto_id": 587
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Hurtownia danych zwykle służy do operacji transakcyjnych i bieżącej edycji rekordów.",
      "B": "Hurtownia danych jest zoptymalizowana pod analizy historyczne i raportowanie (OLAP), a nie do codziennych transakcji OLTP."
    },
    "correct": "B",
    "explanation": "Hurtownie danych (OLAP) są przeznaczone do agregacji i analizy, a nie do szybkich operacji transakcyjnych (OLTP).",
    "auto_id": 588
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Operacja Create w CRUD polega wyłącznie na odczycie rekordów z bazy bez modyfikacji.",
      "B": "Operacja Create w CRUD tworzy nowy rekord w bazie, odpowiadając za dodanie danych do systemu."
    },
    "correct": "B",
    "explanation": "Create oznacza tworzenie nowych danych, np. INSERT do bazy.",
    "auto_id": 589
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Read w CRUD pozwala wyświetlać bądź pobierać dane, nie zmieniając ich zawartości.",
      "B": "Read w CRUD odpowiada za usuwanie danych z systemu, jeśli spełniony jest warunek klucza obcego."
    },
    "correct": "A",
    "explanation": "Read (odczyt) nie modyfikuje danych – służy do przeglądania lub pobierania z bazy.",
    "auto_id": 590
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Delete w CRUD umożliwia zmianę klucza głównego rekordu w tabeli, zachowując pozostałe pola.",
      "B": "Delete w CRUD usuwa wybrany rekord z bazy, często poprzez zapytanie typu DELETE z odpowiednim warunkiem."
    },
    "correct": "B",
    "explanation": "Delete odpowiada za fizyczne usunięcie rekordu z bazy danych.",
    "auto_id": 591
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Testy jednostkowe skupiają się na sprawdzaniu współpracy kilku modułów jednocześnie w środowisku produkcyjnym.",
      "B": "Testy jednostkowe badają pojedyncze elementy (funkcje, metody) w izolacji, bez zależności z innymi modułami."
    },
    "correct": "B",
    "explanation": "Testy jednostkowe (unit tests) testują małe fragmenty kodu oddzielnie od reszty systemu.",
    "auto_id": 592
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Testy regresyjne są niepotrzebne, bo jeśli dana funkcja kiedyś działała, zawsze będzie działać przy każdej zmianie kodu.",
      "B": "Testy regresyjne sprawdzają, czy zmiana w kodzie nie popsuła wcześniej działających funkcji."
    },
    "correct": "B",
    "explanation": "Testy regresyjne zapobiegają wprowadzaniu starych błędów ponownie, weryfikując stabilność istniejących funkcji.",
    "auto_id": 593
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Testy E2E (end-to-end) weryfikują poszczególne linie kodu w izolacji od całego systemu.",
      "B": "Testy E2E sprawdzają działanie całego systemu od perspektywy użytkownika do warstwy danych, obejmując wszystkie integracje."
    },
    "correct": "B",
    "explanation": "E2E testują całą ścieżkę działania aplikacji, łącznie z komunikacją między warstwami i bazą danych.",
    "auto_id": 594
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Bazy NoSQL mają zawsze sztywny schemat tabel i używają kluczy obcych do relacji.",
      "B": "Bazy NoSQL często rezygnują z relacji i sztywnego schematu, co pozwala im na większą elastyczność i skalowanie w poziomie."
    },
    "correct": "B",
    "explanation": "NoSQL zwykle stawia na elastyczny schemat i skalowalność, rezygnując z typowych relacji SQL.",
    "auto_id": 595
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Dokumentowe bazy NoSQL (np. MongoDB) przechowują dane w formie dokumentów JSON, często o zróżnicowanej strukturze.",
      "B": "Dokumentowe bazy NoSQL wymagają ściśle zdefiniowanego schematu w stylu SQL, by tworzyć tabelaryczne powiązania."
    },
    "correct": "A",
    "explanation": "Bazy dokumentowe przechowują dane w dokumentach (np. JSON), bez narzuconego schematu kolumnowego.",
    "auto_id": 596
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Key-value store w NoSQL pozwala na przesyłanie wyłącznie danych w formacie CSV o stałej długości rekordów.",
      "B": "Key-value store przechowuje dane jako pary klucz-wartość, co świetnie się sprawdza w szybkich lookupach i prostych modelach danych."
    },
    "correct": "B",
    "explanation": "Model klucz-wartość to najprostsza struktura w NoSQL, sprzyja wydajnym odczytom przez klucz.",
    "auto_id": 597
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Bazy relacyjne używają języka SQL, kluczy obcych i głównych, co ułatwia spójność i relacje między tabelami.",
      "B": "Bazy relacyjne nie dopuszczają użycia kluczy ani zapytań z warunkiem JOIN."
    },
    "correct": "A",
    "explanation": "Relacyjne DB (np. MySQL, PostgreSQL) bazują na SQL i relacjach (klucze główne/obce).",
    "auto_id": 598
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Normalizacja w bazach relacyjnych polega na duplikowaniu danych w wielu tabelach, by szybciej je odczytywać.",
      "B": "Normalizacja w bazach relacyjnych usuwa redundancje i dzieli tabelę na mniejsze, spójne struktury, zapobiegając anomaliom aktualizacji."
    },
    "correct": "B",
    "explanation": "Normalizacja ogranicza powielanie danych i eliminuje anomalie w aktualizacji, wstawianiu i usuwaniu.",
    "auto_id": 599
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Klucz obcy w relacyjnej bazie zawsze wskazuje sam na siebie, tworząc cykl w tej samej tabeli.",
      "B": "Klucz obcy łączy się z kluczem głównym innej (lub tej samej) tabeli, wymuszając spójność referencyjną."
    },
    "correct": "B",
    "explanation": "FOREIGN KEY wskazuje PK innej (lub ewentualnie tej samej) tabeli, utrzymując spójność danych.",
    "auto_id": 600
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Zagrożeniem w bazach danych jest np. SQL Injection, pozwalające atakującemu wstrzyknąć własne zapytania przez niezwalidowane wejścia.",
      "B": "Brak hasła do bazy danych jest bez znaczenia, bo silnik SQL zawsze wymusza autentykację."
    },
    "correct": "A",
    "explanation": "SQL Injection to główne zagrożenie, jeśli aplikacja nie waliduje lub nie używa parametrów w zapytaniach.",
    "auto_id": 601
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Brak kopii zapasowej bazy danych może prowadzić do nieodwracalnej utraty danych w razie awarii.",
      "B": "Brak kopii zapasowej zazwyczaj nie stanowi zagrożenia, bo zawsze można przywrócić dane z pamięci operacyjnej."
    },
    "correct": "A",
    "explanation": "Backupy są kluczowe, bo bez nich po awarii nie ma sposobu na odzyskanie danych produkcyjnych.",
    "auto_id": 602
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Hasła w bazie najlepiej trzymać w czystej postaci, by szybciej je zweryfikować.",
      "B": "Hasła w bazie powinny być hashowane (i solone), aby w razie wycieku uniemożliwić atakującemu poznanie haseł użytkowników."
    },
    "correct": "B",
    "explanation": "Przechowywanie haseł w formie hashowanej (i salted) chroni je nawet przy wycieku bazy.",
    "auto_id": 603
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Zagrożenia w systemach operacyjnych mogą wynikać z luk typu exploit, rootkit, czy braku aktualizacji zabezpieczeń.",
      "B": "System operacyjny nie wymaga żadnych poprawek, gdyż ma wbudowaną odporność na wszystkie exploit-y."
    },
    "correct": "A",
    "explanation": "System bez łatek jest narażony na różnorodne luki – exploit, rootkit, itd.",
    "auto_id": 604
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Rootkit to legalny pakiet sterowników, który poprawia wydajność systemu przez ukrywanie procesów.",
      "B": "Rootkit to złośliwe oprogramowanie ukrywające procesy lub pliki, umożliwiające atakującemu przejęcie kontroli w trybie administracyjnym."
    },
    "correct": "B",
    "explanation": "Rootkit jest złośliwy i maskuje swoją obecność, dając atakującemu szerokie uprawnienia.",
    "auto_id": 605
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Regularne aktualizacje systemu operacyjnego i używanie kont o ograniczonych uprawnieniach zmniejsza ryzyko przejęcia uprawnień root/Administrator.",
      "B": "Aktualizacje nie mają wpływu na bezpieczeństwo systemu, bo kluczowe są wyłącznie fizyczne zabezpieczenia CPU."
    },
    "correct": "A",
    "explanation": "Aktualizacje eliminują znane luki, a ograniczone konta utrudniają atakującemu eskalację uprawnień.",
    "auto_id": 606
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Zagrożeniem w sieciach komputerowych jest np. DDoS, który może przeciążyć serwer nadmiarem ruchu rozproszonego.",
      "B": "Atak DDoS polega na szyfrowaniu pakietów, co uniemożliwia dotarcie do serwera."
    },
    "correct": "A",
    "explanation": "DDoS (Distributed Denial of Service) przeciąża serwer wieloma jednoczesnymi żądaniami, uniemożliwiając normalną pracę.",
    "auto_id": 607
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Man-in-the-Middle (MitM) polega na wstrzyknięciu złośliwego kodu SQL do bazy danych bez udziału sieci.",
      "B": "MitM to przechwycenie komunikacji między dwiema stronami przez atakującego, umożliwiające podsłuch i modyfikację przesyłanych danych."
    },
    "correct": "B",
    "explanation": "MitM przechwytuje ruch sieciowy między dwiema stronami, często bez ich wiedzy.",
    "auto_id": 608
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Sniffing to podsłuchiwanie ruchu sieciowego, co może ujawnić hasła lub inne poufne dane, jeśli transmisja nie jest szyfrowana.",
      "B": "Sniffing polega wyłącznie na testach integracyjnych w modelu Waterfall."
    },
    "correct": "A",
    "explanation": "Sniffing (analizowanie pakietów sieciowych) pozwala atakującemu zobaczyć przesyłane dane w sieci, jeśli nie są szyfrowane.",
    "auto_id": 609
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Model TCP/IP posiada 7 warstw podobnych jak w OSI.",
      "B": "Model TCP/IP składa się z 4 warstw (aplikacji, transportu, internetu i dostępu do sieci), definiujących protokoły komunikacji w Internecie."
    },
    "correct": "B",
    "explanation": "TCP/IP jest czterowarstwowy, w odróżnieniu od 7-warstwowego modelu OSI.",
    "auto_id": 610
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "UDP zapewnia gwarantowaną dostawę pakietów w odpowiedniej kolejności.",
      "B": "TCP zapewnia niezawodną, strumieniową komunikację, weryfikując kolejność i brak duplikatów."
    },
    "correct": "B",
    "explanation": "UDP jest bezpołączeniowe i nie gwarantuje kolejności, a TCP to protokół niezawodny ze sterowaniem przepływem.",
    "auto_id": 611
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Warstwa aplikacji w TCP/IP to np. protokoły HTTP, FTP, SMTP, pozwalające usługom działać nad warstwą transportową.",
      "B": "Warstwa aplikacji w TCP/IP obejmuje wyłącznie IP i ARP."
    },
    "correct": "A",
    "explanation": "Protokół IP i ARP należą do warstwy internetowej, a HTTP, FTP do warstwy aplikacji.",
    "auto_id": 612
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "ERD (Entity-Relationship Diagram) prezentuje przepływ sterowania i decyzji w aplikacji.",
      "B": "ERD ukazuje encje (tabele) i relacje między nimi (1:1, 1:N, M:N), służąc do projektowania bazy danych."
    },
    "correct": "B",
    "explanation": "ERD przedstawia struktury danych i ich wzajemne relacje, zwykle w bazach relacyjnych.",
    "auto_id": 613
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Relacja N:M w ERD oznacza, że jeden rekord w tabeli A może być powiązany z wieloma rekordami w B, i na odwrót.",
      "B": "Relacja N:M to synonim relacji 1:1 z redundancją kluczy."
    },
    "correct": "A",
    "explanation": "W N:M rekord w A może mieć wiele powiązań w B, a rekord w B może mieć wiele powiązań w A.",
    "auto_id": 614
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Encja w ERD nie może posiadać klucza głównego, bo to opis nieformalny.",
      "B": "Encja w ERD zwykle ma klucz główny (np. id) i atrybuty opisujące dane obiektu, a relacje łączą encje ze sobą."
    },
    "correct": "B",
    "explanation": "W ERD każda encja ma klucz główny, co identyfikuje każdy rekord. Relacje łączą encje.",
    "auto_id": 615
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Wymagania funkcjonalne określają, co system powinien robić (np. rejestracja), a niefunkcjonalne opisują cechy, np. wydajność.",
      "B": "Wymagania niefunkcjonalne opisują kluczowe funkcje systemu, takie jak logowanie czy zapis danych."
    },
    "correct": "A",
    "explanation": "Funkcjonalne – zadania systemu, niefunkcjonalne – jakość, wydajność, bezpieczeństwo itp.",
    "auto_id": 616
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Wymaganie o dostępności 24/7 to przykład wymagań niefunkcjonalnych (dot. jakości/systemu),",
      "B": "Wymaganie o dostępności 24/7 jest funkcjonalne, bo mówi, jaką funkcję system oferuje w relacji z użytkownikiem."
    },
    "correct": "A",
    "explanation": "Dostępność 24/7 odnosi się do cechy systemu (wymaganie niefunkcjonalne).",
    "auto_id": 617
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Wymagania funkcjonalne dotyczą budżetu i terminu, co jest kluczowe dla marketingu.",
      "B": "Wymagania funkcjonalne określają konkretne działania (use cases), np. 'Użytkownik może wyszukać produkt po nazwie'."
    },
    "correct": "B",
    "explanation": "Funkcjonalne zawsze mówią o faktycznych funkcjach i zadaniach, jakie system ma spełnić.",
    "auto_id": 618
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Aplikacja mobilna zwykle łączy się z bazą bezpośrednio, aby uzyskać dane (port 3306).",
      "B": "Aplikacja mobilna często komunikuje się z bazą poprzez warstwę backend (REST, GraphQL), nie mając bezpośredniego dostępu do portu bazy."
    },
    "correct": "B",
    "explanation": "Zazwyczaj aplikacja mobilna korzysta z API wystawionego przez serwer, zamiast łączyć się bezpośrednio z bazą.",
    "auto_id": 619
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Backend nie powinien walidować danych z aplikacji mobilnej, gdyż i tak trafiają one prosto do bazy.",
      "B": "Backend powinien walidować dane (np. z aplikacji mobilnej), zanim zapisze je do bazy, by uniknąć błędów i ataków typu injection."
    },
    "correct": "B",
    "explanation": "Zabezpieczenie i walidacja danych w warstwie backend to klucz, by nie wpuścić nieprawidłowych lub złośliwych danych do bazy.",
    "auto_id": 620
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W architekturze mobilna app → baza SQL, user musi znać hasło do bazy, co jest dobrym podejściem.",
      "B": "Zwykle aplikacja mobilna loguje się do API, a serwer jest jedynym podmiotem znającym dane uwierzytelniające do bazy."
    },
    "correct": "B",
    "explanation": "Tylko serwer (backend) powinien mieć poświadczenia do bazy. Aplikacja mobilna używa mechanizmów autoryzacji w warstwie API.",
    "auto_id": 621
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Klucz obcy (FOREIGN KEY) w tabeli zawsze jest identyczny z kluczem głównym w tej samej tabeli.",
      "B": "Klucz obcy odnosi się do kolumny (zwykle klucza głównego) w innej tabeli, zapewniając spójność referencyjną."
    },
    "correct": "B",
    "explanation": "Klucz obcy wskazuje najczęściej PK w innej tabeli, gwarantując wiązanie i spójność między rekordami.",
    "auto_id": 622
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Złożony klucz główny (Composite Key) to kilka kolumn razem tworzących unikalny identyfikator wiersza.",
      "B": "Złożony klucz główny wymaga, by kolumny były zawsze identyczne i trzymały duplikaty dla spójności."
    },
    "correct": "A",
    "explanation": "Composite Key łączy co najmniej dwie kolumny, których kombinacja jednoznacznie identyfikuje rekord.",
    "auto_id": 623
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "ON DELETE CASCADE w kluczu obcym kasuje powiązane rekordy w tabeli podrzędnej, gdy usuwamy rekord nadrzędny.",
      "B": "ON DELETE CASCADE blokuje usunięcie rekordu nadrzędnego, jeśli istnieją zależne rekordy."
    },
    "correct": "A",
    "explanation": "CASCADE usuwa zależne wiersze. Natomiast RESTRICT/NO ACTION blokuje usunięcie, jeśli istnieją powiązania.",
    "auto_id": 624
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "INNER JOIN zwraca rekordy tylko wtedy, gdy istnieje dopasowanie w obu tabelach.",
      "B": "INNER JOIN zwraca wszystkie rekordy z lewej tabeli, nawet jeśli brak dopasowania w prawej."
    },
    "correct": "A",
    "explanation": "INNER JOIN wymaga zgodności warunku łączenia w obu tabelach. Bez dopasowania rekord nie trafia do wyniku.",
    "auto_id": 625
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "LEFT JOIN zwraca rekordy z lewej tabeli i dopasowania z prawej, a jeśli brak dopasowania – wartości z prawej są NULL.",
      "B": "LEFT JOIN usuwa wszystkie rekordy lewej tabeli, gdy nie ma pasującego wiersza w prawej."
    },
    "correct": "A",
    "explanation": "LEFT JOIN zawsze zwraca wszystkie rekordy z lewej tabeli; niedopasowane pola z prawej stają się NULL.",
    "auto_id": 626
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "FULL OUTER JOIN łączy wyłącznie wspólne rekordy z obu tabel, ignorując brakujące dopasowania.",
      "B": "FULL OUTER JOIN zwraca komplet rekordów z obu tabel, również te nieposiadające pasującego wiersza po drugiej stronie."
    },
    "correct": "B",
    "explanation": "FULL OUTER JOIN łączy i dopasowane, i niepasujące rekordy z lewej i prawej tabeli.",
    "auto_id": 627
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Responsywność oznacza, że strona zawsze ma stałą szerokość w pikselach dla zachowania spójnego layoutu.",
      "B": "Responsywność to zdolność do adaptacji układu i stylów strony w zależności od rozdzielczości i urządzenia."
    },
    "correct": "B",
    "explanation": "Strona responsywna dopasowuje się do różnych rozmiarów ekranu i orientacji.",
    "auto_id": 628
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W CSS media queries pozwalają definiować odrębne style w zależności od szerokości/rozdzielczości ekranu.",
      "B": "Media queries wyłącznie definiują efekty cieni w parametrach box-shadow."
    },
    "correct": "A",
    "explanation": "Media queries to klucz do warunkowego stylowania w CSS w zależności od cech urządzenia.",
    "auto_id": 629
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Bez meta viewport przeglądarka na telefonie często wyświetla stronę w trybie 'desktop scaled', co utrudnia obsługę dotykiem.",
      "B": "Meta viewport nie ma wpływu na prezentację w urządzeniach mobilnych, jest jedynie komentarzem."
    },
    "correct": "A",
    "explanation": "Ustawienie meta viewport (width=device-width) jest kluczowe, by strona nie była renderowana w trybie desktop.",
    "auto_id": 630
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Planista CPU w systemie operacyjnym decyduje, który proces (lub wątek) otrzyma czas procesora, bazując na priorytetach i algorytmach (np. RR).",
      "B": "Planista CPU umożliwia jedynie wybór między dwoma procesami, jeśli nie ma w systemie semaforów."
    },
    "correct": "A",
    "explanation": "Planista (scheduler) przydziela zasoby procesora procesom/wątkom zależnie od reguł priorytetów, kwantu czasu itd.",
    "auto_id": 631
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Przełączanie kontekstu (context switch) zapisuje stan aktualnego procesu i wczytuje stan kolejnego, aby CPU mógł wykonywać wiele procesów współbieżnie.",
      "B": "Przełączanie kontekstu wyłącznie zmienia priorytet systemu plików w dysku, nie wpływając na stan procesu."
    },
    "correct": "A",
    "explanation": "W context switch OS zapisuje rejestry i stan procesu, a następnie ładuje stan innego procesu do CPU.",
    "auto_id": 632
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Deadlock polega na tym, że procesy równolegle wykonują zadania i kończą się szybciej.",
      "B": "Deadlock to sytuacja, w której procesy/wątki wzajemnie czekają na zasoby, nie mogąc ruszyć dalej."
    },
    "correct": "B",
    "explanation": "Deadlock pojawia się, gdy procesy blokują się nawzajem, oczekując na zwolnienie zasobu.",
    "auto_id": 633
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Zarządzanie użytkownikami w systemie OS polega na przydzielaniu czy też ograniczaniu dostępu do zasobów (pliki, urządzenia, operacje).",
      "B": "Zarządzanie użytkownikami oznacza wyłącznie automatyczne generowanie kluczy par SSH co godzinę."
    },
    "correct": "A",
    "explanation": "Zarządzanie użytkownikami obejmuje tworzenie kont, uprawnień, grup i ograniczania dostępu do zasobów.",
    "auto_id": 634
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W systemie Linux plik /etc/shadow przechowuje zaszyfrowane hasła użytkowników z ograniczonym dostępem, a /etc/passwd jest publiczny i zawiera podstawowe dane kont.",
      "B": "W systemie Linux /etc/passwd trzyma zaszyfrowane hasła, a /etc/shadow jest jawne i odczytywane przez wszystkich."
    },
    "correct": "A",
    "explanation": "Plik /etc/shadow jest dostępny tylko dla roota (trzyma hasła), a /etc/passwd jest jawny i zawiera UID, shell itp.",
    "auto_id": 635
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Użycie sudo pozwala wybranym użytkownikom wykonywać wybrane polecenia z uprawnieniami roota, bez ujawniania hasła roota.",
      "B": "Użycie sudo oznacza dostęp do wszystkich plików .env w trybie read-only z poziomu konta guest."
    },
    "correct": "A",
    "explanation": "sudo pozwala tymczasowo podnieść uprawnienia do roota, jeśli użytkownik ma zgodę w pliku sudoers, bez znajomości hasła roota.",
    "auto_id": 636
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Sieć bezprzewodowa (Wi-Fi) nie wymaga szyfrowania, ponieważ sygnały radiowe nie mogą być przechwycone poza pomieszczeniem.",
      "B": "Sieć bezprzewodowa jest podatna na przechwycenie sygnału, więc WPA2/WPA3 jest istotne, by chronić dane przed podsłuchem."
    },
    "correct": "B",
    "explanation": "Wi-Fi można łatwo podsłuchać, więc szyfrowanie WPA2/WPA3 jest konieczne do bezpieczeństwa.",
    "auto_id": 637
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "WPA2-PSK to metoda uwierzytelniania w sieci Wi-Fi z hasłem udostępnianym wszystkim użytkownikom, zapewniająca szyfrowanie danych.",
      "B": "WPA2-PSK nie szyfruje żadnego ruchu, wymaga jedynie potwierdzenia klucza w trybie plain text."
    },
    "correct": "A",
    "explanation": "WPA2-PSK to szyfrowana sieć Wi-Fi z kluczem wstępnym udostępnianym użytkownikom (Pre-Shared Key).",
    "auto_id": 638
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Zmiana kanału w Wi-Fi 2,4 GHz może zredukować zakłócenia, zwłaszcza gdy sąsiednie sieci pracują na tym samym kanale.",
      "B": "Nie da się zmienić kanału w 2,4 GHz, bo jest on na stałe przypisany do routera i regulatorów pasma."
    },
    "correct": "A",
    "explanation": "W 2,4 GHz można wybrać kanał (np. 1,6,11), unikając kolizji z sieciami w pobliżu.",
    "auto_id": 639
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Frontend w architekturze web to warstwa serwerowa, która łączy się z bazą danych.",
      "B": "Frontend jest uruchamiany w przeglądarce użytkownika (HTML, CSS, JS) i komunikuje się z backendem po stronie serwera."
    },
    "correct": "B",
    "explanation": "Frontend to część klienta (UI), a backend działa na serwerze, obsługuje logikę i bazę.",
    "auto_id": 640
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Backend (np. Node.js, PHP) zwykle odpowiada za logikę, operacje na bazie i wystawianie API, a frontend wyświetla interfejs.",
      "B": "Backend jest pakietem stylów CSS do upiększania interfejsu, a frontend to system baz danych."
    },
    "correct": "A",
    "explanation": "Backend implementuje logikę biznesową i zarządza danymi, a frontend dostarcza UI w przeglądarce.",
    "auto_id": 641
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W architekturze frontend-backend, klient (przeglądarka) wysyła żądania HTTP do serwera, który przetwarza i zwraca odpowiedź.",
      "B": "W architekturze frontend-backend zwykle to baza danych sama generuje widok HTML i przekazuje go do przeglądarki."
    },
    "correct": "A",
    "explanation": "Przeglądarka (frontend) komunikuje się z serwerem (backend) przez HTTP. Baza z reguły nie generuje bezpośrednio widoków HTML.",
    "auto_id": 642
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Architektura trójwarstwowa: prezentacja (UI), logika (biznesowa) i dane (baza). Każda warstwa ma swoją rolę i można je rozwijać/skalować niezależnie.",
      "B": "Architektura trójwarstwowa łączy UI, logikę i bazę w jednym monolicie, eliminując potrzebę separacji."
    },
    "correct": "A",
    "explanation": "Trójwarstwowość dzieli system na UI, logikę i warstwę danych, co daje modularność i ułatwia utrzymanie.",
    "auto_id": 643
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Warstwa prezentacji steruje też transakcjami i replikacją w bazie, by zapewnić spójność zapisu.",
      "B": "Warstwa logiki biznesowej decyduje o przepływie operacji i walidacji, a warstwa danych zajmuje się fizycznym przechowywaniem i transakcjami."
    },
    "correct": "B",
    "explanation": "Warstwa biznesowa implementuje reguły i przepływy, a warstwa danych dba o przechowywanie, transakcje i indeksy.",
    "auto_id": 644
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "W architekturze trójwarstwowej kod frontu, logiki i bazy jest w jednym pliku .php.",
      "B": "W architekturze trójwarstwowej UI (np. React) jest oddzielony od serwisu (np. Java/Python) i bazy (SQL/NoSQL)."
    },
    "correct": "B",
    "explanation": "Każda warstwa może być utrzymywana osobno, a komunikacja jest odseparowana interfejsami/endpointami.",
    "auto_id": 645
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Web scraping to pobieranie danych bezpośrednio z bazy, jeśli mamy hasło do systemu produkcyjnego.",
      "B": "Web scraping to automatyczne pozyskiwanie zawartości stron internetowych (HTML) i ekstrakcja danych, np. gdy brak API."
    },
    "correct": "B",
    "explanation": "Scraping pobiera dane z kodu strony, często potrzebny, gdy nie ma dostępu do API.",
    "auto_id": 646
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Crowdsourcing danych polega na udziale społeczności w dostarczaniu informacji (np. ankiety, wiki), co umożliwia zbieranie dużej ilości danych.",
      "B": "Crowdsourcing ogranicza się do analizy logów systemowych w trybie offline."
    },
    "correct": "A",
    "explanation": "Crowdsourcing angażuje użytkowników/społeczność w dostarczanie informacji – np. Wikipedia, ankiety.",
    "auto_id": 647
  },
  {
    "type": "simple_select",
    "question": "Które stwierdzenie jest prawdziwe?",
    "options": {
      "A": "Pozyskiwanie danych z plików logów serwera może dać informacje o aktywności użytkowników, ale nie jest to metoda gromadzenia danych.",
      "B": "Pozyskiwanie danych z logów to jedna z typowych metod zbierania informacji (np. o ruchu), które mogą zostać poddane analizie w BI czy Big Data."
    },
    "correct": "B",
    "explanation": "Logi serwera to ważne źródło danych o działaniach użytkowników i wydajności – cenne w procesach analitycznych.",
    "auto_id": 648
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód przeprowadzenia szczegółowej analizy wymagań na początku projektu?",
    "options": {
      "A": "Ponieważ umożliwia to zrozumienie oczekiwań i ograniczeń, co pozwala zaplanować odpowiednie rozwiązania już na wczesnym etapie.",
      "B": "Ponieważ dokumentacja wymagań jest formalnością, która nie ma wpływu na dalszy przebieg projektu.",
      "C": "Ponieważ dzięki temu można od razu rozpocząć programowanie bez marnowania czasu na planowanie."
    },
    "correct": "A",
    "explanation": "Szczegółowa analiza wymagań na początku projektu pozwala zrozumieć, co należy zbudować i jakie są ograniczenia. Dzięki temu projektanci mogą opracować rozwiązanie spełniające realne potrzeby i uniknąć kosztownych zmian na późniejszych etapach.",
    "auto_id": 649
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód wyboru danego języka programowania do implementacji systemu?",
    "options": {
      "A": "Ponieważ wybrany język oferuje biblioteki i funkcje potrzebne do realizacji wymagań projektu, co przyspiesza i ułatwia implementację.",
      "B": "Ponieważ wybrany język jest najnowszy na rynku, mimo że zespół nie ma w nim doświadczenia.",
      "C": "Ponieważ w tym języku każdy program działa szybciej niż w jakimkolwiek innym, niezależnie od kontekstu."
    },
    "correct": "A",
    "explanation": "Język programowania wybrano ze względu na dopasowanie do potrzeb projektu – np. dostępność odpowiednich bibliotek, wydajność wystarczająca dla zadania i znajomość technologii przez zespół. Najnowszy język lub mityczna uniwersalna szybkość nie są uzasadnionymi powodami, jeśli nie przekładają się na realizację wymagań.",
    "auto_id": 650
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zastosowania architektury warstwowej w projekcie?",
    "options": {
      "A": "Ponieważ architektura warstwowa wymusza podział systemu na części o odrębnych odpowiedzialnościach, co ułatwia modyfikacje i utrzymanie kodu.",
      "B": "Ponieważ architektura warstwowa pozwala na napisanie całego kodu w jednej warstwie, co znacznie upraszcza strukturę projektu.",
      "C": "Ponieważ architektura warstwowa gwarantuje, że system będzie działał szybciej dzięki dodatkowemu podziałowi logicznemu."
    },
    "correct": "A",
    "explanation": "Architektura warstwowa służy rozdzieleniu odpowiedzialności (np. prezentacja, logika biznesowa, dostęp do danych), co poprawia czytelność i ułatwia rozwój systemu. Dzięki temu zmiany w jednej warstwie nie wpływają bezpośrednio na inne. Nie jest ona stosowana po to, by uprościć kod przez umieszczenie go w jednej warstwie (co jest sprzeczne z jej założeniami) ani bezpośrednio przyspieszyć działanie systemu (chodzi głównie o organizację, nie wydajność).",
    "auto_id": 651
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód wyboru relacyjnej bazy danych do przechowywania danych aplikacji?",
    "options": {
      "A": "Ponieważ dane mają ustrukturyzowany charakter i wymagane są złożone zapytania oraz transakcje, co relacyjna baza danych obsługuje efektywnie zapewniając spójność danych.",
      "B": "Ponieważ relacyjne bazy danych nigdy nie wymagają optymalizacji ani zmian schematu podczas rozwoju systemu.",
      "C": "Ponieważ relacyjna baza danych automatycznie zamienia nieustrukturyzowane dane w uporządkowane tabele bez pracy ze strony projektanta."
    },
    "correct": "A",
    "explanation": "Relacyjna baza danych została wybrana, gdyż dane aplikacji były silnie powiązane i należało zapewnić ich spójność oraz możliwość wykonywania skomplikowanych zapytań i transakcji. Relacyjne bazy dobrze radzą sobie z takimi wymaganiami. Nie jest prawdą, że nigdy nie wymagają zmian czy optymalizacji – schemat może ewoluować wraz z projektem. Również sama baza nie porządkuje automatycznie chaotycznych danych bez odpowiedniego zaprojektowania modelu.",
    "auto_id": 652
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód normalizacji schematu bazy danych do postaci 3NF (trzeciej postaci normalnej)?",
    "options": {
      "A": "Ponieważ normalizacja redukuje redundancję danych i zapobiega anomaliom modyfikacji, dzięki czemu dane pozostają spójne i niepowtarzające się.",
      "B": "Ponieważ zdenormalizowane bazy danych są zawsze wolniejsze i nigdy nie sprawdzają się w praktyce.",
      "C": "Ponieważ 3NF jest wymagane przez wszystkie systemy baz danych i bez niej baza nie zadziała."
    },
    "correct": "A",
    "explanation": "Normalizacja do trzeciej postaci normalnej eliminuje nadmiarowe powielanie danych i zabezpiecza przed niejednoznacznością czy anomaliami podczas operacji dodawania, usuwania czy aktualizacji. Dzięki temu utrzymanie integralności danych jest łatwiejsze. Nie jest prawdą, że zdenormalizowane bazy zawsze zawodzą – czasem świadomie się je stosuje dla wydajności. Również nie ma obowiązku stosowania 3NF w każdym systemie – to projektant decyduje, co jest potrzebne.",
    "auto_id": 653
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zastosowania algorytmu wyszukiwania binarnego do przeszukiwania zbioru danych?",
    "options": {
      "A": "Ponieważ przy założeniu posortowanych danych algorytm binarny znacznie skraca czas wyszukiwania (logarytmiczna złożoność) w porównaniu do przeszukiwania liniowego.",
      "B": "Ponieważ algorytm binarny jest łatwiejszy do zaimplementowania niż proste przeszukiwanie liniowe nieposortowanych danych.",
      "C": "Ponieważ wyszukiwanie binarne gwarantuje znalezienie elementu nawet jeśli nie istnieje on w zbiorze danych."
    },
    "correct": "A",
    "explanation": "Wyszukiwanie binarne na posortowanym zbiorze jest bardzo wydajne – liczba porównań rośnie logarytmicznie wraz z rozmiarem danych, co jest znacznie lepsze niż liniowy wzrost przy przeszukiwaniu prostym. Nie jest ono prostsze w implementacji od iteracyjnego przeszukiwania całości, ale jest szybsze, pod warunkiem posortowania danych. Oczywiście, jeśli szukanego elementu nie ma, algorytm binarny go nie znajdzie – po prostu zakończy bez sukcesu.",
    "auto_id": 654
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód wyboru tablicy (ciągłego obszaru w pamięci) zamiast listy połączonej do przechowywania elementów w tym projekcie?",
    "options": {
      "A": "Ponieważ tablica umożliwia bezpośredni dostęp do elementów po indeksie i lepsze wykorzystanie pamięci podręcznej, co przekłada się na szybsze operacje odczytu przy znanej z góry wielkości danych.",
      "B": "Ponieważ tablice nigdy nie zużywają całej dostępnej pamięci, w przeciwieństwie do list połączonych.",
      "C": "Ponieważ tablica automatycznie dopasowuje swój rozmiar do liczby elementów, co eliminuje konieczność zarządzania pamięcią."
    },
    "correct": "A",
    "explanation": "Tablica (ciągły blok pamięci) została wybrana, gdyż w projekcie znana była z grubsza liczba elementów i ważny był szybki dostęp do danych po indeksie. Tablice korzystają z ciągłości pamięci, co sprzyja wykorzystaniu cache i zwiększa wydajność odczytu. Listy połączone mają inne zalety (np. łatwe wstawianie), ale wolniejszy dostęp sekwencyjny. Stwierdzenie, że tablice nigdy nie zużywają całej pamięci, jest bezpodstawne – mogą zająć dużo pamięci zależnie od rozmiaru. Tablice również nie zmieniają automatycznie rozmiaru – za to odpowiadają inne struktury, jak np. dynamiczne listy w bibliotekach.",
    "auto_id": 655
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zastosowania wzorca projektowego Singleton dla modułu konfiguracji w aplikacji?",
    "options": {
      "A": "Ponieważ Singleton zapewnia istnienie tylko jednej instancji modułu konfiguracji w całym programie, co zapobiega rozbieżnościom i konfliktom w ustawieniach.",
      "B": "Ponieważ Singleton znacząco przyspiesza działanie programu poprzez ograniczenie liczby obiektów tworzonych w systemie.",
      "C": "Ponieważ użycie Singletona jest wymagane we wszystkich projektach obiektowych niezależnie od ich specyfiki."
    },
    "correct": "A",
    "explanation": "Wzorzec Singleton zastosowano, aby zagwarantować jedną spójną instancję konfiguracji dostępnej globalnie. Dzięki temu wszystkie części aplikacji odwołują się do tych samych ustawień, eliminując problem potencjalnie sprzecznych konfiguracji. Singleton nie jest wymagany zawsze, ani nie służy do przyspieszania działania (chodzi raczej o ograniczenie liczby instancji niż optymalizację wydajności).",
    "auto_id": 656
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód napisania testów jednostkowych dla krytycznych komponentów projektu?",
    "options": {
      "A": "Ponieważ testy jednostkowe pozwalają wychwycić błędy na wczesnym etapie i upewnić się, że poszczególne części aplikacji działają zgodnie z założeniami przed integracją.",
      "B": "Ponieważ testy jednostkowe automatycznie poprawiają błędy w kodzie, dzięki czemu programista nie musi tego robić ręcznie.",
      "C": "Ponieważ testy jednostkowe zastępują potrzebę testów integracyjnych i systemowych, co pozwala zaoszczędzić czas."
    },
    "correct": "A",
    "explanation": "Testy jednostkowe weryfikują poprawność działania poszczególnych modułów kodu. Pozwalają wykryć i naprawić błędy już na etapie implementacji modułów, zanim zostaną one połączone w całość. Nie naprawiają one błędów automatycznie – wskazują jedynie, gdzie coś nie działa zgodnie z oczekiwaniem. Nie zastępują też w pełni testów wyższego poziomu (integracyjnych, systemowych), ale je uzupełniają.",
    "auto_id": 657
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód korzystania z systemu kontroli wersji (np. Gita) podczas tworzenia oprogramowania?",
    "options": {
      "A": "Ponieważ system kontroli wersji umożliwia śledzenie zmian w kodzie, współpracę wielu programistów i bezpieczny powrót do poprzednich wersji w razie problemów.",
      "B": "Ponieważ kontrola wersji automatycznie pisze za programistów kod, gdy ci popełnią błąd.",
      "C": "Ponieważ korzystanie z kontroli wersji jest wymagane tylko w dużych projektach, a w małych nie ma żadnych zalet."
    },
    "correct": "A",
    "explanation": "System kontroli wersji (taki jak Git) pozwala utrzymywać historię zmian, co jest kluczowe przy pracy zespołowej i złożonych projektach. Dzięki niemu można łączyć zmiany wielu osób, rozwiązywać konflikty i w razie potrzeby cofnąć się do poprzedniego stanu. Nie generuje kodu sam z siebie ani nie jest zarezerwowany wyłącznie dla dużych projektów – także w małych projektach chroni przed utratą pracy i pomaga w organizacji zmian.",
    "auto_id": 658
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód wybrania podejścia Agile do zarządzania realizacją projektu programistycznego?",
    "options": {
      "A": "Ponieważ Agile umożliwia częste korygowanie kierunku prac na podstawie informacji zwrotnej i zmian w wymaganiach, co zwiększa szanse dostarczenia produktu spełniającego oczekiwania.",
      "B": "Ponieważ Agile wymaga tworzenia bardzo rozbudowanej dokumentacji przed rozpoczęciem prac, co minimalizuje ryzyko błędów.",
      "C": "Ponieważ Agile eliminuje potrzebę jakiegokolwiek planowania i umożliwia całkowicie improwizowane prowadzenie projektu."
    },
    "correct": "A",
    "explanation": "Agile (np. metodyka Scrum) zakłada iteracyjne dostarczanie oprogramowania i częste przeglądy postępów. Dzięki temu zespół może szybko reagować na zmiany i uwagi klienta. Celem jest dopasowanie produktu do potrzeb poprzez stopniowe doskonalenie. Agile nie polega na stworzeniu ogromnej dokumentacji na starcie (to cechuje raczej model waterfall) ani na braku planu – plan istnieje, ale jest elastyczny i dostosowywany w trakcie projektu.",
    "auto_id": 659
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód szyfrowania danych przesyłanych między klientem a serwerem w systemie?",
    "options": {
      "A": "Ponieważ szyfrowanie chroni wrażliwe dane przed podejrzeniem lub modyfikacją przez osoby trzecie podczas transmisji, zapewniając poufność i integralność komunikacji.",
      "B": "Ponieważ szyfrowanie znacznie zwiększa szybkość transmisji danych dzięki dodatkowej warstwie przetwarzania.",
      "C": "Ponieważ bez szyfrowania żadne dane nie mogą zostać zapisane w bazie danych po stronie serwera."
    },
    "correct": "A",
    "explanation": "Szyfrowanie danych w trakcie transmisji (np. poprzez protokół HTTPS) zapewnia, że informacje takie jak hasła czy dane osobowe nie będą przechwycone lub zmienione przez osoby niepowołane. Chodzi o bezpieczeństwo komunikacji. Szyfrowanie wprowadza pewien narzut, więc nie przyspiesza transmisji – raczej ją nieznacznie obciąża. Brak szyfrowania nie uniemożliwia zapisu danych w bazie, ale naraża je na przechwycenie w drodze.",
    "auto_id": 660
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód utrzymania interfejsu użytkownika w aplikacji w formie minimalistycznej z ograniczoną liczbą funkcji w pierwszej wersji?",
    "options": {
      "A": "Ponieważ skupienie się na kluczowych funkcjach i prostocie interfejsu ułatwia użytkownikom naukę obsługi oraz pozwala szybciej zebrać opinie o najważniejszych elementach aplikacji.",
      "B": "Ponieważ minimalistyczny interfejs oznacza, że aplikacja ma mniej możliwości, więc jest mniej użyteczna dla użytkowników.",
      "C": "Ponieważ takie podejście pozwala twórcom uniknąć pracy nad dodatkowymi funkcjami, nawet jeśli byłyby istotne dla użytkowników."
    },
    "correct": "A",
    "explanation": "Decyzja o prostym, minimalistycznym interfejsie w początkowej wersji wynika z chęci dostarczenia użytkownikom najważniejszych funkcji w czytelnej formie. Ułatwia to testowanie koncepcji i zbieranie opinii, co można wykorzystać do dalszego rozwoju. Nie chodzi o ograniczenie użyteczności, lecz o skupienie się na rdzeniu aplikacji. Unikanie implementacji istotnych funkcji nie jest celem – kluczowe funkcje są zawarte, a mniej ważne mogą poczekać do kolejnych wersji.",
    "auto_id": 661
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zaprojektowania serwera do obsługi zadań w sposób asynchroniczny zamiast synchronicznego?",
    "options": {
      "A": "Ponieważ podejście asynchroniczne pozwala serwerowi obsługiwać wiele żądań jednocześnie bez czekania na zakończenie pojedynczych operacji, co zwiększa wydajność i przepustowość systemu.",
      "B": "Ponieważ asynchroniczność sprawia, że kod jest prostszy do zrozumienia i debugowania w porównaniu z kodem synchronicznym.",
      "C": "Ponieważ serwer synchroniczny nie jest w stanie obsłużyć więcej niż jednego użytkownika w tym samym czasie na żadnym sprzęcie."
    },
    "correct": "A",
    "explanation": "Architektura asynchroniczna (np. z wykorzystaniem nieblokujących operacji wejścia/wyjścia lub mechanizmów typu event loop) pozwala na obsługę wielu zadań równocześnie. Serwer nie blokuje się na oczekiwaniu np. na zapis do bazy czy odpowiedź z API, tylko przełącza się do obsługi kolejnych zdarzeń. Dzięki temu rośnie efektywność obsługi ruchu. Kod asynchroniczny bywa trudniejszy do debugowania, więc nie to jest powodem wyboru, a serwer synchroniczny może obsługiwać wielu użytkowników (np. poprzez wiele wątków), ale asynchroniczność robi to efektywniej pod pewnymi względami.",
    "auto_id": 662
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zaimplementowania rygorystycznej walidacji danych wejściowych od użytkownika w aplikacji?",
    "options": {
      "A": "Ponieważ walidacja wejścia zapobiega wprowadzaniu niepoprawnych lub złośliwych danych, które mogłyby spowodować błędy w działaniu systemu lub luki bezpieczeństwa.",
      "B": "Ponieważ walidacja umożliwia użytkownikom wprowadzanie dowolnych danych bez żadnych ograniczeń, co czyni system bardziej elastycznym.",
      "C": "Ponieważ dzięki walidacji program automatycznie naprawia wpisane przez użytkownika błędne dane, odciążając go od myślenia."
    },
    "correct": "A",
    "explanation": "Walidacja danych wejściowych jest kluczowa dla bezpieczeństwa i poprawności działania aplikacji. Dzięki niej nieprawidłowe dane (np. z literówkami, błędnym formatem czy zawierające szkodliwy kod) są odrzucane lub korygowane zanim zaszkodzą systemowi (np. powodując wyjątek czy podatność na SQL Injection). Nie chodzi o pozwolenie na dowolność – wręcz przeciwnie, nakłada się ograniczenia, by chronić system i użytkownika. Walidacja również nie oznacza automatycznej poprawy wszystkich błędów za użytkownika, a raczej wychwycenie ich i przekazanie informacji zwrotnej.",
    "auto_id": 663
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód podzielenia systemu na odrębne moduły z jasno zdefiniowanymi interfejsami?",
    "options": {
      "A": "Ponieważ modularna budowa systemu ułatwia równoległe prace nad poszczególnymi częściami, testowanie i przyszłe modyfikacje, ograniczając wpływ zmian w jednym module na resztę systemu.",
      "B": "Ponieważ modułowa architektura wymaga pisania całego kodu od początku dla każdego modułu, co zapewnia brak powtórzeń w systemie.",
      "C": "Ponieważ podział na moduły automatycznie przyspiesza działanie programu dzięki dodatkowym warstwom abstrakcji."
    },
    "correct": "A",
    "explanation": "Wyodrębnienie odrębnych modułów (komponentów) z określonymi interfejsami sprawia, że zespół może pracować nad nimi niezależnie, a każdą część można testować oddzielnie. Zmiana wewnątrz modułu mniej wpływa na inne części, jeśli interfejs pozostaje zgodny. To poprawia utrzymanie i skalowalność zespołu. Nie chodzi o pisanie wszystkiego od nowa (raczej o unikanie duplikacji przez wykorzystanie modułów wielokrotnie) ani o przyspieszenie programu przez warstwy abstrakcji – te służą organizacji, nie bezpośrednio wydajności.",
    "auto_id": 664
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zastosowania wstrzykiwania zależności (Dependency Injection) w projekcie?",
    "options": {
      "A": "Ponieważ wstrzykiwanie zależności ułatwia wymianę komponentów i testowanie przez usunięcie bezpośrednich powiązań między klasami, co zwiększa elastyczność i modularność kodu.",
      "B": "Ponieważ dzięki wstrzykiwaniu zależności program nigdy nie będzie wymagał aktualizacji bibliotek zewnętrznych.",
      "C": "Ponieważ wstrzykiwanie zależności sprawia, że każda klasa może samodzielnie tworzyć swoje zależności bez potrzeby konfiguracji."
    },
    "correct": "A",
    "explanation": "Dependency Injection polega na przekazywaniu zależności do obiektów z zewnątrz, zamiast tworzenia ich wewnątrz klasy. To ułatwia podmienianie implementacji (np. w testach można wstrzyknąć zamienniki) i zmniejsza powiązanie między komponentami. W efekcie kod jest bardziej elastyczny i łatwiejszy do utrzymania. Nie ma to bezpośredniego wpływu na konieczność aktualizacji bibliotek zewnętrznych, a wręcz DI zakłada, że klasy nie tworzą same swoich zależności (to jest odwrotność DI).",
    "auto_id": 665
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód preferowania algorytmu działającego w czasie wielomianowym nad algorytmem wykładniczym dla rozwiązania danego problemu?",
    "options": {
      "A": "Ponieważ algorytm wielomianowy zapewnia rozwiązanie w rozsądnym czasie nawet dla większych danych, podczas gdy algorytm o złożoności wykładniczej staje się praktycznie nieużyteczny już dla średnich rozmiarów problemu.",
      "B": "Ponieważ algorytm wykładniczy zazwyczaj daje przybliżone wyniki, a algorytm wielomianowy zawsze wyniki dokładne.",
      "C": "Ponieważ algorytmy wielomianowe są łatwiejsze do zrozumienia niż algorytmy wykładnicze, niezależnie od problemu."
    },
    "correct": "A",
    "explanation": "Rząd wielkości złożoności obliczeniowej ma krytyczne znaczenie dla skalowalności rozwiązania. Algorytm o złożoności wielomianowej (np. O(n^2) czy O(n^3)) będzie wykonalny dla większych danych, podczas gdy algorytm wykładniczy (np. O(2^n)) bardzo szybko staje się niewykonalny przy rosnącym n. Chodzi o wydajność – uzyskanie wyniku w sensownym czasie. Dokładność wyników nie zależy wprost od tego, czy algorytm jest wielomianowy czy wykładniczy, a zrozumiałość algorytmu to kwestia wtórna i nie decyduje o wyborze w kontekście wydajności.",
    "auto_id": 666
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód wykorzystania wielowątkowości do realizacji niektórych zadań w aplikacji?",
    "options": {
      "A": "Ponieważ wielowątkowość pozwala na równoległe przetwarzanie zadań na wielu rdzeniach procesora, co skraca łączny czas wykonania pracochłonnych operacji.",
      "B": "Ponieważ wielowątkowość gwarantuje, że w programie nie wystąpią żadne trudne do wykrycia błędy związane z dostępem do współdzielonych zasobów.",
      "C": "Ponieważ bez użycia wielowątkowości program nie mógłby w ogóle działać na nowoczesnym systemie operacyjnym."
    },
    "correct": "A",
    "explanation": "Wielowątkowość umożliwia wykonywanie wielu operacji jednocześnie, szczególnie na systemach z wieloma rdzeniami CPU. Jeśli aplikacja ma do wykonania kilka niezależnych lub równoległych zadań, można rozdzielić je na wątki i skrócić czas oczekiwania na wyniki poprzez zrównoleglenie. Jednak programowanie wielowątkowe wprowadza ryzyko błędów synchronizacji i dostępu do współdzielonych danych (np. race conditions), więc nie eliminuje problemów – wręcz je dodaje, choć rozwiązuje kwestię wydajności. Nowoczesne systemy operacyjne potrafią uruchamiać także programy jednowątkowe, więc to nie był powód decyzji.",
    "auto_id": 667
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód wprowadzenia mechanizmu cache'owania dla często pobieranych danych w systemie?",
    "options": {
      "A": "Ponieważ cache umożliwia przechowywanie często wykorzystywanych wyników w pamięci podręcznej, co zmniejsza liczbę powtarzających się obliczeń lub zapytań i przyspiesza działanie systemu.",
      "B": "Ponieważ cache całkowicie eliminuje potrzebę korzystania z baz danych lub usług zewnętrznych, niezależnie od świeżości danych.",
      "C": "Ponieważ cache sprawia, że system może dowolnie zwiększać zużycie pamięci bez negatywnych konsekwencji."
    },
    "correct": "A",
    "explanation": "Cache (pamięć podręczna) polega na tym, że jeśli pewne dane lub wyniki obliczeń są często potrzebne, system przechowuje je tymczasowo, aby nie pobierać ani nie liczyć ich ponownie za każdym razem. Dzięki temu unika się zbędnej pracy i skraca czas odpowiedzi. Mechanizm cache nie eliminuje całkowicie korzystania z baz danych czy usług (co jakiś czas dane trzeba zaktualizować), ani nie oznacza nieograniczonego zużycia pamięci – cache należy zarządzać, aby nie zapełnił całej dostępnej pamięci.",
    "auto_id": 668
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zastosowania mechanizmu leniwego ładowania (lazy loading) dla niektórych zasobów lub modułów aplikacji?",
    "options": {
      "A": "Ponieważ leniwe ładowanie opóźnia inicjalizację ciężkich zasobów do momentu, gdy są one potrzebne, co skraca czas startu aplikacji i obniża zużycie pamięci, gdy dane funkcje nie są używane.",
      "B": "Ponieważ lazy loading natychmiast ładuje wszystkie zasoby tuż po starcie, by później było mniej pracy dla systemu.",
      "C": "Ponieważ zastosowanie leniwego ładowania gwarantuje, że aplikacja nigdy nie będzie musiała wczytywać brakujących modułów podczas działania."
    },
    "correct": "A",
    "explanation": "Leniwe ładowanie polega na odwlekaniu wczytywania pewnych danych lub inicjalizacji obiektów do chwili, gdy faktycznie będą potrzebne. Dzięki temu aplikacja szybciej się uruchamia i zużywa mniej zasobów początkowo, co poprawia responsywność i wydajność wstępną. Nie oznacza to, że wszystko jest ładowane od razu – wręcz przeciwnie, ładujemy później. Oczywiście, gdy przychodzi pora użycia zasobu, musi on zostać załadowany – leniwe ładowanie nie eliminuje konieczności ładowania, tylko przesuwa ją na właściwy moment.",
    "auto_id": 669
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód wdrożenia rozwiązania na platformie chmurowej zamiast na własnej infrastrukturze serwerowej?",
    "options": {
      "A": "Ponieważ chmura umożliwia łatwe skalowanie zasobów w zależności od obciążenia oraz redukuje koszty i nakład pracy związany z utrzymaniem własnych serwerów.",
      "B": "Ponieważ rozwiązanie chmurowe gwarantuje nieograniczoną moc obliczeniową bez żadnych kosztów, niezależnie od intensywności użycia.",
      "C": "Ponieważ korzystanie z chmury eliminuje potrzebę tworzenia kopii zapasowych i zabezpieczeń danych."
    },
    "correct": "A",
    "explanation": "Platforma chmurowa oferuje elastyczność – można dynamicznie zwiększać lub zmniejszać wykorzystywane zasoby (moc obliczeniową, przestrzeń dyskową) wraz ze zmieniającym się zapotrzebowaniem, płacąc tylko za to, co się wykorzystuje. Dodatkowo odchodzi problem fizycznej administracji serwerami (aktualizacje, naprawy sprzętu). Chmura nie jest darmowa – koszty rosną z użyciem, a także nie zwalnia z myślenia o kopiach zapasowych czy bezpieczeństwie, choć dostawcy chmurowi oferują pewne narzędzia ułatwiające te zadania.",
    "auto_id": 670
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zastosowania w procesie wytwórczym potoku CI/CD (Continuous Integration/Continuous Deployment)?",
    "options": {
      "A": "Ponieważ CI/CD automatyzuje proces budowania, testowania i wdrażania aplikacji, co pozwala szybciej wykrywać błędy integracji i regularnie dostarczać aktualizacje do użytkowników.",
      "B": "Ponieważ CI/CD zwalnia programistów z obowiązku pisania testów, jako że system sam wykryje i poprawi błędy.",
      "C": "Ponieważ CI/CD wymaga wdrażania zmian tylko raz na koniec projektu, co redukuje liczbę potencjalnych awarii w trakcie rozwoju."
    },
    "correct": "A",
    "explanation": "Continuous Integration/Continuous Deployment to praktyka, w której zmiany w kodzie są często integrowane, testowane automatycznie i w razie sukcesu wdrażane. Dzięki temu błędy wynikające z połączenia różnych fragmentów kodu wychodzą na jaw wcześniej, a użytkownicy szybciej dostają poprawki i nowe funkcje. CI/CD nie pisze testów za programistów, ani nie oznacza wdrażania dopiero na końcu – jest wprost przeciwnie: wdraża się często, w małych porcjach, minimalizując ryzyko poważnych awarii.",
    "auto_id": 671
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód użycia gotowej biblioteki lub frameworka do zaimplementowania pewnej funkcjonalności zamiast pisania wszystkiego od podstaw?",
    "options": {
      "A": "Ponieważ sprawdzona biblioteka zapewnia gotowe, przetestowane rozwiązania, co skraca czas rozwoju i zmniejsza ryzyko błędów w porównaniu z tworzeniem własnej implementacji od zera.",
      "B": "Ponieważ użycie cudzej biblioteki gwarantuje, że nie trzeba rozumieć działania tej funkcjonalności, by z niej korzystać.",
      "C": "Ponieważ każda własnoręcznie napisana implementacja jest z założenia gorsza od dowolnej istniejącej biblioteki."
    },
    "correct": "A",
    "explanation": "Wykorzystanie istniejącej biblioteki lub frameworka pozwala skupić się na specyficznych dla projektu zagadnieniach, zamiast rozwiązywać po raz kolejny standardowy problem. Taka biblioteka jest zwykle dobrze przetestowana i optymalizowana przez społeczność lub twórców, co oznacza mniej błędów i oszczędność czasu. Nie oznacza to, że można nie rozumieć jej działania – integracja wymaga podstawowego zrozumienia. Oczywiście zdarza się, że własna implementacja może być lepsza w szczególnym przypadku, ale ogólnie pisanie wszystkiego samemu jest czasochłonne i ryzykowne.",
    "auto_id": 672
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód wyboru mikrokontrolera do sterowania urządzeniem w projekcie zamiast użycia standardowego komputera PC?",
    "options": {
      "A": "Ponieważ mikrokontroler spełnia wymagania wydajnościowe przy znacznie mniejszym poborze mocy i niższych kosztach, co jest istotne w urządzeniach wbudowanych o ograniczonych zasobach.",
      "B": "Ponieważ na zwykłym komputerze PC nie da się uruchomić specjalistycznego oprogramowania sterującego urządzeniami.",
      "C": "Ponieważ mikrokontrolery nie wymagają programowania, w przeciwieństwie do komputerów PC."
    },
    "correct": "A",
    "explanation": "Mikrokontrolery są projektowane do sterowania urządzeniami i pracy w systemach wbudowanych: są małe, energooszczędne i stosunkowo tanie. Jeżeli wymagania obliczeniowe nie są ogromne, mikrokontroler potrafi je zaspokoić, jednocześnie pozwalając na łatwą integrację z czujnikami, silnikami itp. Komputer PC byłby przerostem formy nad treścią (większy pobór mocy, wyższa cena, potrzeba pełnego OS). Stwierdzenie, że PC nie uruchomi specjalistycznego oprogramowania lub że mikrokontroler nie wymaga programowania, jest błędne – różnica tkwi raczej w skali i przeznaczeniu obu rozwiązań.",
    "auto_id": 673
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód regularnego refaktoryzowania kodu podczas trwania projektu?",
    "options": {
      "A": "Ponieważ regularny refactoring poprawia strukturę i czytelność kodu bez zmiany jego funkcjonalności, co zapobiega narastaniu długu technologicznego i ułatwia dalszy rozwój.",
      "B": "Ponieważ refaktoryzacja polega na dopisywaniu nowych funkcji przy każdej iteracji, co dynamicznie zwiększa zakres projektu.",
      "C": "Ponieważ refaktoryzacja usuwa potrzebę pisania testów – kod po refaktoryzacji zawsze działa poprawnie, więc testowanie staje się zbędne."
    },
    "correct": "A",
    "explanation": "Refaktoryzacja (refactoring) to proces poprawy wewnętrznej struktury kodu bez zmieniania jego zewnętrznego zachowania. Celem jest utrzymanie wysokiej jakości kodu w miarę dodawania nowych funkcjonalności – w przeciwnym razie łatwo o chaos i dług technologiczny (bałagan utrudniający wprowadzanie zmian). Refaktoryzacja nie oznacza dodawania nowych funkcji, a tym bardziej nie zastępuje testów – wręcz przeciwnie, posiadanie testów automatycznych ułatwia bezpieczne refaktoryzowanie.",
    "auto_id": 674
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód przygotowania obszernej dokumentacji dla interfejsów API systemu?",
    "options": {
      "A": "Ponieważ dokładna dokumentacja ułatwia przyszłym deweloperom i integratorom zrozumienie sposobu użycia API, co przyspiesza rozwój dodatkowych funkcjonalności i integrację z innymi systemami.",
      "B": "Ponieważ dokumentacja API zastępuje potrzebę pisania czytelnego kodu, gdyż wszystko można wyjaśnić w instrukcjach.",
      "C": "Ponieważ bez dokumentacji API system nie będzie mógł funkcjonować – dokumentacja jest wymagana do działania kodu."
    },
    "correct": "A",
    "explanation": "Dobra dokumentacja API sprawia, że osoby chcące skorzystać z funkcji systemu lub rozbudować go, mogą łatwo zrozumieć dostępne zasoby i zasady komunikacji. To oszczędza czas i redukuje liczbę błędów wynikających z nieznajomości kontraktów API. Oczywiście dokumentacja nie zastępuje pisania czytelnego kodu wewnętrznie, a system technicznie może działać bez niej – jednak z punktu widzenia użytkowników czy deweloperów zewnętrznych byłby trudny lub niemożliwy do użycia.",
    "auto_id": 675
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód zastosowania algorytmu zachłannego (greedy) do rozwiązania postawionego problemu optymalizacyjnego?",
    "options": {
      "A": "Ponieważ algorytm zachłanny w każdym kroku wybiera lokalnie najlepszą opcję, co w przypadku tego problemu prowadzi do wystarczająco dobrego rozwiązania w znacznie krótszym czasie niż metody dokładne.",
      "B": "Ponieważ algorytm zachłanny zawsze gwarantuje znalezienie globalnie optymalnego rozwiązania, niezależnie od charakterystyki problemu.",
      "C": "Ponieważ użycie algorytmu zachłannego pozwala całkowicie uniknąć analizowania warunków brzegowych i wyjątków w problemie."
    },
    "correct": "A",
    "explanation": "Algorytmy zachłanne są często wykorzystywane, gdy zależy nam na szybkości otrzymania przybliżonego rozwiązania. W każdym kroku wybierają one najbardziej obiecującą akcję licząc, że taka strategia doprowadzi do dobrego wyniku końcowego. Jeśli problem ma strukturę, która zapewnia optymalność lub bliskość optymalności rozwiązania zachłannego (np. problemy z właściwością optymalnej podstruktury), to taki algorytm da w praktyce bardzo dobry rezultat dużo szybciej niż algorytmy dokładne. Nie ma gwarancji globalnej optymalności dla dowolnego problemu – w wielu przypadkach algorytm zachłanny daje wynik przyzwoity, ale nie najlepszy możliwy. Nadal trzeba też brać pod uwagę pewne warunki brzegowe przy implementacji – algorytm zachłanny nie zwalnia z myślenia o nich.",
    "auto_id": 676
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód uwzględnienia opinii użytkowników przy kolejnych iteracjach projektowania produktu?",
    "options": {
      "A": "Ponieważ opinie użytkowników ujawniają rzeczywiste potrzeby i problemy w korzystaniu z produktu, co pozwala wprowadzać ulepszenia, które czynią produkt bardziej użytecznym i przyjaznym.",
      "B": "Ponieważ użytkownicy zawsze wiedzą lepiej od projektantów, jakie funkcje należy zaimplementować, więc należy podążać dokładnie za ich sugestiami bez wyjątków.",
      "C": "Ponieważ zbieranie opinii użytkowników jest wymagane formalnie, choć nie wpływa na realne decyzje projektowe."
    },
    "correct": "A",
    "explanation": "Włączanie użytkowników w proces projektowania (np. poprzez testy użyteczności, ankiety, beta-testy) pozwala odkryć, jak produkt sprawdza się w praktyce. Użytkownicy mogą wskazać, co jest dla nich niejasne, niewygodne lub jakich funkcji im brakuje w codziennym użyciu. Projektanci na tej podstawie mogą dokonać zmian, które sprawią, że produkt lepiej spełni swoje zadanie. Nie chodzi o ślepe wykonywanie każdej sugestii (trzeba je analizować) ani o spełnienie formalności – realny feedback przekłada się na realne usprawnienia.",
    "auto_id": 677
  },
  {
    "type": "causal_reasoning_select",
    "question": "Które zdanie najlepiej wyjaśnia powód przeprowadzenia symulacji działania układu przed zbudowaniem fizycznego prototypu?",
    "options": {
      "A": "Ponieważ symulacja pozwala przetestować projekt układu w różnych warunkach wirtualnie, co pomaga wykryć błędy i wprowadzić poprawki bez ponoszenia kosztów i czasu na budowę fizycznego prototypu.",
      "B": "Ponieważ symulacja gwarantuje, że gotowy fizyczny prototyp będzie działał dokładnie tak samo jak model, bez żadnych dodatkowych testów.",
      "C": "Ponieważ symulacja jest wymagana, aby projekt został zaakceptowany, mimo że nie wnosi realnej wartości do procesu projektowania."
    },
    "correct": "A",
    "explanation": "Symulacja komputerowa umożliwia zweryfikowanie zachowania projektowanego układu (np. elektronicznego, mechanicznego) w warunkach zbliżonych do rzeczywistych bez konieczności budowania go. Pozwala to szybko iterować nad projektem – jeśli coś nie działa w symulacji, można to poprawić znacznie taniej i szybciej niż po wykonaniu fizycznego modelu. Oczywiście rzeczywistość może przynieść dodatkowe niespodzianki, więc symulacja nie daje 100% pewności powodzenia, ale istotnie zmniejsza ryzyko. Nie jest to czysta formalność – to praktyczne narzędzie, choć nie zastępuje całkowicie testów fizycznego prototypu.",
    "auto_id": 678
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Algorytmy uczenia nadzorowanego”?",
    "options": {
      "A": "Algorytmy, które nie wymagają etykiet ani przykładów, bo same tworzą kategorię wynikową.",
      "B": "Zbiór metod, w których model uczy się na podstawie danych wejściowych z przypisanymi im właściwymi odpowiedziami (etykietami), aby później przewidywać wynik dla nowych danych.",
      "C": "Sposób przeprowadzania testów jednostkowych w modelu Waterfall.",
      "D": "Technika ograniczająca dostęp do pamięci podręcznej w systemach wielordzeniowych."
    },
    "correct": "B",
    "auto_id": 679
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Algorytmy głębokiego uczenia maszynowego”?",
    "options": {
      "A": "Metody przetwarzania grafów sieciowych, oparte wyłącznie na heurystyce BFS i DFS.",
      "B": "Zestaw algorytmów opartych na wielowarstwowych sieciach neuronowych, umożliwiających hierarchiczną analizę i automatyczne wykrywanie cech.",
      "C": "Narzędzia służące do symulacji procesów systemu rozproszonego na warstwie transportu.",
      "D": "Klasyczna implementacja rekurencyjnych drzew decyzyjnych bez warstw ukrytych."
    },
    "correct": "B",
    "auto_id": 680
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Wybrane algorytmy genetyczne”?",
    "options": {
      "A": "Zbiór metod wykorzystujących zasady biologicznej ewolucji (selekcja, krzyżowanie, mutacja) do optymalizacji rozwiązań.",
      "B": "Protokół szyfrujący wykorzystywany w sieciach bezprzewodowych typu WPA2.",
      "C": "Grupa rozwiązań do analizy obrazu w konwolucyjnych sieciach neuronowych.",
      "D": "Jednorazowe testy penetracyjne w procesie CI/CD."
    },
    "correct": "A",
    "auto_id": 681
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Systemy rozproszone”?",
    "options": {
      "A": "Systemy działające wyłącznie na jednym serwerze z wielordzeniowym CPU w trybie single-user.",
      "B": "Zbiór niezależnych komputerów współpracujących jako spójny system, udostępniających zasoby i komunikujących się po sieci, bez wspólnej fizycznej pamięci.",
      "C": "Metoda wyznaczania minimalnego drzewa rozpinającego w algorytmach grafowych.",
      "D": "Warstwa analizy danych w relacyjnym modelu baz oparta na kluczach głównych."
    },
    "correct": "B",
    "auto_id": 682
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Programowanie współbieżne”?",
    "options": {
      "A": "Tworzenie aplikacji działających wyłącznie w sekwencyjnym trybie jednowątkowym.",
      "B": "Podejście umożliwiające wykonywanie wielu zadań (lub wątków) w tym samym czasie lub przeplatanie ich wykonania, by poprawić efektywność i responsywność.",
      "C": "Specjalna metoda analizowania diagramów UML w systemach rozproszonych.",
      "D": "Algorytm wyznaczający kolejność paczek do załadowania na ciężarówkę."
    },
    "correct": "B",
    "auto_id": 683
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Sztuczne sieci neuronowe”?",
    "options": {
      "A": "Bazy danych typu NoSQL do przechowywania grafów.",
      "B": "Modele obliczeniowe inspirowane strukturą biologicznych sieci neuronowych, uczące się poprzez dostosowywanie wag połączeń.",
      "C": "Zbiór metod do testowania wydajności systemów wieloprocesowych.",
      "D": "Protokół służący do szyfrowania warstwy aplikacji w sieciach LAN."
    },
    "correct": "B",
    "auto_id": 684
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Metody i techniki projektowania systemów informatycznych”?",
    "options": {
      "A": "Zestaw praktyk (np. Agile, RUP, Waterfall), narzędzi oraz wzorców, które wspomagają analizę, planowanie i realizację systemów oprogramowania.",
      "B": "Wyłącznie techniki testów penetracyjnych w warstwie sieci.",
      "C": "Procedura wyznaczania minimalnego drzewa rozpinającego w analizie topologii systemu.",
      "D": "Lista bibliotek CSS używanych do tworzenia responsywnego interfejsu."
    },
    "correct": "A",
    "auto_id": 685
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „4 diagramy UML (przypadków użycia, sekwencji, klas i aktywności)”?",
    "options": {
      "A": "Zbiór diagramów do modelowania różnych aspektów systemu: jego funkcjonalności (przypadków użycia), interakcji w czasie (sekwencji), struktury (klas) i przepływu pracy (aktywności).",
      "B": "Sposób definicji kluczy głównych i obcych w modelu relacyjnym baz danych.",
      "C": "Opis metod statystycznych do eksploracji danych.",
      "D": "Protokoły transportu w modelu TCP/IP zdefiniowane przez IEEE 802.11."
    },
    "correct": "A",
    "auto_id": 686
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Gromadzenie i eksploracja danych (ETL)”?",
    "options": {
      "A": "Metoda testowania systemu pod kątem obciążenia i przerwań sieciowych w architekturze rozproszonej.",
      "B": "Proces polegający na pobraniu danych (Extract), ich przekształceniu (Transform) i załadowaniu (Load) do docelowego magazynu (np. hurtowni), łącznie z wstępną eksploracją.",
      "C": "Sposób definiowania kluczy obcych w modelu UML.",
      "D": "Ręczne przepisywanie arkuszy CSV do bazy relacyjnej, bez weryfikacji formatów."
    },
    "correct": "B",
    "auto_id": 687
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Big Data i BI (Business Intelligence)”?",
    "options": {
      "A": "Zestaw metod tworzenia diagramów UML w oparciu o model TCP/IP.",
      "B": "Zakres zagadnień związanych z przetwarzaniem ogromnych, szybko napływających i różnorodnych danych (Big Data), oraz technik analitycznych (BI) umożliwiających wyciąganie wniosków biznesowych z tych danych.",
      "C": "Protokół szyfrowania w sieciach bezprzewodowych z wykorzystaniem kluczy simetrycznych.",
      "D": "Wspólna nazwa zestawu testów regresyjnych do analizy wydajności baz NoSQL."
    },
    "correct": "B",
    "auto_id": 688
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „CRUD”?",
    "options": {
      "A": "Zestaw podstawowych operacji na danych: Create (tworzenie), Read (odczyt), Update (aktualizacja), Delete (usuwanie).",
      "B": "Model testów eksploracyjnych w metodyce Waterfall.",
      "C": "Algorytm uczenia maszynowego w kontekście klasteryzacji k-średnich.",
      "D": "Sieć neuronowa z rekurencyjnymi warstwami do przetwarzania sekwencji."
    },
    "correct": "A",
    "auto_id": 689
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Podstawowe testy aplikacji internetowych”?",
    "options": {
      "A": "Zbiór technik pozwalających manipulować pakietami TCP w warstwie transportu.",
      "B": "Testy funkcjonalne, integracyjne, jednostkowe oraz testy UI i bezpieczeństwa, mające na celu weryfikację poprawności działania aplikacji webowej.",
      "C": "Wykorzystanie wyłącznie testów penetracyjnych w trybie offline.",
      "D": "Protokół do szyfrowania warstwy aplikacji w architekturze trójwarstwowej."
    },
    "correct": "B",
    "auto_id": 690
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Bazy NoSQL”?",
    "options": {
      "A": "Systemy bazodanowe oparte na relacjach i kluczach głównych, pozwalające na wielokrotne JOIN-y.",
      "B": "Bazy nierelacyjne: dokumentowe, klucz-wartość, kolumnowe czy grafowe, zaprojektowane pod kątem elastycznego schematu i skalowalności poziomej.",
      "C": "Mechanizm testujący wydajność złączeń w modelu relacyjnym.",
      "D": "Protokół bezpieczeństwa w architekturze klastrowej."
    },
    "correct": "B",
    "auto_id": 691
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Bazy relacyjne”?",
    "options": {
      "A": "Bazy, w których dane przechowuje się wyłącznie w formie dokumentów JSON.",
      "B": "Bazy danych oparte na modelu tabel, relacjach (klucz główny, klucz obcy) oraz języku SQL do definicji i operacji na danych.",
      "C": "Sposób testowania bezpieczeństwa w warstwie systemu operacyjnego poprzez transakcje atestujące.",
      "D": "Algorytm do uczenia głębokich sieci neuronowych bez warstw wstecznej propagacji."
    },
    "correct": "B",
    "auto_id": 692
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Zagrożenia w bazach danych”?",
    "options": {
      "A": "Tylko błędy typograficzne w definicji tabel i kolumn.",
      "B": "Ryzyka związane z atakami (np. SQL Injection), niewłaściwymi uprawnieniami czy brakiem szyfrowania, prowadzące do wycieku, utraty lub modyfikacji danych.",
      "C": "Rodzaj testów jednostkowych w modelu CI/CD dla aplikacji mobilnych.",
      "D": "Dowolne problemy z interpretacją plików CSV w arkuszach kalkulacyjnych."
    },
    "correct": "B",
    "auto_id": 693
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Zagrożenia w systemach operacyjnych”?",
    "options": {
      "A": "Wyłącznie problem braku kompatybilności z plikami .docx.",
      "B": "Luki bezpieczeństwa (exploity, rootkity), nieaktualizowane systemy, podatność na przejęcie uprawnień, nieautoryzowany dostęp do zasobów.",
      "C": "Zbiór testów integracyjnych w warstwie UI systemu Windows.",
      "D": "Rozbudowany protokół szyfrujący w sieciach komórkowych."
    },
    "correct": "B",
    "auto_id": 694
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Zagrożenia w sieciach komputerowych”?",
    "options": {
      "A": "Konieczność używania testów penetracyjnych w modelu UML do generowania wykresów sekwencji.",
      "B": "Ataki (DDoS, MitM, sniffing), nieautoryzowany dostęp do routerów, brak szyfrowania w Wi-Fi, które mogą prowadzić do podsłuchu, przejęcia czy paraliżu sieci.",
      "C": "Brak protokołu IP w warstwie dostępu do sieci a obawa o integralność plików PDF.",
      "D": "Zestaw praktyk do analizy algorytmów genetycznych."
    },
    "correct": "B",
    "auto_id": 695
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Model TCP/IP”?",
    "options": {
      "A": "Czterowarstwowy model komunikacji (warstwa aplikacji, transportu, internetu i dostępu do sieci) opisujący protokoły używane w Internecie.",
      "B": "Siedmiowarstwowy model OSI dotyczący wymiany plików CSV.",
      "C": "Algorytm konwolucyjny używany do szyfrowania ruchu w warstwie aplikacji.",
      "D": "Jednorazowy test penetracyjny sprawdzający zgodność z warstwami sieci VLAN."
    },
    "correct": "A",
    "auto_id": 696
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Budowa diagramu ERD (Entity-Relationship Diagram)”?",
    "options": {
      "A": "Model relacji między encjami (np. tabelami w bazie danych), zawierający atrybuty, klucze główne/obce i typ relacji (1:1, 1:N, N:M).",
      "B": "Diagram wskazujący hierarchię klas i ich dziedziczenie w systemie obiektowym.",
      "C": "Schemat testów penetracyjnych w architekturze klastrowej.",
      "D": "Zbiór wykresów sekwencji do opisu interakcji użytkowników z systemem."
    },
    "correct": "A",
    "auto_id": 697
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Wymagania funkcjonalne i niefunkcjonalne”?",
    "options": {
      "A": "Wymagania dotyczące tylko wydajności systemu, bez określania jego zachowania.",
      "B": "Podział wymagań: funkcjonalne opisują konkretne działania i funkcje systemu, a niefunkcjonalne skupiają się na cechach jakości, np. wydajności, bezpieczeństwie, dostępności.",
      "C": "Dodatkowe spisy bibliotek i zależności stosowanych w warstwie frontendowej.",
      "D": "Zbiór kluczy głównych do modelu ERD."
    },
    "correct": "B",
    "auto_id": 698
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Korzystanie z serwerów bazodanowych przez aplikacje internetowe i mobilne”?",
    "options": {
      "A": "Model bezpośredniego łączenia kodu mobilnego do portu bazy (np. 3306), bez warstwy pośredniczącej.",
      "B": "Podejście, w którym aplikacje (webowe, mobilne) komunikują się z bazą danych przez API/warstwę backend (REST/GraphQL), co zapewnia bezpieczeństwo i logikę pośredniczącą.",
      "C": "Schemat konfiguracyjny do definicji kluczy obcych w systemach NoSQL.",
      "D": "Zasada testowania warstwy UI przez protokoły SSH i RDP."
    },
    "correct": "B",
    "auto_id": 699
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Klucze w relacyjnych bazach danych”?",
    "options": {
      "A": "Kolumny pomocnicze, które pełnią wyłącznie funkcję indeksów sortujących w plikach CSV.",
      "B": "Mechanizmy identyfikacji i wiązania danych: klucze główne (Primary Key) jednoznacznie identyfikują rekord, a klucze obce (Foreign Key) definiują relacje i zapewniają spójność referencyjną.",
      "C": "Zestaw struktur przechowujących jedynie definicje ról użytkowników do zarządzania systemem.",
      "D": "Funkcjonalność, która pozwala automatycznie łączyć bazy NoSQL z systemami plików w trybie offline."
    },
    "correct": "B",
    "auto_id": 700
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Złączenia typu JOIN w bazach danych”?",
    "options": {
      "A": "Technika łączenia tabel w zapytaniach SQL: INNER JOIN zwraca dopasowane rekordy w obu tabelach, LEFT/RIGHT JOIN uwzględniają rekordy także bez dopasowania, a FULL OUTER JOIN łączy wszystkie z obu stron.",
      "B": "Algorytm haszujący wykorzystywany w kryptografii klucza publicznego.",
      "C": "Mechanizm blokad transakcyjnych działający tylko w systemach rozproszonych.",
      "D": "Zbiór protokołów do szyfrowania w warstwie prezentacji w UML."
    },
    "correct": "A",
    "auto_id": 701
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Responsywność w aplikacjach internetowych”?",
    "options": {
      "A": "Zdolność serwera do szybkiej odpowiedzi na zapytania bazy SQL.",
      "B": "Możliwość automatycznej modyfikacji kodu w backendzie w czasie rzeczywistym.",
      "C": "Dostosowanie wyglądu i układu interfejsu do różnych urządzeń i rozdzielczości ekranu, by zapewnić wygodę użytkowania na telefonie, tablecie i desktopie.",
      "D": "Wykorzystywanie schematów UML do generowania animacji w warstwie UI."
    },
    "correct": "C",
    "auto_id": 702
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Zarządzanie procesami w systemach operacyjnych”?",
    "options": {
      "A": "Mechanizm do szyfrowania i deszyfrowania plików .docx w systemie plików.",
      "B": "Obsługa cyklu życia procesów (tworzenie, planowanie, przełączanie kontekstu, oczekiwanie, zakończenie) i przydział zasobów (CPU, pamięć).",
      "C": "Zbiór działań testowych w warstwie integracji dedykowanej dla sieci komputerowych.",
      "D": "Interfejs do wyświetlania grafiki 3D w trybie single-thread."
    },
    "correct": "B",
    "auto_id": 703
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Zarządzanie użytkownikami w systemach operacyjnych”?",
    "options": {
      "A": "Proces przydzielania kart graficznych i sterowników USB w systemie Linux.",
      "B": "Tworzenie, modyfikacja i usuwanie kont użytkowników, grup, hasła, uprawnienia dostępu do zasobów oraz uwierzytelnianie i autoryzacja.",
      "C": "System automatycznego doboru protokołu ARP w sieciach WLAN.",
      "D": "Specjalna metoda weryfikacji semantyki plików DLL w Windows."
    },
    "correct": "B",
    "auto_id": 704
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Sieci bezprzewodowe”?",
    "options": {
      "A": "Sieci działające wyłącznie na kablach światłowodowych w modelu VLAN.",
      "B": "Sieci oparte na transmisji fal radiowych (Wi-Fi, Bluetooth, LTE itp.), umożliwiające komunikację bezprzewodową na różne odległości.",
      "C": "Protokół szyfrujący w warstwie aplikacji do weryfikacji ładowania plików .exe.",
      "D": "Zbiór metod do analizy sentimentu w arkuszach CSV."
    },
    "correct": "B",
    "auto_id": 705
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Technologie internetowe: frontend i backend”?",
    "options": {
      "A": "Rozróżnienie na część uruchamianą w przeglądarce (HTML, CSS, JS = frontend) i część serwerową (obsługa logiki, komunikacja z bazą danych = backend).",
      "B": "Model połączeń TCP oraz UDP w warstwie fizycznej sieci bezprzewodowej.",
      "C": "Mechanizm testowania protokołu HTTP w systemach wbudowanych.",
      "D": "Zbiór metod do podpisywania kluczy SSH w warstwie UI."
    },
    "correct": "A",
    "auto_id": 706
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Architektura trójwarstwowa w aplikacjach internetowych”?",
    "options": {
      "A": "Sposób szyfrowania plików .docx w warstwie systemu operacyjnego, sieci i aplikacji.",
      "B": "Podział aplikacji na warstwę prezentacji (UI), warstwę logiki biznesowej (serwis) i warstwę danych (baza), by ułatwić utrzymanie i skalowanie.",
      "C": "Rozwiązanie polegające na wykorzystaniu trzech routerów sieciowych w warstwie VLAN.",
      "D": "Model rozpoznawania obrazów z trzema konwolucjami w CNN."
    },
    "correct": "B",
    "auto_id": 707
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Techniki pozyskiwania i gromadzenia danych”?",
    "options": {
      "A": "Metody testowania bezpieczeństwa w architekturze klastrowej.",
      "B": "Różnorodne sposoby zdobywania danych (formularze online, web scraping, API, czujniki IoT, ankiety), a następnie ich składowanie (np. w bazach, hurtowniach).",
      "C": "Procedura weryfikacji kluczy głównych w modelu relacyjnym UML.",
      "D": "Algorytm do przełączania kontekstu procesów w systemie wbudowanym."
    },
    "correct": "B",
    "auto_id": 708
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Model TCP/IP”?",
    "options": {
      "A": "Czterowarstwowy model komunikacji (warstwa aplikacji, transportu, internetu i dostępu do sieci) opisujący protokoły używane w Internecie.",
      "B": "Siedmiowarstwowy model OSI dotyczący wymiany plików CSV.",
      "C": "Algorytm konwolucyjny używany do szyfrowania ruchu w warstwie aplikacji.",
      "D": "Jednorazowy test penetracyjny sprawdzający zgodność z warstwami sieci VLAN."
    },
    "correct": "A",
    "auto_id": 709
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Budowa diagramu ERD (Entity-Relationship Diagram)”?",
    "options": {
      "A": "Model relacji między encjami (np. tabelami w bazie danych), zawierający atrybuty, klucze główne/obce i typ relacji (1:1, 1:N, N:M).",
      "B": "Diagram wskazujący hierarchię klas i ich dziedziczenie w systemie obiektowym.",
      "C": "Schemat testów penetracyjnych w architekturze klastrowej.",
      "D": "Zbiór wykresów sekwencji do opisu interakcji użytkowników z systemem."
    },
    "correct": "A",
    "auto_id": 710
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Wymagania funkcjonalne i niefunkcjonalne”?",
    "options": {
      "A": "Wymagania dotyczące tylko wydajności systemu, bez określania jego zachowania.",
      "B": "Podział wymagań: funkcjonalne opisują konkretne działania i funkcje systemu, a niefunkcjonalne skupiają się na cechach jakości, np. wydajności, bezpieczeństwie, dostępności.",
      "C": "Dodatkowe spisy bibliotek i zależności stosowanych w warstwie frontendowej.",
      "D": "Zbiór kluczy głównych do modelu ERD."
    },
    "correct": "B",
    "auto_id": 711
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Korzystanie z serwerów bazodanowych przez aplikacje internetowe i mobilne”?",
    "options": {
      "A": "Model bezpośredniego łączenia kodu mobilnego do portu bazy (np. 3306), bez warstwy pośredniczącej.",
      "B": "Podejście, w którym aplikacje (webowe, mobilne) komunikują się z bazą danych przez API/warstwę backend (REST/GraphQL), co zapewnia bezpieczeństwo i logikę pośredniczącą.",
      "C": "Schemat konfiguracyjny do definicji kluczy obcych w systemach NoSQL.",
      "D": "Zasada testowania warstwy UI przez protokoły SSH i RDP."
    },
    "correct": "B",
    "auto_id": 712
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Klucze w relacyjnych bazach danych”?",
    "options": {
      "A": "Kolumny pomocnicze, które pełnią wyłącznie funkcję indeksów sortujących w plikach CSV.",
      "B": "Mechanizmy identyfikacji i wiązania danych: klucze główne (Primary Key) jednoznacznie identyfikują rekord, a klucze obce (Foreign Key) definiują relacje i zapewniają spójność referencyjną.",
      "C": "Zestaw struktur przechowujących jedynie definicje ról użytkowników do zarządzania systemem.",
      "D": "Funkcjonalność, która pozwala automatycznie łączyć bazy NoSQL z systemami plików w trybie offline."
    },
    "correct": "B",
    "auto_id": 713
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Złączenia typu JOIN w bazach danych”?",
    "options": {
      "A": "Technika łączenia tabel w zapytaniach SQL: INNER JOIN zwraca dopasowane rekordy w obu tabelach, LEFT/RIGHT JOIN uwzględniają rekordy także bez dopasowania, a FULL OUTER JOIN łączy wszystkie z obu stron.",
      "B": "Algorytm haszujący wykorzystywany w kryptografii klucza publicznego.",
      "C": "Mechanizm blokad transakcyjnych działający tylko w systemach rozproszonych.",
      "D": "Zbiór protokołów do szyfrowania w warstwie aplikacji w architekturze trójwarstwowej."
    },
    "correct": "A",
    "auto_id": 714
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Responsywność w aplikacjach internetowych”?",
    "options": {
      "A": "Zdolność serwera do szybkiej odpowiedzi na zapytania bazy SQL.",
      "B": "Możliwość automatycznej modyfikacji kodu w backendzie w czasie rzeczywistym.",
      "C": "Dostosowanie wyglądu i układu interfejsu do różnych urządzeń i rozdzielczości ekranu, by zapewnić wygodę użytkowania na telefonie, tablecie i desktopie.",
      "D": "Wykorzystywanie schematów UML do generowania animacji w warstwie UI."
    },
    "correct": "C",
    "auto_id": 715
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Zarządzanie procesami w systemach operacyjnych”?",
    "options": {
      "A": "Mechanizm do szyfrowania i deszyfrowania plików .docx w systemie plików.",
      "B": "Obsługa cyklu życia procesów (tworzenie, planowanie, przełączanie kontekstu, oczekiwanie, zakończenie) i przydział zasobów (CPU, pamięć).",
      "C": "Zbiór działań testowych w warstwie integracji dedykowanej dla sieci komputerowych.",
      "D": "Interfejs do wyświetlania grafiki 3D w trybie single-thread."
    },
    "correct": "B",
    "auto_id": 716
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Zarządzanie użytkownikami w systemach operacyjnych”?",
    "options": {
      "A": "Proces przydzielania kart graficznych i sterowników USB w systemie Linux.",
      "B": "Tworzenie, modyfikacja i usuwanie kont użytkowników, grup, hasła, uprawnienia dostępu do zasobów oraz uwierzytelnianie i autoryzacja.",
      "C": "System automatycznego doboru protokołu ARP w sieciach WLAN.",
      "D": "Specjalna metoda weryfikacji semantyki plików DLL w Windows."
    },
    "correct": "B",
    "auto_id": 717
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Sieci bezprzewodowe”?",
    "options": {
      "A": "Sieci działające wyłącznie na kablach światłowodowych w modelu VLAN.",
      "B": "Sieci oparte na transmisji fal radiowych (Wi-Fi, Bluetooth, LTE itp.), umożliwiające komunikację bezprzewodową na różne odległości.",
      "C": "Protokół szyfrujący w warstwie aplikacji do weryfikacji ładowania plików .exe.",
      "D": "Zbiór metod do analizy sentimentu w arkuszach CSV."
    },
    "correct": "B",
    "auto_id": 718
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Technologie internetowe: frontend i backend”?",
    "options": {
      "A": "Rozróżnienie na część uruchamianą w przeglądarce (HTML, CSS, JS = frontend) i część serwerową (obsługa logiki, komunikacja z bazą danych = backend).",
      "B": "Model połączeń TCP oraz UDP w warstwie fizycznej sieci bezprzewodowej.",
      "C": "Mechanizm testowania protokołu HTTP w systemach wbudowanych.",
      "D": "Zbiór metod do podpisywania kluczy SSH w warstwie UI."
    },
    "correct": "A",
    "auto_id": 719
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Architektura trójwarstwowa w aplikacjach internetowych”?",
    "options": {
      "A": "Sposób szyfrowania plików .docx w warstwie systemu operacyjnego, sieci i aplikacji.",
      "B": "Podział aplikacji na warstwę prezentacji (UI), warstwę logiki biznesowej (serwis) i warstwę danych (baza), by ułatwić utrzymanie i skalowanie.",
      "C": "Rozwiązanie polegające na wykorzystaniu trzech routerów sieciowych w warstwie VLAN.",
      "D": "Model rozpoznawania obrazów z trzema konwolucjami w CNN."
    },
    "correct": "B",
    "auto_id": 720
  },
  {
    "type": "simple_select",
    "question": "Które z poniższych najlepiej definiuje pojęcie „Techniki pozyskiwania i gromadzenia danych”?",
    "options": {
      "A": "Metody testowania bezpieczeństwa w architekturze klastrowej.",
      "B": "Różnorodne sposoby zdobywania danych (formularze online, web scraping, API, czujniki IoT, ankiety), a następnie ich składowanie (np. w bazach, hurtowniach).",
      "C": "Procedura weryfikacji kluczy głównych w modelu relacyjnym UML.",
      "D": "Algorytm do przełączania kontekstu procesów w systemie wbudowanym."
    },
    "correct": "B",
    "auto_id": 721
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych odpowiedzi wskazują różnice między zarządzaniem użytkownikami a zarządzaniem procesami w systemach operacyjnych?",
    "options": {
      "A": "Zarządzanie użytkownikami dotyczy nadawania uprawnień i kontroli dostępu, a zarządzanie procesami kontroluje wykorzystanie CPU i pamięci.",
      "B": "Zarządzanie procesami obejmuje tworzenie i planowanie zadań, natomiast zarządzanie użytkownikami skupia się na kontach, grupach i uwierzytelnianiu.",
      "C": "Zarządzanie użytkownikami odbywa się tylko w systemach z graficznym interfejsem, a zarządzanie procesami — tylko w systemach serwerowych.",
      "D": "Zarządzanie procesami wymaga obsługi kontekstu przełączeń, natomiast zarządzanie użytkownikami — konfiguracji polityk bezpieczeństwa."
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "auto_id": 722
  },
  {
    "type": "multi_select",
    "question": "Które odpowiedzi poprawnie wskazują różnice między sieciami przewodowymi a bezprzewodowymi?",
    "options": {
      "A": "Sieci bezprzewodowe są bardziej podatne na zakłócenia i ataki typu sniffing niż przewodowe.",
      "B": "Sieci przewodowe wymagają fizycznego połączenia urządzeń, co ogranicza mobilność.",
      "C": "Sieci bezprzewodowe nie potrzebują protokołów warstwy sieciowej.",
      "D": "Sieci przewodowe zazwyczaj oferują wyższą stabilność i przepustowość w porównaniu do sieci bezprzewodowych."
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "auto_id": 723
  },
  {
    "type": "multi_select",
    "question": "Które ze stwierdzeń wskazują różnice między frontendem a backendem w aplikacjach internetowych?",
    "options": {
      "A": "Frontend odpowiada za interakcję z użytkownikiem, a backend za logikę aplikacji i dostęp do bazy danych.",
      "B": "Frontend realizowany jest zwykle przy użyciu HTML, CSS i JS, backend zaś np. w PHP, Pythonie czy Node.js.",
      "C": "Frontend działa po stronie serwera, backend po stronie przeglądarki.",
      "D": "Backend może obsługiwać uwierzytelnianie i autoryzację, a frontend prezentuje dane użytkownikowi."
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "auto_id": 724
  },
  {
    "type": "multi_select",
    "question": "Które odpowiedzi przedstawiają różnice między architekturą trójwarstwową a jednowarstwową?",
    "options": {
      "A": "Architektura trójwarstwowa rozdziela logikę, interfejs i dane, jednowarstwowa skupia wszystkie funkcje w jednej aplikacji.",
      "B": "Trójwarstwowa architektura ułatwia testowanie i skalowanie, w jednowarstwowej zmiana jednej części może wpływać na całość.",
      "C": "Architektura jednowarstwowa pozwala na lepsze bezpieczeństwo niż trójwarstwowa.",
      "D": "W architekturze trójwarstwowej możliwe jest niezależne rozwijanie UI i backendu."
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "auto_id": 725
  },
  {
    "type": "multi_select",
    "question": "Które ze stwierdzeń poprawnie wskazują różnice między web scrapingiem a zbieraniem danych z API?",
    "options": {
      "A": "API dostarcza dane w uporządkowany sposób, natomiast web scraping wymaga analizy struktury HTML strony.",
      "B": "Web scraping może być bardziej podatny na błędy, gdy zmienia się struktura strony.",
      "C": "Dane z API często wymagają dodatkowego przetwarzania wizualnego, web scraping nie.",
      "D": "Dostęp do API może być regulowany przez klucze dostępu i limity, web scraping rzadziej posiada takie ograniczenia."
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "auto_id": 726
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie wskazują różnice między algorytmami uczenia nadzorowanego a nienadzorowanego?",
    "options": {
      "A": "Uczenie nadzorowane wymaga etykiet dla danych treningowych, nienadzorowane nie ma etykiet i grupuje lub wyodrębnia wzorce samodzielnie.",
      "B": "W uczeniu nadzorowanym model przewiduje wartości liczbowe bez analizy etykiet, a w nienadzorowanym próbuje odgadnąć etykiety zdefiniowane przez użytkownika.",
      "C": "Uczenie nienadzorowane jest zwykle wykorzystywane do klasteryzacji i redukcji wymiaru, podczas gdy nadzorowane do klasyfikacji i regresji.",
      "D": "Uczenie nadzorowane koncentruje się na budowaniu drzew decyzyjnych, natomiast nienadzorowane dotyczy wyłącznie sieci neuronowych."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 727
  },
  {
    "type": "multi_select",
    "question": "Które ze stwierdzeń poprawnie opisują różnice między „głębokimi” sieciami neuronowymi a „płytkimi” sieciami neuronowymi?",
    "options": {
      "A": "Głębokie sieci mają wiele (co najmniej kilka) warstw ukrytych, natomiast płytkie sieci zawierają zwykle jedną warstwę ukrytą.",
      "B": "Płytkie sieci nie mogą korzystać z funkcji aktywacji, a głębokie sieci zawsze używają ReLU.",
      "C": "Głębokie sieci lepiej radzą sobie z automatycznym wykrywaniem złożonych cech i wzorców, podczas gdy płytkie wymagają częściej ręcznego opracowania cech.",
      "D": "Płytkie sieci są stosowane wyłącznie do klasteryzacji, a głębokie do regresji."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 728
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie wskazują różnice między algorytmami genetycznymi a metodami gradientowymi w optymalizacji?",
    "options": {
      "A": "Algorytmy genetyczne działają na populacji rozwiązań i wykorzystują selekcję, krzyżowanie, mutację, a metody gradientowe z reguły aktualizują pojedyncze rozwiązanie w kierunku spadku gradientu.",
      "B": "Algorytmy genetyczne gwarantują znalezienie globalnego optimum, metody gradientowe nigdy nie schodzą poniżej lokalnych minimów.",
      "C": "W algorytmach genetycznych nie trzeba wyliczać gradientu funkcji przystosowania, natomiast metody gradientowe wymagają różniczkowalnej funkcji kosztu.",
      "D": "Metody gradientowe zawsze działają wolniej od algorytmów genetycznych i nie potrafią obsłużyć zadań ciągłych."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 729
  },
  {
    "type": "multi_select",
    "question": "Które ze stwierdzeń poprawnie ukazują różnice między systemami rozproszonymi a systemami scentralizowanymi?",
    "options": {
      "A": "Systemy rozproszone opierają się na wielu węzłach komunikujących się przez sieć, a scentralizowane polegają na jednym głównym serwerze.",
      "B": "W systemach scentralizowanych łatwiej uniknąć pojedynczego punktu awarii, natomiast w rozproszonych awaria jednego węzła zatrzymuje całość.",
      "C": "Systemy rozproszone mogą skalować się poziomo, dodając więcej węzłów, a w scentralizowanych rozbudowa zwykle oznacza ulepszenie jednego serwera (skalowanie pionowe).",
      "D": "Systemy rozproszone zawsze wymagają światłowodów klasy enterprise, a scentralizowane działają wyłącznie w sieciach bezprzewodowych."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 730
  },
  {
    "type": "multi_select",
    "question": "Które ze stwierdzeń poprawnie opisują różnice między programowaniem współbieżnym a sekwencyjnym?",
    "options": {
      "A": "Współbieżność umożliwia przeplatanie lub równoległe wykonywanie wielu zadań, a sekwencyjne wykonuje jedną operację po drugiej.",
      "B": "Programowanie sekwencyjne pozwala obsługiwać wielu użytkowników jednocześnie, a współbieżne zawsze ogranicza się do jednego rdzenia CPU.",
      "C": "We współbieżności mogą pojawić się race conditions, których nie ma w modelu ściśle sekwencyjnym.",
      "D": "Sekwencyjny model nie wymaga synchronizacji zasobów, współbieżny często tak."
    },
    "correct": [
      "A",
      "C",
      "D"
    ],
    "auto_id": 731
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia wskazują kluczowe różnice między sieciami neuronowymi a klasycznymi, symbolicznymi metodami sztucznej inteligencji?",
    "options": {
      "A": "Symboliczne metody (np. systemy ekspertowe) opierają się na regułach i logice, natomiast sieci neuronowe uczą się wzorców z danych i dostosowują wagi.",
      "B": "Sieci neuronowe zawsze wyjaśniają swoje decyzje w zrozumiały sposób, a systemy oparte na regułach są bardziej czarną skrzynką.",
      "C": "Klasyczne podejścia zwykle wymagają ręcznego kodowania wiedzy, a sieci neuronowe automatycznie wyodrębniają cechy, jeśli mają wystarczająco dużo danych.",
      "D": "Symboliczne metody wymagają GPU, a sieci neuronowe mogą działać bez przyspieszeń sprzętowych."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 732
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie wskazują różnice między metodykami Agile a podejściem Waterfall w projektowaniu systemów informatycznych?",
    "options": {
      "A": "W Agile prace przebiegają iteracyjnie i można zmieniać wymagania w trakcie, a w Waterfall najczęściej określa się je szczegółowo na wczesnym etapie i rzadko zmienia.",
      "B": "Waterfall pozwala na częste iteracje i ciągły kontakt z klientem, a Agile ogranicza kontakt do fazy końcowej.",
      "C": "Agile skupia się na wielomiesięcznych fazach dokumentacyjnych przed napisaniem pierwszej linii kodu, natomiast w Waterfall rozwija się prototypy co sprint.",
      "D": "Waterfall bywa bardziej adekwatny w projektach z jasno określonymi, stabilnymi wymaganiami, a Agile — w sytuacjach dynamicznych i zmiennych."
    },
    "correct": [
      "A",
      "D"
    ],
    "auto_id": 733
  },
  {
    "type": "multi_select",
    "question": "Które odpowiedzi podkreślają różnice między diagramem przypadków użycia (use case) a diagramem klas w UML?",
    "options": {
      "A": "Diagram przypadków użycia prezentuje funkcje z perspektywy aktorów, a diagram klas opisuje strukturę i relacje między klasami w systemie.",
      "B": "Diagram przypadków użycia pokazuje logiczną sekwencję interakcji, a diagram klas wyłącznie stany obiektów.",
      "C": "Diagram klas jest nastawiony na model danych i dziedziczenie, a use case na definiowanie zachowań i scenariuszy użytkownika.",
      "D": "Diagram przypadków użycia zawsze przedstawia warstwę fizyczną wdrożenia, a klas – warstwę logiczną."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 734
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia pokazują różnice między prostym gromadzeniem danych (np. formularze) a ich eksploracją (data exploration)?",
    "options": {
      "A": "Gromadzenie polega na uzyskaniu lub zapisie surowych danych, a eksploracja na analizie, szukaniu wzorców i anomalii w tych danych.",
      "B": "Formularze nigdy nie wymagają walidacji, natomiast data exploration dotyczy tylko interfejsów CLI.",
      "C": "Eksploracja danych może ujawniać odstające rekordy i zależności, podczas gdy proste gromadzenie skupia się na pozyskaniu danych w określonym formacie.",
      "D": "Gromadzenie danych i eksploracja to zupełnie to samo, bez żadnych różnic w celu."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 735
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie opisują różnice między Big Data a klasycznymi, mniejszymi zbiorami danych w Business Intelligence?",
    "options": {
      "A": "Big Data obejmuje ogromne wolumeny i różnorodność, przez co wymaga skalowalnych, rozproszonych narzędzi (Hadoop, Spark), a BI w klasycznym wydaniu często wystarcza do mniejszych, strukturalnych danych.",
      "B": "BI przy małych danych nie potrzebuje żadnych procesów ETL, a Big Data zawsze wymaga tylko lokalnych arkuszy kalkulacyjnych.",
      "C": "W Big Data kluczowe są aspekty Volume, Velocity, Variety, natomiast w klasycznym BI przetwarza się dane o stosunkowo ustabilizowanej strukturze i niskiej dynamice.",
      "D": "W klasycznej analizie BI nie występują żadne relacje między tabelami, a w Big Data zawsze korzysta się z JOIN."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 736
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych poprawnie wskazują różnice między poszczególnymi operacjami CRUD (Create, Read, Update, Delete)?",
    "options": {
      "A": "Create tworzy nowy rekord, Read pobiera i wyświetla dane, Update modyfikuje istniejące dane, a Delete je usuwa.",
      "B": "Read zapisuje rekord, a Create czyta zapisany stan procesora.",
      "C": "Update usuwa rekord, a Delete zmienia wartości pól w bazie.",
      "D": "Create i Update działają tylko w relacyjnych bazach danych, a Read i Delete w NoSQL."
    },
    "correct": [
      "A"
    ],
    "auto_id": 737
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia pokazują różnice między testami jednostkowymi a integracyjnymi w aplikacjach internetowych?",
    "options": {
      "A": "Testy jednostkowe sprawdzają izolowane funkcje czy klasy, a testy integracyjne – współpracę między modułami (np. backend i baza).",
      "B": "Testy jednostkowe zawsze dotyczą wydajności, natomiast integracyjne skupiają się na atakach bezpieczeństwa.",
      "C": "W testach integracyjnych sprawdza się poprawność interakcji (np. API + warstwa logiki), a w jednostkowych – szczegółowe zachowanie jednej metody.",
      "D": "Testy jednostkowe można wykonywać tylko w środowisku produkcyjnym, a integracyjne w środowisku lokalnym."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 738
  },
  {
    "type": "multi_select",
    "question": "Które z poniższych odpowiedzi wskazują różnice między bazami dokumentowymi a kolumnowymi w NoSQL?",
    "options": {
      "A": "Bazy dokumentowe przechowują dane w postaci JSON/ BSON (np. MongoDB), a kolumnowe (np. Cassandra) organizują dane w kolumny, co sprzyja analizie dużych zbiorów.",
      "B": "Kolumnowe są przeznaczone wyłącznie do danych binarnych, a dokumentowe tylko do liczb całkowitych.",
      "C": "Dokumentowe bazy nie pozwalają na indeksowanie, kolumnowe mają indeksy dla każdej kolumny.",
      "D": "W bazach dokumentowych zapisujemy całą strukturę obiektu w jednym dokumencie, a kolumnowe dzielą dane na klucze i zestawy wartości w kolumnach."
    },
    "correct": [
      "A",
      "D"
    ],
    "auto_id": 739
  },
  {
    "type": "multi_select",
    "question": "Które ze stwierdzeń poprawnie ukazują różnice między bazami relacyjnymi a NoSQL?",
    "options": {
      "A": "Relacyjne bazują na tabelach i SQL, NoSQL oferują różne modele (dokumenty, kolumny, key-value, graf) i zwykle elastyczne schematy.",
      "B": "Bazy relacyjne zawsze przechowują dane w formacie JSON, a NoSQL w CSV.",
      "C": "NoSQL często lepiej radzi sobie ze skalowaniem poziomym, relacyjne kładą nacisk na spójność i transakcje ACID.",
      "D": "Relacyjne nie obsługują żadnych indeksów, NoSQL zawsze ma indeks na każdą kolumnę."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 740
  },
  {
    "type": "multi_select",
    "question": "Które ze stwierdzeń poprawnie podkreślają różnice między zagrożeniami w bazach danych a zagrożeniami w warstwie sieci?",
    "options": {
      "A": "Zagrożenia baz danych często obejmują SQL Injection lub brak autoryzacji do tabel, a zagrożenia sieciowe to DDoS, sniffing, podsłuch ruchu.",
      "B": "Ataki na warstwę bazy zwykle skupiają się na manipulowaniu zapytaniami, a w warstwie sieci – na przechwytywaniu pakietów lub atakach typu MitM.",
      "C": "Warstwa sieci jest nietykalna, więc wszystkie ataki muszą przejść przez bazę danych.",
      "D": "W bazach danych nie używa się protokołów szyfrowania, a w sieci zawsze jest ono domyślnie włączone."
    },
    "correct": [
      "A",
      "B"
    ],
    "auto_id": 741
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie różnicują zagrożenia w systemach operacyjnych od tych w bazach danych?",
    "options": {
      "A": "Zagrożenia OS dotyczą głównie luki w kernelu, eksploitów czy rootkitów, a w bazach danych – SQL Injection i braku spójności referencyjnej.",
      "B": "W systemach operacyjnych nie istnieje koncepcja uprawnień, a w bazach jest obowiązkowa.",
      "C": "Systemy operacyjne narażone są na ataki typu eskalacja uprawnień, a bazy danych na niewłaściwą konfigurację dostępu do tabel i wstrzykiwanie złośliwego kodu.",
      "D": "W systemach operacyjnych używamy wyłącznie klucza obcego, a w bazach danych – klucza głównego."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 742
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie wskazują różnice między zagrożeniami w sieciach komputerowych a w systemach operacyjnych?",
    "options": {
      "A": "W sieciach komputerowych przeważają ataki typu sniffing, DDoS, MitM, a w systemach operacyjnych – rootkity, eskalacja uprawnień.",
      "B": "Zagrożenia sieciowe nie wymagają żadnych poprawek bezpieczeństwa, podczas gdy w systemach operacyjnych łata się kernel.",
      "C": "System operacyjny może być celem ataku lokalnego, a sieci komputerowe ataku zdalnego, choć często te sfery się przenikają (np. exploit w protokole sieciowym).",
      "D": "Każdy atak w sieci komputerowej zawsze dotyczy tylko bazy danych, a w systemach – jedynie plików .exe."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 743
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie oddają różnice między protokołem TCP a UDP w modelu TCP/IP?",
    "options": {
      "A": "TCP zapewnia niezawodność, kontrolę przepływu i kolejność pakietów, UDP jest szybsze, lecz bez gwarancji dostarczenia i kolejności.",
      "B": "W UDP konieczne jest tworzenie połączenia i trzymanie stanu, w TCP nie ma takiej potrzeby.",
      "C": "TCP jest używane m.in. przez HTTP, FTP, a UDP – często przez aplikacje czasu rzeczywistego (np. transmisje wideo, VoIP).",
      "D": "UDP ma większy narzut na pakiet, bo przechowuje liczne informacje sterujące, a TCP jest minimalistyczne."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 744
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie przedstawiają różnice między ERD a diagramem klas w UML?",
    "options": {
      "A": "ERD skupia się na encjach i relacjach (bazodanowych), a diagram klas opisuje obiekty, ich atrybuty i metody w kontekście obiektowym.",
      "B": "Diagram klas zawsze wymaga definicji klucza głównego, a ERD nie.",
      "C": "ERD służy głównie do projektowania struktur danych w bazach, a diagram klas do projektowania struktury kodu w programowaniu obiektowym.",
      "D": "W diagramie klas relacje są wyłącznie 1:1, a w ERD zwykle 1:N."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 745
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie wskazują różnice między wymaganiami funkcjonalnymi a niefunkcjonalnymi?",
    "options": {
      "A": "Funkcjonalne mówią, co system ma robić (np. rejestracja, wyszukiwanie), a niefunkcjonalne – jak dobrze ma to robić (wydajność, bezpieczeństwo, dostępność).",
      "B": "Niefunkcjonalne odnoszą się wyłącznie do testów regresyjnych w CI/CD, a funkcjonalne do warstwy sieciowej.",
      "C": "Funkcjonalne określają zadania i zachowania systemu, a niefunkcjonalne – ograniczenia i cechy jakościowe (np. maksymalny czas odpowiedzi).",
      "D": "Wymagania niefunkcjonalne nie mają wpływu na projektowanie, a funkcjonalne determinują całą architekturę."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 746
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie opisują różnice między bezpośrednim połączeniem aplikacji (internetowej/mobilnej) z bazą danych a dostępem za pośrednictwem warstwy backend?",
    "options": {
      "A": "Połączenie bezpośrednie naraża bazę na ekspozycję danych i brak kontroli logiki biznesowej, natomiast backend pozwala walidować żądania i chronić bazę.",
      "B": "Warstwa backend może implementować dodatkową logikę (np. autoryzację, cache), a przy bezpośrednim połączeniu aplikacja musi sama wszystko obsłużyć.",
      "C": "Bezpośrednia komunikacja jest zawsze bezpieczniejsza, bo nie ma pośrednika.",
      "D": "Backend pozwala na łatwe skalowanie i współdzielenie logiki między różnymi aplikacjami, a bezpośrednie połączenie jest trudniejsze w utrzymaniu."
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "auto_id": 747
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia dobrze pokazują różnice między kluczem głównym a kluczem obcym w relacyjnych bazach danych?",
    "options": {
      "A": "Klucz główny (PK) jednoznacznie identyfikuje rekord w swojej tabeli, a klucz obcy (FK) wskazuje na PK innej tabeli, tworząc relację.",
      "B": "Klucz obcy definiuje unikalność w danej tabeli, a klucz główny łączy dwie tabele ze sobą.",
      "C": "PK nie może mieć wartości NULL, a FK może, jeśli relacja dopuszcza brak skojarzonego rekordu nadrzędnego.",
      "D": "Klucz obcy zawsze zwiększa wartość automatycznie, a główny musi być wypełniany ręcznie przez użytkownika."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 748
  },
  {
    "type": "multi_select",
    "question": "Które ze stwierdzeń ukazują różnice między INNER JOIN i OUTER JOIN w zapytaniach SQL?",
    "options": {
      "A": "INNER JOIN zwraca wyłącznie rekordy pasujące w obu tabelach, a OUTER JOIN (LEFT/RIGHT/FULL) może zwrócić także niepasujące rekordy z jednej lub obu tabel.",
      "B": "OUTER JOIN jest zawsze szybszy od INNER JOIN przy dużych tabelach.",
      "C": "INNER JOIN wymaga warunku łączenia, a OUTER JOIN nie.",
      "D": "OUTER JOIN wypełnia brak dopasowań wartościami NULL, a INNER JOIN odrzuca wiersze bez dopasowania."
    },
    "correct": [
      "A",
      "D"
    ],
    "auto_id": 749
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie wskazują różnice między responsywnym a adaptacyjnym projektowaniem stron?",
    "options": {
      "A": "Responsywne projektowanie używa fluid layoutu i media queries, adaptacyjne często zakłada sztywno zdefiniowane layouty dla konkretnych rozdzielczości.",
      "B": "Projekt responsywny automatycznie dostosowuje elementy do rozmiaru okna, a adaptacyjny wybiera spośród kilku wersji layoutu.",
      "C": "Adaptacyjne projektowanie wymaga zawsze jednej wersji strony, a responsywne trzech różnych wersji.",
      "D": "Responsywne layouty są tworzone tylko za pomocą CSS, adaptacyjne – przez dynamiczne generowanie HTML po stronie serwera."
    },
    "correct": [
      "A",
      "B"
    ],
    "auto_id": 750
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia dobrze obrazują różnice między priorytetowym a round-robinowym planowaniem procesów?",
    "options": {
      "A": "Planowanie priorytetowe wybiera procesy o wyższym priorytecie najpierw, natomiast round-robin rozdziela CPU każdemu procesowi na równy kwant czasu w cyklu.",
      "B": "Round-robin nigdy nie pozwala na przełączanie kontekstu, a priorytetowe zawsze blokuje procesy niskiego priorytetu w nieskończoność.",
      "C": "Planowanie priorytetowe może wymagać obniżania priorytetu głodujących procesów, podczas gdy round-robin oferuje fairness (sprawiedliwość) kosztem czasem dłuższego oczekiwania na zakończenie procesu o wysokim priorytecie.",
      "D": "Round-robin działa tylko w systemach jednordzeniowych, priorytetowe w wielordzeniowych."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 751
  },
  {
    "type": "multi_select",
    "question": "Które odpowiedzi poprawnie wskazują różnice między kontami użytkowników a mechanizmem grup w systemie operacyjnym?",
    "options": {
      "A": "Konto użytkownika to indywidualny profil z hasłem i UID, grupa to logiczne zrzeszenie użytkowników posiadających wspólne uprawnienia.",
      "B": "Grupy ułatwiają nadawanie uprawnień wielu kontom naraz, a bez grup trzeba by konfigurować dostęp każdemu użytkownikowi osobno.",
      "C": "Grupy mogą mieć również hasła, a konta nie.",
      "D": "Konto użytkownika zawsze obsługuje wiele procesów, a grupa dotyczy zarządzania pamięcią podręczną systemu."
    },
    "correct": [
      "A",
      "B"
    ],
    "auto_id": 752
  },
  {
    "type": "multi_select",
    "question": "Które odpowiedzi poprawnie opisują różnice między Wi-Fi a Bluetooth w kontekście sieci bezprzewodowych?",
    "options": {
      "A": "Wi-Fi ma zwykle większy zasięg i przepustowość, Bluetooth jest projektowany do krótkiego zasięgu i mniejszej szybkości przesyłu.",
      "B": "Bluetooth nie wymaga żadnych protokołów bezpieczeństwa, Wi-Fi zawsze jest szyfrowane WPA2.",
      "C": "Bluetooth może służyć do parowania urządzeń (np. słuchawki, mysz), Wi-Fi pozwala na dostęp do Internetu i tworzenie większych sieci lokalnych.",
      "D": "Wi-Fi używa wyłącznie pasma 2,4 GHz, a Bluetooth jedynie 5 GHz."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 753
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie wskazują różnice między frontendem a backendem w kontekście logiki biznesowej i odpowiedzialności za dane?",
    "options": {
      "A": "Frontend jest odpowiedzialny głównie za prezentację i interakcję z użytkownikiem, a backend za obróbkę danych, wykonywanie zapytań do bazy oraz uwierzytelnianie.",
      "B": "Backend zawsze jest napisany w JavaScript, a frontend w Pythonie.",
      "C": "Frontend nie powinien zawierać kluczy dostępu do bazy, backend może bezpiecznie zarządzać połączeniem do DB i weryfikować poprawność żądań.",
      "D": "Backend nie może komunikować się z bazą danych w czasie rzeczywistym, a frontend generuje wywołania SQL na serwerze."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 754
  },
  {
    "type": "multi_select",
    "question": "Które stwierdzenia poprawnie ukazują różnice między architekturą trójwarstwową a mikrousługami?",
    "options": {
      "A": "W trójwarstwowej mamy wyraźny podział na UI, logikę biznesową i bazę, mikrousługi dzielą aplikację na wiele małych serwisów, każdy może mieć własną logikę i bazę.",
      "B": "Architektura mikrousług zawsze działa na jednym serwerze bez możliwości skalowania, a trójwarstwowa skaluje się w poziomie.",
      "C": "W trójwarstwowej logika jest centralna, w mikrousługach każdy serwis realizuje określoną część funkcjonalności i komunikuje się przez sieć.",
      "D": "Mikrousługi nie wymagają żadnych testów integracyjnych, a trójwarstwowa architektura jest całkowicie odporna na awarie jednego modułu."
    },
    "correct": [
      "A",
      "C"
    ],
    "auto_id": 755
  },
  {
    "type": "multi_select",
    "question": "Które odpowiedzi poprawnie pokazują różnice między web scrapingiem a zasilaniem hurtowni przez klasyczny proces ETL?",
    "options": {
      "A": "Web scraping pobiera dane bezpośrednio z kodu HTML stron, a klasyczne ETL często korzysta z ustrukturyzowanych źródeł (np. pliki CSV, bazy relacyjne) i transformuje je przed załadowaniem do hurtowni.",
      "B": "W web scrapingu trzeba analizować dynamiczną strukturę strony, w ETL zwykle mamy stabilne formaty wejściowe.",
      "C": "Proces ETL nie wymaga żadnej transformacji danych, bo dane są już w znormalizowanej formie, a web scraping zawsze je oczyszcza i łączy z kluczem głównym.",
      "D": "Web scraping jest bardziej podatny na zmiany layoutu strony, podczas gdy ETL zakłada raczej stały schemat w źródłach."
    },
    "correct": [
      "A",
      "B",
      "D"
    ],
    "auto_id": 756
  }
]